今天的主要任务：
    回顾Cookie：知识点多，但是应用比较简单

        掌握重点：，Cookie的细节操作
            Cookie的执行原理：
                基于Set-cookie 响应头以及 cookie 请求头 实现的

    1.session的介绍
    2.jsp的常规操作以及原理


1. session的概念

    域对象：request对象，servletContext对象，session对象
    域对象：tomcat服务器接收请求时，
            会自动创建一些对象：servlet、HttpServletRequest、HttpServletResponse
            它们能够共享数据
            共同的特征：全都不是程序员自己创建的，都是由tomcat服务器创建的！！


    session是一个域对象。

    session是：服务器端数据存储技术，
               实现了一次会话中，多次请求多次响应之间的数据共享。

    session存储的数据相对安全，不会泄露相关信息。
    session的应用场景：一般用于记录，登录用户的相关信息：
                    比如：用户的id  或者是  user对象

2. session的基本操作

    创建一个day15-session项目，
    创建一个package包：cn.tedu.session
    创建一个servlet类：Session01

    与request对象相似：
    session.setAttribute(key,value);
    session.getAttribute(key);
    session.getAttributeNames();
    session.removeAttribute();
    session.invalidate();//清空session

    总结：1. session是服务器端技术，它的操作以及生成都是后端代码
          2. session的存储 也是存在于 服务器端的
          3. request.getSession();  该方法是与request对象相关，与response响应无关

3. session 的作用域

    request对象（请求转发中）  <  session对象（一次会话中）  < servletContext对象（整个web应用中）

    在一次会话中，多次请求多次响应，整个过程中，session一直存在。

    session是存在于服务器端的，存放的数据更加的隐私。

4. session的原理 ：查看底层API源码

    session对象时基于 JSESSIONID 的cookie工作的。

        第一次请求时：生成的session对象的id，会响应到cookie中
            SeT - Cookie: JSESSIONID= 4365456SADA123

        第N次请求时，通过JSESSIONID 去 匹配获取 session对象

        那么这多次请求中，因为JSESSIONID是相同的，所有sessin的数据是实现了共享

5. session的细节：

    1. 当浏览器关闭后，重新打开访问服务器，那么访问的session是同一个对象吗？
        答案：默认情况下不是
        因为：每一次关闭浏览器。JSESSIONID会被清除。所有每一次重新打开浏览器，
            访问的都是不同的session对象，因为JSESSIONID是不同的
            JSESSIONID=E74C80AD590A65B9F829397E549048C6
            JSESSIONID=AFA36F25C64A2056E877712CD82B3D62

        持久化解决方案：

            Cookie cookie = new Cookie("JSESSIONID",session.getId());
            cookie.setMaxAge(60*60);
            response.addCookie(cookie);

            JSESSIONID=020831C4CB6935938FD604BFFBA13BFB
            JSESSIONID=020831C4CB6935938FD604BFFBA13BFB

    2. 当浏览器不关闭，服务器关闭时，服务器重启之后，访问是同一个sesison吗 ？
        答案：默认情况不是
        因为：session对象在服务器关闭后，会被从内存中清理掉
              下次的session对象 是一个新的session对象

        session如何保证：服务器关闭前后，都是同一个session呢？？？

        解决方案：tomcat已经给我们解决了。
        技术支持：
            对象的序列化 ： 把内存中的对象存储到硬盘中，相当于把内存中的对象保存起来
            对象的反序列化 ：当下次使用这个对象的时候，可以把硬盘中的文件 解析到内存，
                            那么 我们的内存中 这个对象有存在了。
        演示过程：tomcat的session的序列化与反序列化

            1.找到day15-session这个项目，然后找到它的output输出路径：编译之后的项目
            2. 把项目打包成war包：day15-session.war
            3. 把这个war包，放入到tomcat服务器中（不适用IDEA,使用tomcat\bin）

        演示过程：idea进行session的序列化与反序列化
            问题：idea关闭tomcat时，会把session进行序列化
            但是，当idea重新启动tomcat时，会自动的把序列化之后的文件删除，
                所以，使用idea演示 浏览器不关闭，服务器关闭时 这个场景时，
                并不能看到反序列化的过程，因为 序列化文件被删除了

    3. session不进行持久化工作时，session对象在内存中多长时间会失效？？

        答案：默认情况是 30分钟 【tomcat7\conf\web.xml中】

        <session-config>
                <session-timeout>30</session-timeout>
        </session-config>

        如果session失效了，会发生什么问题？？
            比如：登录了一个网站，session存储了用户的登录信息。
                  如果用户在半小时中，不进行任何操作（挂机）
                  过一段时间回来，会提示：请重新登录。

6. session与cookie的区别

    1.session是存储在服务器端，cookie是存储在浏览器端
    2.session没有数据大小的显示，cookie是由大小限制
    3.session的数据保存是安全的，cooke的数据是相对不安全的

7.综合案例：注册页面的【验证码】

    准备工作：需要的资源Util工具类
     【课后资料\day14-cookie-PMALL\资源\VerifyCode】

    VerifyCode中的方法：

        drawImage:生成一张验证码图片 ，
                该图片最终是要显示到页面上的，给用户看到

        getCode() ：验证码中的图片的数字，一定是正确的验证码
                该数字是专门用于 对比用户输入的 验证码
                该数字是存储于 session 对象中，一次会话中生效

    regist.jsp页面：验证码的<img />

        <img src="img/regist/yzm.jpg" width="" height="" alt="" />

        img/regist/yzm.jpg ： 是一个写死的静态的图片

        需要改造：当点击图片时，图片更换一张验证码，需要发送一个请求
                  当页面刷新时，图片更换一张验证码，需要发送一个请求
    创建一个Servlet类：cn.tedu.servlet/ValidateCodeServlet.java
        缓存【控制浏览器不适用缓存】
        接受【更换验证码的请求】
        获取【一张验证码图片】
        获取【验证码的正确code，存放到session中】
        响应【输出流输出图片】

    打开RegistServlet.java类：需要验证用户输入的验证码是否正确





