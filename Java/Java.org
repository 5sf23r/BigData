* Java的简介
  1995年由SUN公司推出的一款高级编程语言（Oak橡树），面向互联网编程，安全可靠、面向独享、跨平台等特点
** 语言特点
*** 跨平台（操作系统）
JVM（java虚拟机），想在不同平台运行java应用程序，需要在相应平台安装与之对应的运行环境（JVM）
把java应用程序放到JVM中运行，使得相同的应用程序得到的结果一样，进而屏蔽了底层操作系统的差异性
[[./img/1.jpg]]
** 三大技术架构
J2se、J2ee、J2me；Jdk1.5位里程碑的版本，其中J2se更名为JavaSe，J2ee更名为JavaEE，J2ME更名为JavaME
*** J2se
Standard Edition 基础版--提供小型程序或者桌面服务解决方案
*** J2ee
Enterprise Edition 企业版--提供了企业中遇到的集中化或者模块化开发的解决方案
*** J2me
Micro Edition 小型版--终端的嵌入式开发提供了可能
** 搭建Java语言环境
- JRE（java Runtime Environment）java应用程序所需要的运行环境
- JRE = JVM + 核心类库（java程序启动的时候所必需的信息）
- JDK（java Development Kit）java的开发环境以及运行环境
- JDK = JRE + 开发工具包

- 从大到小排列
  + JVM-->JRE-->JDK
安装JDK不可以出现空格和中文
** 人机交互的方式
1. 图形界面
2. 命令行模式
** 命令提示符
1. win+r
2. 地址栏输入cmd
** 磁盘操作系统（Dos）的命令
1. dir展示当前目录下的所有信息
2. cd翻转目录（cd.. :返回上一级）
   cd/：返回根目录（当前盘符）
** 环境变量
操作系统指定当前操作环境的参数
PATH = JDK bin文件夹所在地址
*** 自定义环境变量
JAVA_HOME = JDK的安装目录
PATH = %JAVA_HOME%\bin
** 包
package cm.tedu.exer
#+BEGIN_SRC java
package cm.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
[[./Source Code/PackageDemo.java]]
*** 带包编译和运行
#+BEGIN_SRC java
package cn.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
[[./Source Code/PackageDemo.java]]
#+BEGIN_SRC java
package cm.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
[[./Source Code/PackageDemo1.java]]
**** 编译
-d：新建目录;表示在编译的时候需要将包生成对应的文件夹
 .：当前目录
  E:\\ 编译之后产生的文件夹的存放位置
  javac -d . PackageDemo.java
  javac -d E:\\ PackageDemo1.java
**** 运行
Java 包名.类名
java cn.tedu.exer.PackageDemo
java cm.tedu.exer.PackageDemo1
** 案例：输出HelloWorld
*** 定义一个类
class HelloWorld{}
*** 定义main方法
#+BEGIN_SRC java
public static void main(String[] args){}
#+END_SRC
#+BEGIN_SRC java
class HelloWorld{
    public static void main(String[] args){}
}
#+END_SRC
**** main主函数的主要作用：
1. 可以让类单独运行
2. 是程序的入口
3. 被JVM调用
4. 输出语句
   System.out.println("helloworld");
*** 总结：
.java文件（源文件）经过编译成为.class文件（二进制文件/字节码文件）
编译时期（检测代码的语法问题）
运行时期（执行代码的逻辑）
*** 注意：
1. .class文件名称和类名一致
2. 公共类的类名要和.java文件的文件名称保持一致
3. .java文件中只能最多有一个公共类
4. .java文件中可以存储多个类，有几个类就会生成几个.class文件，如果出现大小写的问题就看最后一个
** 注释
*** 书写格式
编译时，编译器会忽略注释的存在。
**** 单行注释
//注释内容
**** 多行注释
/*
  注释内容
*/
- 可以嵌套单行注释，不可以嵌套多行注释
**** 文档注释
/**
  注释内容
*/
通过javadoc命令对注释的内容进行抽取，抽取到文档中（程序员说明书）
** 关键字
在java中被赋予了特殊含义的单词，53个关键字，两个保留字（const,goto也是关键字）

在java中所有的关键字都是小写的

[[./img/16.png]]
** 标识符
在java中可以自定义的名称,就是名称的意思，所有的名称统称为标识符。
*** 组成元素
- 英文字符：a~z A~Z
- 数字：0~9
- 符号： _ $(一般不推荐使用$)
*** 标识符规则
- 数字不能开头
- 不可以使用关键字
- 严格区分大小写，不限制起名长度，尽量达到见名知意
*** 命名的规范
一个标识符可以由一个单词或者多个单词拼接而成
驼峰命名法：
- 类名字/接口名字
  首字母大写，第二个单词首字母大写
  AaaBbbCcc
  HelloWorld Demo
  UserService
  ProdService
- 方法的名字/变量名字
  首字母小写，每个单词首字母大写
  xxxYyyZzz
  helloWorld demo
  String userName = "zs";
  int userId=3;
- 如果用作常量名称，则所有单词全部大写，单词之间用下划线连接
  final PI_NUM=3.14;
- 转悠名词通常全部大写
  String NBA="nba";
- 包名
  单级：xxx
  多级：xxx.yyy.zzz(cn.tedu.day01)(这个整体不是标识符，cn是标识符,tedu是标识符
  ,day01是标识符)
- 常用名
  XXX_YYY_ZZZ
** 数据
*** 程序概述
程序 = 数据+逻辑
*** 数据类型
- 基本数据类型
  整数、浮点、字符、 布尔
- 引用数据类型
  数组、类、接口
*** 常量
在代码的执行过程中值不发生改变的量
**** 整数类型
**** 浮点类型
如1.0、-3.15、3.168等
**** 布尔类型
true false
**** 字符类型
如'a' 'A' '0' '家'
字符必须使用''包裹，并且其中智能且仅能包含一个字符
**** 字符串类型
字符串String类型是一种引用类型
如"我爱你"  "01234" "null"
字符串必须使用""包裹，其中可以包含0~N个字
**** 空常量
null
*** 整数的四种不同的表现形式(进制)
进制：进位的一种方式（逢X进1）
计算机底层用的是二进制
**** 二进制：
0~1，满2进1，1+1=10，11+1=100，在JDK1.7之前，程序中不允许定义二进制数字；
从JDK1.7开始，允许在程序中定义二进制数字,但必须以0b/0B作为开头
0b000111 0B101101
**** 八进制：
0~7，满8进1，7+1=10，17+1=20，77+1=100，要求以0作为开头  05
**** 十进制：
0~9，满10进1，数字如果没有特殊表示，就默认是十进制
**** 十六进制：
0~9，a~f，满16进1，8+1=9，9+1=A，A+1=B，F+1=10，39+1=3A,99+1=9a
，9f+1=A0，ff+1=100，要求以0X/0x作为开头 0x5 0xAF
**** 举例
#+BEGIN_SRC java
class JavaDemo2{
    public static void main(String[] args){
        //输出二进制数
        System.out.println(0b100);
        //输出八进制
        System.out.println(0100);
        //输出十进制
        System.out.println(100);
        //输出十六进制
        System.out.println(0x100);
    }
}
#+END_SRC
[[./Source Code/JavaDemo2.java]]
**** 进制转换
***** 其他进制转换为十进制
****** 二进制转换为十进制
从低位次（数字最右边是低位次）开始，按位次乘以2的位次次幂，然后求和

[[./img/2.png]]

100 ---> 4

=1*2^2 + 0*2^1 + 0*2^0

=4

1101 ---> 13

= 1*2^0 + 0*2^1 + 1*2^2 + 1*2^3

=13
****** 十六进制转换为十进制
[[./img/3.png]]

522 ---> 1314

=5*16^2 + 2*16^1 + 2*16^0

=1314

基数：X进制 X

位：每位上的数

权：从右往左由0开始编号

规律：位乘以基数的权次幂之和
***** 十进制转换为其他进制
****** 十进制转换为二进制
[[./img/4.png]]

十进制 14 ---> 二进制 1110

规律：除基取余，直至商为0，余数翻转
***** 任意进制直接的转换
****** 二进制向八进制转换
[[./img/10.png]]

三变一----从低位次开始，每三位二进制划分为一组，产生一个八进制数字，最高位可能不足三位，补0，补齐三位，然后也产生一个八进制数字

1100110 = 0146

001 100 110

001 = 1

100 = 4

110 = 6
****** 八进制向二进制转换
[[./img/11.png]]

一变三----每一位八进制都会产生三位二进制数字

0527 = 101 010 111

   5 = 101

   2 = 010

   7 = 111
****** 二进制转十六进制
[[./12.png]]

四变一----每四位产生一位十六进制

1110101101 = 0x3ad

      1101 = d(13)

      1010 = a(10)

      0011 = 3
****** 十六进制转二进制
[[./9.png]]

一变四

0xe3c = 1110 0011 1100

e(14) = 1110

    3 = 0011

c(12) = 1100

****** 以十进制为中转进行转换
X进制先转为十进制，这个十进制转换为Y进制

[[./5.png]]

二进制 101 ---> 八进制 5

= 1*2^2 + 1*2^0

= 5

****** 15*4=120是几进制？
将对应的进制设为n，将等号两边的都转换为10进制进行计算

(5*n^0 + 1*n^1)*(4*n^0) = 0*n^0 + 2*n^1 + 1*n^2

****** 拆分组合
三个二进制的数范围为0~7（000~111），0~7可以看做是8进制

[[./6.png ]]

******* 二进制--->八进制（三变一）
从低位次开始，每三位二进制划分为一组转换为十进制数，最高位可能不足三位，用0补齐三位

1100110 ---> 001100110 ---> 001 100 110 ---> 1 4 6

1100110 ---> 0146(八进制以0开头)
******* 八进制--->二进制（一变三）
0527 ---> 101010111
******* 二进制转换为十六进制（四变一）
1110101101 ---> 0011 1010 1101 ---> 3 10 13 ---> 3 a d ---> 0x3ad
******* 十六进制--->二进制（一变四）
0xe3c ---> e 3 c ---> 14 3 12 ---> 1110 0011 1100 ---> 111000111100
**** 小数十进制转为二进制
3.28 = 11.0 1 0 0 0 1 1 1...

0.28*2 = 0.56*2 = 1.12->0.12*2 = 0.24*2 = 0.48*2 = 0.96*2 = 1.92->0.92

整数部分除以2转换为二进制，小数部分乘以2取结果的整数部分，然后继续乘以2取结果整数部分，无限循环...

绝大部分小数底层二进制是一个无限位数，表示的不精准，导致计算机在存储小数的时候是不精准的

**** 有符号的数（原码、反码、补码）
计算机的底层运算是以二进制的补码进行运算的

所有的数据在底层都是二进制数据补码形式表示的原码、反码、补码

***** 表示有符号的数去表示5和-5
|------+--------+---------|
| 原码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 0000101 |
|------+--------+---------|
正数的符号位是0，负数是1
|------+--------+---------|
| 反码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 1111010 |
|------+--------+---------|
正数的反码和原码一致，负数的反码是在原码的基础上符号位不变，其他为取反
|------+--------+---------|
| 补码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 1111011 |
|------+--------+---------|
正数的原、反、补一致，负数
的补码是在反码的基础上符号位不变，其他在反码的基础上+1
***** 计算机的底层运算是以二进制的补码进行运算的
-4+1 = -3
|----------+----------+----------+----------+------+----|
| 10000000 | 00000000 | 00000000 | 00000100 | 原码 |    |
| 11111111 | 11111111 | 11111111 | 11111011 | 补码 | -4 |
| 11111111 | 11111111 | 11111111 | 11111100 | 反码 |    |
|----------+----------+----------+----------+------+----|
|          |          |          |          |      | +1 |
|----------+----------+----------+----------+------+----|
| 11111111 | 11111111 | 11111111 | 11111101 | 补码 |    |
| 11111111 | 11111111 | 11111111 | 11111100 | 反码 | -3 |
| 10000000 | 00000000 | 00000000 | 00000011 | 原码 |    |
|----------+----------+----------+----------+------+----|

* Java基本语法组成
** 变量
- 变量概述
  在代码执行过程中值发生改变的量
  变量是内存中装载数据的容器
*** 计算机存储单元
- 在计算机中，是以二进制形式来存储数据，每一位二进制在内存中称之为一“位”(bit,简写为b)
- 变量是内存中最小的容器，用来存储数据
- 计算机存储的最小单位叫 "位（bit）"，又称之为"比特位"，通常以小写的"b"表示
- 计算机存储空间的计量单位为"字节（byte）为最小的存储单元，通常用大写"B"表示，字节由连续的8个位组成
  8bit = 1byte
  1024B = 1KB
  1024KB = 1MB
  1024MB = 1GB
  1024GB = 1TB
      ...
  100Mb = 12.5MB
*** 基本类型之4类8种
- 数据类型分为基本数据类型和引用数据类型（数组、类、接口）
- 变量必须要有明确的类型，什么类型的变量装载什么类型的数据
  + 基本数据类型（4类8种）
    1. 整型
                                         占用内存（字节）                  表示范围
           byte（字节）                        1                  -128（-2^7） ~ 127(2^7-1)
           short（短整型）                     2                 -23767-(2^15) ~ 32767(2^15-1)
           int（整型）                         4            -2147483648(-2^31) ~ 2147483648(2^31-1)
           long（长整型）                      8                        -2^63  ~ 2^63-1
    2. 浮点型
           float（单精度）                     4             -3.403E38(-10^38) ~ 3.403E38(10^38)
           double（双精度）                    8           -1.798E308(-10^308) ~ 1.798E308(10^
    3. 布尔型
           boolean                            1                     只有两个值true与false
    4. 字符型
           char                               2                            0 ~ 65535   表示一个字符，如（'a' 'A' '0' '家'）
           - 文字转成数字---编码     转换规则--编码表
  + 4e4 = 4*10^4 表示十进制的科学计数法
  + 0x5p3 = 5*2^3 表示的是十六进制的科学计数法

  + 整数默认为int，小数默认为double
  + long类型需要在结尾添加l/L作为标识：long l = 10L;
  + float类型需要在结尾添加f/F作为标识：float f = 3.5f;
  + 一个字符直接量只能代表一个字符，不可以在一个字符直接量中写入多个字符，不允许有空的字符直接量
    [[./13.png]]
  + 引用数据类型（复杂数据类型）
**** 表示范围是怎么来的
***** 整数类型
      byte ---> 1byte = 8bit ---> 1bit表示两个二进制数：0或者1;2bit表示四个二进制
          数：00、11、01、10;3bit表示8个二进制数：000、001、011、010、111、101、
          110、100,以此类推,1byte表示2^8（256）个二进制数，正数最大的是01111111也可以理解为10000000-1（2^7-1）
          所以范围为：-128~127
      short ---> 2byte = 16bit ---> -2^15 ~ 2^15 - 1
      int ---> 4byte = 32bit ---> -2^31 ~ 2^31 - 1
      long ---> 8byte = 64bit ---> -2^63 ~ 2^63 - 1
***** 浮点型
      float --->4byte

**** 文字转成数字----->编码
     字符在存储过程中需要按照某周规则转化为数字，这种转化规则称之为编码，记录编码形成的表格形式称之为编码表---码表
     转换规则          ----->                 编码表
     ASCII                        （阿斯科码表  128位 占一个字节）
     ISO8859-1                    （西欧码表    256位 占一个字节）
     GB2312                       （简体中文          占两个字节）
     Big5                         （繁体              占两个字节）
     GBK                          （国标码            占两个字节）
     Unicode编码体系               （utf-8占三个字节 utf-16占两个字节 utf-32）
     char c = 'a' '中'; 用的是GBK，内存占几个字节？
     'a'占一个字节
     '中'占两个字节
     所有的完整码表默认兼容西欧码表
**** 转义字符
     [[./14.png]]
*** 常量与类型
- java中默认的整数类型是int类型
- java中默认的浮点型是double类型
  1. 3.14没有后缀，所以为double类型
  2. 5.28D为double类型
  3. 1.26F为float类型
*** 定义变量(创建变量)
**** 数据类型
限制数据的变化范围
**** 变量名
区分其他变量
**** 初始化
保证变量操作之前有数据
**** 定义格式
数据类型 变量名 = 数据值;
int    a    =  100;
**** 变量声明
int j;
**** 变量赋值
j = 6;
#+BEGIN_SRC java
/*
  定义Java中的变量
  定义出所有数据类型的变量
  四类八种
,*/
class VariableDemo{
    public static void main(String[] args){
    //定义整数类型，字节类型byte类型
    //内存中1个字节，-128 ~ 127
    byte b = 100;
    System.out.println(b);

    //定义整数类型，短整型，short类型
    //内存中2个字节，-32768 ~ 32767
    short s = 200;
    System.out.println(s);

    //定义整数类型，整型，int类型
    //内存中4个字节，-2147483648 ~ 2147483647
    int i = 500006;
    System.out.println(i);

    //定义整数类型，长整型，long类型
    //内存中8个字节
    long l = 21474836470L;
    System.out.println(l);

    //定义浮点数据类型，单精度，float类型
    //内存中4个字节
    float f = 1.0F;
    System.out.println(f);

    //定义浮点数据类型，双精度double类型
    //内存中8个字节
    double d = 2.2;
    System.out.println(d);

    //定义字符类型，char
    //内存中2个字节，必须单引号包裹，只能写1个字符
    char c = '我';
    System.out.println(c);

    //定义布尔类型，boolean
    //内存中1个字节，数据值，true false
    boolean bool = true;
    System.out.println(bool);
    }
}
#+END_SRC
*** 定义字符串变量
#+BEGIN_SRC java
/*
  常量：字符串，双引号，包裹，“0 ~ n”
,*/
class Variable_1{
    public static void main(String[] args){
        //定义变量，字符串类型，数据类型String表示字符串的数据类型
        String s = "我爱Java";
        //String属于引用类型，定义方式和基本类型一样
        System.out.println(s);

    }
}
#+END_SRC
*** 变量定义使用注意事项
- 变量定义后可以不赋值，使用时在赋值，不赋值不能使用
  #+BEGIN_SRC java
  class Variable_2{
      public static void main(String[] args){
          int x;
          x = 20;
          System.out.println(x);
      }
  }
  #+END_SRC
- 变量使用是有自己的作用范围，变量的有效范围是只在定义的一对大括号内
  #+BEGIN_SRC java
  class Variable_3{
      public static void main(String[] args){
          int i = 5;
          System.out.println(i);
          {
              int j = 10;
          }
          System.out.println(j);
          }
      }
  #+END_SRC
- 变量不可以重复定义
*** 数据类型转换
范围小的数据类型值（如byte），可以直接转换为范围大的数据类型值（如int）

byte、char、short只要做操作都会类型提升为int类型(byte、char、short在底层是按照int类型进行存储的)

范围大的数据类型值（如int），不可以直接转换为范围小的数据类型值（如byte）
#+BEGIN_SRC java
class DataTypeDemo{
    public static void main(String[] args){
        //相同数据类型
        int a=1;
        int b=2;
        System.out.println(a+b);
        //不同数据类型
        byte b1=3;
        int i=5;
        int c=b1+i;
        System.out.println(c);

        //byte --- short 可以
        /*byte b1 = 10;
        short c2=b;*/

        //java会进行类型检查，如果是字符就会安装对应的编码就会转换成对应的数值在赋值给变量s
        //如果这个数值不在变量的表示范围之内就会报错
        short s='中';
        char c3=97;
        System.out.prtinln(c);
        //除了char类型其他的基本类型都会有负值
        //可能会导致出现负值char找不到对应的字符
        /*double s=-10;
        char c=s;*/
        char c4=19;
        int i4=c4;
        System.out.println(c4);
    }
}
#+END_SRC
[[./7.png]]

[[./8.png]]

如果=右边只有常量进行运算就会进行编译时期的优化，就会直接算出结果值在进行赋值

[[./15.png]]

- 自动类型转换（范围小转大）
  范围大的数据类型 变量 = 范围小的数据类型值;
  double d = 1000;
- 强制类型转换（范围大转小）
  大类型可以强转为小类型，但是在转化的时候因为字节的损失所以可能导致数据不准确
  强制类型转换，没有要求的时候，不做
  范围小的数据类型 变量 = （范围小的数据类型）范围大的数据类型值;
  int i = (int)6.718; //i的值为6

  double d = 3.14;
  int i2 = (int)d;    //i2的值为3
  #+BEGIN_SRC java
  /*
    128 二进制
    00000000 00000000 00000000 10000000 int
    128int转为byte为：10000000 补码
                     11111111  反码
                     10000000  原码
    值为 -0   表示当前数据类型的最小值，为-128
  */
  class DataTypeDemo1{
      public static void mian(String[] args){
          //b11=-128
          byte b11 = (byte)128;
          System.out.println(b11);
      }
  }
  #+END_SRC
** 运算符
*** 算术运算符
**** 除法运算
- 如果都是整型数据进行操作，结果一定是整型
  i*1.0/j 结果就是浮点数
  #+BEGIN_SRC java
  class SuanShu{
      public static void main(String[] args){
          int i=900;
          int j=9;
          System.out.println(i/j);
          System.out.println(i*1.0/j);
      }
  }
  #+END_SRC
  [[./SuanShu.java]]
- 算术异常
  ArithmeticException:/by zero ---算术异常
  #+BEGIN_SRC java
  System.out.println(a/0);
  #+END_SRC
- Infinity -Infinity   正无穷大 负无穷大   java允许小数除0
  #+BEGIN_SRC java
  System.out.println(a*1.0/0);
  System.out.println(-a*1.0/0);
  #+END_SRC
- NaN -- not a Number
  #+BEGIN_SRC java
  System.out.println(-0.0/0.0);
  #+END_SRC
**** 取余%
取余结果的正负和%左边的正负一致
#+BEGIN_SRC java
System.out.println(-a%3);
#+END_SRC
**** ++ --
- 单独使用
  #+BEGIN_SRC java
  int a =4;
  int a1 = 4;
  //4
  System.out.println(a++);
  //5
  System.out.println(a);
  //4
  System.out.println(a1--);
  //3
  System.out.println(a1);

  //3
  System.out.println(--a);
  //3
  System.out.println(a);
  #+END_SRC
- 如果++或者--用在操作数的后面，先进行赋值，在进行自加或者更自减
- 如果++或者--用在操作数的前面，先自加1或者自减1，在进行赋值
- 参与运算
- =右边前面的值发生改变之后会影响后面的值
  #+BEGIN_SRC java
  b =++a+a--+a++;
  //14
  System.out.println(b);
  //5
  System.out.println(a);
  #+END_SRC
  [[./17.png]]
- byte、char、short使用++时底层都有强制类型转换
  #+BEGIN_SRC java
  //-128
  byte b = 127;
  b++;
  System.out.println(b);
  #+END_SRC
  #+BEGIN_SRC java
  //b
  char c='a';
  c++;
  System.out.println(c);
  #+END_SRC
  #+BEGIN_SRC java
  //-32768
  short s=32767;
  s++;
  System.out.println(s);
  #+END_SRC
  #+BEGIN_SRC java
  /*
    算术运算符
    + 加法，连接
    - 减法
    ,* 乘法
    /除法
    % 取模，获取余数
    ++ 自加1
    -- 自减1

    byte/short/char在 运算的时候会自动提升为int
    int在计算完成之后结果一定是int
    小类型和大类型运算的时候结果一定是大类型
    整数/0---算数异常
    非零小数/0 非零数字/0.0---infinity
    0/0.0 0.0/0 0.0/0.0---NaN
    %的结果的符号看的是%左边数字的符号
    ++/-- 自增/自减 ---在变量之前先自增后运算；在变量之后先运算后自增---在底层做了一次强制转换
    任何数据在计算机中存储的补码

    ,*/
  class Operator{
      public static void main(String[] args){
          // + 连接作用，将一个字符串和其他数据连接起来
          // + 遇到字符串，变成连接符号
          // + 任何类型只要和字符串+，所有的数据都变成了字符串
          System.out.println("5+5="10);

          //byte/short/char在参与运算的时候会自动提升为int
          byte i = 3, j = 4;
          //byte k = i + j;
          //k的类型必须是int
          byte k = (byte)(i + j);
          int k = i + j;

          //除法运算
          //如果都是整型数据进行操作，结果一定是整型
          int i = 100;
          int j = 9;
          System.out.println(i/j);
          //以下操作得到的不是整型
          System.out.println(i*1.0/j);

          //取模运算，两个数相除，获取的是余数
          int k = 6;
          int m = 2;
          System.out.println(k%m);

          //自增运算 ++
          int a = 3;
          int b = 4;

          a++;
          System.out.println(a);

          ++b;
          System.out.println(b);
      }
  }
  #+END_SRC

  #+BEGIN_SRC java
  /*
    ++ 写在变量前面，和写在变量后面的区别
    a = 1;
    a++;
    ++a;
    变量独立计算的时候，++在前在后没有区别
    j = i++; ---> ++ 后算，先将i的值，赋值j，i自己在++

    n = ++m; ---> ++ 先算，后将++过的值赋给n

  ,*/
  class Opeartor_1{
      public static void main(String[] args){
          int j = 5;
          int j = i++;
          System.out.println(i);//6
          System.out.println(j);//5

          int m = 5;
          int n = ++m;
          System.out.println(m);//6
          Syetem.out.println(n);//6
      }
  }
  #+END_SRC
  #+BEGIN_SRC java
  class SuanShu1{
      public static void main(String[] args){
          int a = 4;
          int b = 5;

          //整型和浮点型数据遇到字符会和字符对应的编码值进行相加
          System.out.println(a + b + 'a');
          //字符串可以和任意数据类型的数据进行拼接
          System.out.println(a + b + "c" + 'a');
          // + 可以是相加，也可以是字符串连接符
          System.out.println(a + b);
          System.out.println("A:" + a + ",B:" + b);

      }
  }
  #+END_SRC
*** 赋值运算符
[[./18.png]]
#+BEGIN_SRC java
/*
  赋值运算符
  =
  += -= *= /= %= &= |= ^= <<= >>= >>>=
  ,*/
class Operator_4{
    public static void main(String[] args){
        //= 赋值运算，将后面的值，赋值给左边的变量
        int i = 3;
        i = i + 3;
        System.out.println(i);

        //+= 赋值运算符 i+=3 --->  i=i+3
        int j = 5;
        j+=6;//j=j+6;
        System.out.println(j);

        //byte char short 使用++ --时底层都是强制类型转换
        byte b = 1;
        // b = b + 1;//无法进行相加，需要进行强制转换
        b = (byte)(b+1);
        System.out.println(b);

        byte b1 = 1;
        b1 += 1;//等同于(byte)(b + 1);
        System.out.println(b1);

    }
}
#+END_SRC
**** b+=a;//11 b=a+b;底层会默认加上强制类型转换
      #+BEGIN_SRC java
          byte a=10;
          byte b=1;
          b+=a;//11 b=a+b;
          System.out.println(b);
      #+END_SRC
**** 连等定义？
      #+BEGIN_SRC java
          int x=y=z;//不支持
          int x=1,y=3,z=2;//支持
      #+END_SRC
**** 连等赋值?
      [[./19.png]]
      #+BEGIN_SRC java
          byte a=4;
          byte b=1;
          b=a+=a-=a+=a*=5;
          System.out.println(b);//-16
          System.out.println(a);//-16
      #+END_SRC
      等号后面的值如果改变不会影响前面得值
      #+BEGIN_SRC java
          byte a=4;
          byte b=1;
          b=a+=a-=a+=a*=++a;
          System.out.println(b);//-16
      #+END_SRC
*** 关系运算符
==、>、<、> =、< =、! =
比较（关系）运算符--结果一定是布尔值
*** 逻辑运算符
用于连接布尔值或者布尔表达式的符号
**** 表达式：
用于连接变量或者数据，而且符合java语法的式子
a+b(算术表达式)
a<b(布尔表达式)
&(逻辑与)  |逻辑或   ^逻辑异或  ！逻辑非  ||双或
**** 总结：
逻辑运算符，对两个BOOLEAN类型数据之间进行计算
结果也是BOOLEAN类型

&（按位与）       :只要有一个FALSE，结果就FALSE
(或)|           :只要有一个TRUE，结果就是TRUE
^（按位异或）     :两边相同为FALSE，不同为TRUE
!(非)           :取反 !TRUE = FALSE  !FALSE = TRUE
&&(短路与.逻辑与) :一边是FALSE，另一边不运行;左边是false，则右边默认不执行--短路
(短路或逻辑或)||  :一边true，另一边不运行;如果左边是true，则右边就默认不执行--短路

如果双或在双与的前面，双或发生短路，就会把双与一起短路掉
&&和||优先级一样
开发中常用双与和双或
#+BEGIN_SRC java
class Operator_5{
    public static void main(String[] args){
        System.out.println(false & true);
        System.out.println(false | true);
        System.out.println(false ^ false);//F
        System.out.println(true ^ true);//T
        System.out.println(true ^ false);//F

        System.out.println(!true);
        System.out.println("--------------------------------");
        int i = 3;
        int j = 4;
        System.out.println(3>4 && ++j>2);
        System.out.println(i);
        System.out.println(j);

        System.out.println(3==3 || ++j>2);
        System.out.println(i);
        System.out.println(j);

        //&&在||前面时，不能短路||
        int i1=3,j1=5;
        boolean b1 = false && i1++ > 1 || j1++>3;
        System.out.println(i1);
        System.out.println(j1);
        System.out.println(b1);

        //||在&&前面时，短路&&
        int i2=3,j2=5;
        boolean b2 = true || i2++ > 6 && j2++ > 10;
        System.out.println(i2);
        System.out.println(j2);
        System.out.println(b2);

    }
}
#+END_SRC
#+BEGIN_SRC java
class Luoji{
    public static void main(String[] args){
        int a=3;
        int b=4;
        int c=5;
        int a1=3;
        int b1=4;
        int c1=5;
        int a2=3;
        int b2=4;
        int c2=5;
        int a3=3;
        int b3=4;
        int c3=5;
        int a4=3;
        int b4=4;
        int c4=5;
        System.out.println((a++==b)&&(c++>b));
        //4,4,5
        System.out.println(a+","+b+","+c);

        System.out.println((c1++>b1)&&(a1++==b1));
        //4,4,6
        System.out.println(a1+","+b1+","+c1);

        System.out.prtinln(true&&(a2++!=b)||(c2++>b2));
        //4,4,5
        System.out.println(a2+","+b2+","+c2);

        System.out.prtinln(false&&(a3++!=b)||(c3++>b3));
        //3,4,6
        System.out.println(a3+","+b3+","+c3);

        //如果双或在双与的前面，双或发生了短路就会把双与一起短路掉
        // System.out.println(true||(a4++!=b4)&&(c4++>b4));
        //3,4,5
        // System.out.println(a4+","+b4+","+c4);
        System.out.println(true&&c4++>b4);
        System.out.println(c4);
    }
}
#+END_SRC
[[./Luoji.java]]
*** 位运算符
要把数据转成二进制的补码形式才能进行位运算
移位的位数要对32进行取余，取余的结果才是真正移动的位数--规定
**** &（按位与） |（按位或） ^（按位异或）
任意一个数&1==1就是奇数
任意一个正数&任意一个数=正数
任意一个负数|任意一个数=负数
任意一个数|0=原来的值

      4 & 5=4 遇0则0
        4 00000000 00000000 00000000 00000100
      & 5 00000000 00000000 00000000 00000101
      --------------
        4 00000000 00000000 00000000 00000100

      4 | 5=5 遇1则1
        4 00000000 00000000 00000000 00000100
      | 5 00000000 00000000 00000000 00000101
      --------------
        5 00000000 00000000 00000000 00000101

      4 ^ 5 =1 相同则0 不同则1
        4 00000000 00000000 00000000 00000100
      ^ 5 00000000 00000000 00000000 00000101
      --------------
        1 00000000 00000000 00000000 00000001
      ~ 4=
        4 00000000 00000000 00000000 00000100 补
          11111111 11111111 11111111 11111010 反
       -5 10000000 00000000 00000000 00000101 原
      [[./Wei.java]]
**** <<左移 >>右移 >>>无符号右移 ~取反
***** >>
如果是正数右移几位就在最左边补几个0
如果是负数右移几位就在最左边补几个1
如果是正数右移几位，操作数/2^移动位数
***** <<
无论正负数左移几位最右边就补几个0
左移几位，操作数*2^移动位数
***** >>>
一定是正数
无论正负数右移几位，就在最左边补几个0
***** 示例
      4 >> 2
      4 [00]00000000 00000000 00000000 000001(00)
      1     00000000 00000000 00000000 00000001

      4 << 2
      4  (00)00000000 00000000 00000000 00000100[00]
      16     00000000 00000000 00000000 00010000

      4 >>> 2
      4 [00]00000000 00000000 00000000 000001(00)
      1     00000000 00000000 00000000 00000001
      #+BEGIN_SRC java
      class WeiDemo4{
          public static void main(String[] args){
              // >>
              System.out.println(4>>2);//4/2^2
              // <<
              System.out.println(4<<2);//4*2^2
              //>>>
              System.out.println(4>>>2);
          }
      }
      #+END_SRC
      [[./WeiDemo4.java]]
**** 按位异或的扩展
如果一个数按位异或上另一个数两次，结果就是本身
[[./WeiDemo.java]]
**** 交换值的方式：
- 方式一：异或法
  int x = 5
  int y = 7

  x = x ^ y;
  y = x ^ y; ---> y = x ^ y ^ y; ---> y = x; ---> y = 5;
  x = x ^ y; ---> x = x ^ y ^ x; ---> x = y; ---> x = 7;
  #+BEGIN_SRC java
  class WeiDemo2{
      public static void main(String[] args){
          int a=4;
          int b=5;
          //按位异或
          a=a^b;
          b=a^b;
          a=a^b;
          System.out.println("a:"+a+",b:"+b);

      }
  }
  #+END_SRC
  [[./WeiDemo2.java]]
- 方式二：加减法
  int x = 3;
  int y = 7;

  x = x + y;
  y = x - y; ---> y = x + y - y; ---> y = x; ---> y = 3;
  x = x - y; ---> x = x + y - x; ---> x = y; ---> x = 7;
  #+BEGIN_SRC java
  class WeiDemo3{
      public static void main(String[] args){
          int a=4;
          int b=5;
          a=a+b;
          b=a-b;
          a=a-b;
          System.out.println("a:"+a+",b:"+b);
      }
  }

  #+END_SRC
  [[./WeiDemo3.java]]
- 方式三：第三方变量
  int x = 3;
  int y = 7;
  int z = x;
  x = y;
  y = z;
  #+BEGIN_SRC java
  class WeiDemo1{
      public static void main(String[] args){
          int a=4;
          int b=5;
          //中间变量
          int temp=a;
          a=b;
          b=temp;
          System.out.println("a:"+a+",b:"+b);
      }
  }
  #+END_SRC
  [[./WeiDemo1.java]]
- 扩展：考虑三种方式的优劣性
  异或法的效率最高，但使用频率最低            ---只能适用于整数值的交换
  加减法的效率低于异或法，但是高于第三方变量法  ---理论上适用于数值型（小数运算不准确）
  第三方变量法的效率最低，但是使用频率是最高的  ---适用于所有的类型
*** 运算符的优先级
() ~ ++ -- ! * / % + - << >> >>> 关系 逻辑 & | ^ 三元 赋值
#+BEGIN_SRC java
class OperatorDemo121{
    public static void main(String[] args){
        /*
          如果算术比关系的优先级高，就先算2+5 =7，然后比较3>7，所以结果是false
          如果关系比算术高，就先算3>2 = true,然后计算true + 5，因为类型不能转换，所以会报错
          System.out.println(3>2+5);
        ,*/

        /*
          如果先算的是关系，那么就先计算2>3=false,然后计算true&&false = false
          如果先计算逻辑，那么先算true&&2不能计算，会报错
          System.out.println(true&&2>3);
        ,*/

        /*
          如果位比算术优先级高，先算5&1=1，然后计算3+1=4
          如果算术比位的高，先算3+5=8，然后计算8+1=0
          System.out.println(3 + 5 & 1);
        ,*/

        /*
          位>关系   ----true
          位<关系   ----报错
          System.out.println(3 > 5 & 1);
        ,*/

        /*
          算术>位 ---20
          位>算术 ---11
          System.out.println(3 + 2 << 2);
        ,*/

        /*
          位>关系 ---false
          关系>位 ---报错
          System.out.println(3 > 2 << 2);
        ,*/

        /*
          ~>算术 ---2
          算术>~ --- -8
          System.out.println(~2 + 5);
        ,*/
    }
}
#+END_SRC
*** 三元运算符
**** 格式和执行流程
格式：
表达式（布尔值） ? 表达式值1:表达式值2;
执行流程：
先去计算表达式的值，如果这个值是true，就把表达式值1返回，
如果这个值是false，就把表达式值2进行返回
**** 示例
***** 求两个整数的最大值
#+BEGIN_SRC java
class Operator_6{
    public static void main(String[] args){
        //求两个整数的最大值
        int a=5;
        int b=9;
        //有另一个变量来接收值得时候，要保证这个变量的类型和两个表达式值的类型一致
        System.out.println(max);
        //连个表达式值的类型可以不一样但是有个前提，没有另一个变量来接收返回值
        System.out.println(a>b?'a':true);
    }
}
#+END_SRC
***** 求三个整数的最大值
#+BEGIN_SRC java
class Operator122{
    public static void main(String[] args){
        int i = 3,j = 8,k = 5;
        //三元表达式的嵌套
        int max = i > j ? (i > k ? i : k) : (j > k ? j : k);
        System.out.println(max);

        /*int max = i > j ? i : j;
        max = max > k ? max : k;
        System.out.println(max);
        ,*/
    }
}
      #+END_SRC
***** 判断一个数是奇数还是偶数
#+BEGIN_SRC java
class Operator133{
    public static void main(String[] args){
        //定义一个整数变量，判断这个整数是一个寄数还是一个偶数
        int num = 15;
        String str = (num % 2) == 1 ? "奇数" : "偶数";
        //String str = (num & 1) == 1 ? "奇数" : "偶数";
        System.out.println(str);
    }
}
#+END_SRC
***** 分数评级
#+BEGIN_SRC java
class Operator134{
    public static void main(String[] args){
        /*
          定义一个变量表示分数:
          分数 >= 90 ----- A
          分数 >= 80 ----- B
          分数 >= 70 ----- C
          分数 >= 60 ----- D
          分数 <  60 ----- E
        ,*/
        double score = 79.5;
        char level = score >= 90 ? 'A' :
        (score >= 80 ? 'B' :
        (score >= 70 ? 'C' :
        (score >= 60 ? 'D' : 'E')));
        System.out.println(level);
    }
}
#+END_SRC
***** 平年还是闰年
#+BEGIN_SRC java
class Operator135{
    public static void main(String[] args){
        /*
          定义一个变量表示年份，判断这一年是平年还是闰年：
          逢百年整除400,不是百年整除4
          2000 --- 闰年
          2100 --- 平年
          2012 --- 闰年
        ,*/
        int year = 2900;
        String str = year % 100 == 0 ?
        (year % 400 == 0 ? "闰年" : "平年") :
        (year % 4 == 0 ? "闰年" : "平年");
        System.out.println(str);
    }
}
#+END_SRC
** 引用数据类型
*** Scanner类
步骤：
    1.导包
    2.找到Scanner
    3.获取数据
#+BEGIN_SRC java
import java.util.Scanner;
class JavaDemo{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int num =sc.netxInt();
        //System.out.println(num);
        String s=sc.next();
        System.out.println(s);
    }
}
#+END_SRC
[[./JavaDemo.java]]
**** 引用数据类型的使用
数据类型 变量名 = new 数据类型（）;
调用该类型实例的功能：
变量名.方法名();
**** Scanner类
完成用户键盘录入，获取到录入的数据
***** Scanner使用步骤
导包：import java.util.Scanner;
创建对象实例：Scanner sc = new Scanner(System.in);
调用方法：
        int i = sc.nextInt();用来接收控制台录入的数字
        String s = sc.next();用来接收控制台录入的字符串
#+BEGIN_SRC java
/*
  引用数据类型，介绍一个类Scanner
  java中已经存在，是sun公司为用户做好的类
  用他定义引用数据类型变量，和基本类型变量区别
  int a=1;
  格式：
      类型 变量名 = new 类型（）；
      举例：创建出Scanner类的变量
      Scanner sc = new Scanner（）;
      int a = 1;
      每个引用类型，都有自己的功能，如何使用功能
      公式：
          变量.功能名字();
          Scanner类，作用，让我在命令行中，接受键盘的输入
,*/
import java.util.Scanner;
public class ScannerDemo{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        System.out.println(num);

        String s = sc.next();
        System.out.println(s+1);
    }
}
#+END_SRC
*** 随机数类Random
用于产生随机数的类
#+BEGIN_SRC java
/*
  java中已经有的引用类型  Random类,作用，产生随机数
  步骤：
      1. 导入包，Random，也在java.util文件夹
      2. 公式：创建出Random类型的变量
         数据类型  变量名 = new 数据类型();
      3. 变量. 调用Random类中的功能，产生随机数
         Ramdom类，提供功能，名字 nextInt()产生一个随机数，结果是int类型
         出现随机数的范围，在功能nextInt(写一个整数)，整数：随机出来的范围
         随机数的范围在0~指定的整数之间的随机数 nextInt(100) ---> 0~99

         产生浮点数的随机数：功能名字 nextDouble() 随机数的范围 0.0~1.0

         随机数：伪随机数，虚拟机根据人写好的一个算法，生成出来的
,*/
import java.util.Random;
public class RandomDemo{
    public static void main(String[] args){
        Random ran = new Random();
        int i =ran.nextInt(50);
        System.out.println(i);

        //问题？产生随机数，范围1~100之间
        //nextInt（100）---> 0~99+1

        double d = ran.nextDouble();
        System.out.println(d);
    }
}
#+END_SRC
** 流程控制语句
- 顺序结构
  java中绝大部分的代码都是从上往下，由左往右依次执行执行
- 选择结构
  if语句
  switch语句
- 循环结构
  for
  while
  do...while
*** 选择结构
**** if
***** if语句：
编写格式：if（判断条件）{语句体;}
执行流程：先去计算判断条件的值，如果是true就去执行语句体，
如果是false就跳过不执行，执行其他语句
[[./20.png]]
#+BEGIN_SRC java
import java.util.Scanner;
class IfDemo{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int money=sc.nextInt();
        if(money > 999){
            System.out.println("OKOKOK~~~");
        }
        System.out.println("Over");
    }
}
#+END_SRC
****** 输入三个整数，打印这三个整数中的最大值
#+BEGIN_SRC java
import java.util.Scanner;
public class IfElseExer{
    public static void main(String[] args){
        //输入三个整数，打印这三个整数中的最大值

        Scanner s = new Scanner(System.in);
        int i = s.nextInt();
        int j = s.nextInt();
        int k = s.nextInt();

        /*
          if(i > j){
              if(i > k){
                  System.out.println(i);
              }else{
                  System.out.println(k);
              }
          }else{
              if(j > k){
                  System.out.println(j);
              }else{
                  System.out.println(k);
              }
          }
        */

        //定义变量记录最大值
        int max = i;
        if(max < j){
            max = j;
        }
        if(max < k){
            max = k;
        }
        System.out.println(max);
    }
}
#+END_SRC
***** if...else语句
编写格式：if(判断条件){语句体1;}else{语句体2;}
执行流程：先去计算判断条件，如果是true就执行语句体1，如果false就执行语句体2
如果if语句格式2返回的是一个值就和三目等效
[[./21.png]]
****** 举例
1. 求两个整数的最大值
   #+BEGIN_SRC java
   int a=10;
   int b=1;
   if(a>b){
       System.out.println(a);
   }else{
       System.out.println(b);
   }
   #+END_SRC
   [[./IfDeo2.java]]
2. 求三个整数的最大值
   #+BEGIN_SRC java
   int a=10;
   int b=1;
   int c=8;
   if(a>b){
       if(a>c){
           System.out.println(a);
       }else{
           System.out.println(c);
       }
   }else{
       if(b>c){
           System.out.println(b);
       }else{
           System.out.println(c);
       }
   }
   #+END_SRC
   [[./IfDemo3.java]]
***** if...else if...else语句
适合在程序中，实现多条件的判断
编写格式：
       if(判断条件1){
           语句体1;
       }else if(判断条件2){
           语句体2;
       }else if(判断条件3){
           语句体3;
       }
            ...
       else{
           语句体n+1;
       }
执行流程：
       先计算判断条件1，如果是true，就执行语句体1，
       如果是false就去计算判断条件2，如果是true就执行语句体2
       如果是false就去计算判断条件3，如果是true就执行语句体3，
       如果全部false就执行语句体n+1
[[./22.png]]
#+BEGIN_SRC java
//根据输入的星星数展示用户的段位
Scanner sc=new Scanner(System.in);
int xing=sc.nextInt();
if(xing>=0&&xing<10){
    System.out.println("C");
}else if(xing>=10&&xing<20){
    System.out.println("B");
}else if(xing>=20&&xing<30){
    System.out.println("A");
}else if(xing>=30&&xing<90){
    System.out.println("S");
}else if(xing>=90&&xing<100){
    System.out.println("S+");
}else{
    System.out.println("XXXX");
}
#+END_SRC
***** 选择结构if语句与三元运算转换
要求：已经知道两个数，计算最大值
     两个整数，比较大小

     使用if还是三元
     判断条件多，使用if语句
     三元，必须有结果，if可以没有结果
#+BEGIN_SRC java
public class IfElseDemo{
    public static void main(String[] args){
        int i = 15;
        int j = 6;
        //使用if语句，判断出最大值
        if(i>j){
            System.out.println(i+"是最大值");
        }else{
            System.out.println(j+"是最大值")
        }

        //使用三元运算实现
        int k=i>j?i:j;
        System.out.println(k+"是最大值");
    }
}
#+END_SRC
**** switch
***** 选择结构switch
格式：
    switch(表达式){
        case 值1:
        语句体1;
        case 值2:
        语句体1;
        case 值3:
        语句体 3;
          ...
        default:
        语句体n+1;
        break;
    }
执行流程：计算表达式的值，拿到这个值和每个case后面的值依次进行比较，
         如果有case的值满足比较条件，就执行对应的语句体。如果都不满足就默认执行语句体n+1，语句结束。
[[~/Documents/BigData/Java/23.png]]
switch语句中的表达式的数据类型，是有要求的
jdk1.0 ~ 1.4 数据类型接受 byte short int char
jdk1.5       数据类型接受byte short int char enum（枚举）
jdk1.7       数据类型接受byte short int char enum（枚举），string
#+BEGIN_SRC java
import java.util.Scanner;
    class SwitchDemo{
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int week = sc.nextInt();
            //switch语句
            switch(week){
                case 1:
                    System.out.println("星期一");
                    break;
                case 2:
                    System.out.println("星期二");
                    break;
                case 3:
                    System.out.println("星期三");
                    break;
                case 4:
                    System.out.println("星期四");
                    break;
                case 5:
                    System.out.println("星期五");
                    break;
                case 6:
                    System.out.println("星期六");
                    break;
                case 7:
                    System.out.println("星期日");
                    break;
                default:
                    System.out.println("星期不存在");
                    break;
            }
        }
    }
#+END_SRC
#+BEGIN_SRC java
import java.util.Scanner;
public class SwitchDemo1{
    public static void main(String[] args){
        //输入一个符号(+ - * /)，然后输入两个数字，根据给定的符号来计算两个数字的结果
        Scanner sc = new Scanner(System.in);
        String sym = sc.nextLine();
        double a = sc.nextDouble();
        double b = sc.nextDouble();
        switch(sym){
            case "+":
                System.out.println("a + b =",a + b);
                break;
            case "-":
                System.out.println("a - b =",a - b);
                break;
            case "*":
                System.out.println("a * b =",a * b);
                break;
            case "/":
                System.out.println("a / b =",a / b);
                break;
            default :
                System.out.println("Illegal symbol");
            }
        }
    }
#+END_SRC
***** case穿透
#+BEGIN_SRC java
/*
  switch特性：case穿透性
  案例：星期1 ~ 5输出，工作日，星期6 ~ 7  输出休息日
  case 1 case2...case5 输出结果相同

  case后面的常量和switch中数据相同，没有break，一直向下穿透
  case后面没有break，程序就会一直向下穿透
,*/
public class SwitchDemo_1{
    public static void main(String[] args){
        int week=1;
        switch(week){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("工作日");
                break;
            case 6:
            case 7:
                System.out.println("休息日");
                break;
            }
        }
    }
#+END_SRC
#+BEGIN_SRC java
import java.util.Scanner;
public class SwitchDemo2{
    public static void main(String[] args){
        /*输入三个数字分别表示年月日，计算这一天是这一年的第几天*/

        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        int month = sc.nextInt();
        int day = sc.nextInt();

        //定义变量记录总的天数
        int sum = 0;

        switch(month){
            //经历了一个完整的11月
            case 12:
                sum += 30;
                //经历了一个完整的10月
            case 11:
                sum += 31;
            case 10:
                sum += 30;
            case 9:
                sum += 31;
            case 8:
                sum += 31;
            case 7:
                sum += 30;
            case 6:
                sum += 31;
            case 5:
                sum += 30;
            case 4:
                sum += 31;
            case 3:
                if(year % 400 == 0 || year % 100 != 0 && year % 4 == 0){
                    sum += 29;
                }else{
                    sum += 28;
                }
            case 2:
                sum += 31;
            case 1:
                sum += 0;
            }
            sum += day;
            System.out.println(sum);
        }
    }
#+END_SRC
*** 循环结构
**** for
***** for循环
格式：
    for(初始值;判断值;控制条件){
        循环体;
    }

执行流程:
       1.先计算初始值
       2.初始值与判断条件进行判断
       3.如果是true，就执行循环体，执行完循环体之后执行控制条件
       4.执行完的值与判断条件进行判断
         如果是true就执行3，4操作；知道false出现就结束循环
[[./24.png]]
#+BEGIN_SRC java
class ForDemo{
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            System.out.println("helloworld");
        }
    }
}
#+END_SRC
****** 举例
1. 输出0~10
   #+BEGIN_SRC java
   class ForDemo1{
       public static void main(String[] args){
           //print 0~10
           for(int i = 0;i<11;i++){
               System.out.println(i);
           }
       }
   }
   #+END_SRC
   [[./ForDemo1.java]]
2. 输出1+4的结果
   #+BEGIN_SRC java
   /*
     利用for循环，计算1+4的结果
     1+2+3+4=10

     1+2的和+3
     1+2+3的和+4
   ,*/
   class ForDemo_1{
       public static void main(String[] args){
           //定义变量，记录求和后的数据
           int sum = 0;
           //利用循环，将变量从1变化到4
           for(int i=1;i<=4;i++){
               //对变量进行求和
               sum = sum + i;
           }
               System.out.println(sum);
           }
       }
   #+END_SRC
   [[./ForDemo.java]]
3. 计算1~n中的所有奇数和
   #+BEGIN_SRC java
   import java.util.Scanner;
   class ForDemoa{
       public static void main(String[] args){
           Scanner sc=new Scanner(System.in);
           int n=sc.nextInt();
           /*
             for(int i=1;i<=n;i+=2){
                 sum=sum+i;
             }
             System.out.println(sum);
           */
           for(int i=1;i<=n;i++){
               if((i&1)!=0){
                   sum+=i;
               }
           }
           System.out.println(sum);
       }
   }
   #+END_SRC
   [[./ForDemo3.java]]
4. 计算1~n中的所有偶数和
   #+BEGIN_SRC java
   import java.util.Scanner;
   class ForDemo4{
       public static void main(String[] args){
           Scanner sc=new Scanner(System.in);
           int sum=0;
           int n=sc.nextInt();
           /*
             for(int i=0;i<=n;i+=2){
                 sum+=i;
             }
             System.out.println(sum);
           */
           for(int i=1;i<=n;i++){
               if((i&1)==0){
                   sum+=i;
               }
           }
           System.out.println(sum);
       }
   }
   #+END_SRC
   [[./ForDemo4.java]]
5. 求5的阶乘
   #+BEGIN_SRC java
   class ForDemo5{
       public static void main(String[] args){
           int sum=1;
           for(int i=1;i<=5;i++){
               sum=sum*i;
           }
           System.out.println(sum);
       }
   }
   #+END_SRC
   [[./ForDemo5.java]]
6. 在控制台输出所有水仙花数
   三位数 abc=a^3+b^3+c^3
   123 %10=3
   123 /10%10=2
   123 /100=1
   #+BEGIN_SRC java
   class ForDemo6{
       public static void main(String[] args){
           for(int i=100;i<1000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100;
               if(i==ge*ge*ge+shi*shi*shi+bai*bai*bai){
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC
   [[./ForDemo6.java]]
7. 统计水仙花数有多少个
   #+BEGIN_SRC java
   class ForDemo7{
       public static void main(String[] args){
           int count=0;
           for(int i=100;i<1000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100;
               if(i==ge*ge*ge+shi*shi*shi+bai*bai*bai){
                   count++;
               }
           }
           System.out.println(count);
       }
   }
   #+END_SRC
   [[./ForDemo7.java]]
8. 请在控制台输出满足如下条件的五位数
   个位数等于万位
   十位数等于千位
   个位数+十位数+千位数+万位数=百位数
   #+BEGIN_SRC java
   class ForDemo8{
       public static void main(String[] args){
           for(int i=10000;i<100000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100%10;
               int qian=i/1000%10;
               int wan=i/10000;
               if((ge==wan)&&(shi==qian)&&(ge+shi+qian+wan==bai)){
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC
   [[./ForDemo8.java]]
9. 请统计1~1000之间同时满足如下条件的数据有多少个
   对3整除余2
   对5整数余3
   对7整除余2
   #+BEGIN_SRC java
   class ForDemo9{
       public static void main(String[] args){
           int count=0;
           for(int i=1;i<1000;i++){
               if((i%3==2)&&(i%5==3)&&(i%7==2)){
                   count++;
               }
           }
           System.out.println(count);
       }
   }
   #+END_SRC
   [[./ForDemo9.java]]
***** 增强for循环
底层的实质是迭代
- 格式：
      for(数据类型变量名 : 被遍历的集合或者数组){执行语句}
- 区别：
      必须有被遍历的目标（如集合或数组）
      不能获取下标
      把所有的数组元素拷贝一份拿过来新型输出
**** while
***** 循环语句while
循环次数不确定的时候，首选while
- 循环语句：可以让一部分代码，反复执行
- 编写格式：
          while(判断条件){
              循环体;
              控制条件;
          }
- 条件：
      当条件是true，就执行循环体，当执行完循环体后，程序再次执行while中的条件，
      如果条件是true，继续执行循环体，直到条件是false的时候，循环就结束
      需要定义变量来控制循环的次数
#+BEGIN_SRC java
class WhileDemo{
    public static void main(String[] args){
        int i=1;
        while(i<=10){
            System.out.println(i);
            i++;
        }
    }
}
#+END_SRC
[[./WhileDemo.java]]
****** 举例
1. 输入五个数字，获取最大值
   #+BEGIN_SRC java
   import java.util.Scanner;
   public class WhileDemo{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int max = sc.nextInt();
           int count = 1;
           while(count < 5){
               int num = s.nextInt();
               if(max < num){
                   max = num;
               }
               count ++;
           }
           System.out.println(max);
       }
   }
   #+END_SRC
2. /输入一个整数n,求1~n中的所有的奇数的和/
   #+BEGIN_SRC java
   import java.util.Scanner;
   class LooTest{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 1;
           int sum = 0;
           while(count <= n){
               sum += count;
               count += 2;
           }
           System.out.println(sum);
       }
   }
   #+END_SRC
3. 输入一个整数n，打印1~n中所有能被3整除而不被5整除的数字
   #+BEGIN_SRC java
   import java.util.Scanner;
   class WhileDemo3{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 3;
           while(count <= n){
               if(count % 5 != 0){
                   System.out.println(count);
               }
               count += 3;
           }
       }
   }
   #+END_SRC
4. 输入一个整数n，输出这个n是一个几位数
   #+BEGIN_SRC java
   import java.util.Scanner;
   class SwitchDemo4{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           //定义一个变量来记录位数
           int count = 0;
           while(n != 0){
               count ++;
               //减少一位
               n /= 10;
           }
           System.out.println(count);
       }
   }
   #+END_SRC
5. 输入一个整数n，打印这个整数n的所有的因数
   （这个数能够整除n，这个数就是n的因数）
   思路：
       先获取1~n中的所有的数
       再判断这个是数能否整除n
   #+BEGIN_SRC java
   import java.util.Scanner;
   class WhileDemo4{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 1;
           while(n >= count){
               if(n % count == 0){
                   System.out.println(n);
               }
               count ++;
           }
       }
   }
   #+END_SRC
***** do...while循环
- 格式：
      do{循环体;}while(判断条件);
- 一般格式：
      初始值;
      do{循环体;控制条件;}while(判断条件);

  1.先计算初始值
  2.直接执行循环体以及控制条件
  3.执行完控制条件后的值和判断条件进行判断，
    true的话重复操作2、3，知道false就结束循环
#+BEGIN_SRC java
public class DoWhileDemo{
    public static void main(String[] args){
        int i = 1;
        do{
            System.out.println(i);
            i++;
        }while(i<=10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    );
    }
}
#+END_SRC
****** 举例
实现一个猜数字的小游戏
#+BEGIN_SRC java
/*
  实现猜数字的小游戏
  随机数一个数字，让用户猜
  结果三种情况：
  中了，大了，小了
  随机数：Random
  键盘输入：Scanner
  猜的数字，和随机数进行比较：if判断
  直到猜中为止，反复去猜，循环while
,*/
import java.util.Random;
import java.util.Scanner;
public class GuestNum{
    public static void main(String[] args){
        System.out.println("游戏开始");
        System.out.println("输入1~100的数字");
        Random ran = new Random();
        int ranNum = ran.nextInt(100)+1;

        Scanner sc = new Scanner(System.in);

        while(true){
            int num = sc.nextInt();
            if(num > ranNum){
                System.out.println("猜大了");
            }else if(num<ranNum){
                System.out.println("猜小了");
            }else
                System.out.println("中了");
                break;
            }
        }
    }
#+END_SRC

**** 嵌套循环
#+BEGIN_SRC java
/*
  循环的嵌套：循环里面还有循环，for形式多
  for(){
      for(){
      }
  }
  总的循环次数 = 内循环次数 * 外循环的次数
  内循环，是外循环的循环体

  外循环，控制的是行数
  内循环，控制的是没行的个数
,*/
public class ForForDemo{
    public static void main(String[] args){
        for(int i = 0;i<9;i++){
            for(int j = 0;j<i+1;j++){
                System.out.print("*");
            }
        }
        System.out.println();
    }
}
#+END_SRC
***** 举例
要求:计算出水仙花数
     三位数 100~999 个位数的立方 + 十位数的立方 + 百位数的立方 = 自己本身
     153 = 1*1*1 + 5*5*5 + 3*3*3
     已知三位数  123 获取出每个数位 利用除法，取模运算
实现步骤：
       1.定义变量，存储三个数位上的整数
       2.利用循环，循环中的变量，从100变化到999
       3.循环中得到三位数，利用算术，拆解陈三个单独数位
       4.将三个数位立方的求和计算，计算后的求和和他自己进行比较判断
         若相同位水仙花
#+BEGIN_SRC java
public class LoopTest_1{
    public static void main(String[] args){
        //定义三个变量
        int bai = 0;
        int shi = 0;
        int ge = 0;

        for(int i = 100;i<=999;i++){
            bai = i/100;
            shi = i/10%10;
            ge = i%10;

            if(bai*bai*bai+shi*shi*shi+ge*ge*ge == i){
                System.out.println(i+"为水仙花");
            }
        }
    }
}
#+END_SRC
**** 三种循环的区别于联系
- 联系：
      1.三种循环可以等效转换
      2.优先选择for循环，其次是while最后才是do...while
      3.都会出现死循环
- 区别：
      1.do...while最少会执行一次
      2.for循环的初始值循环结束之后拿不到这个值
*** 嵌套循环(嵌套循环/双层循环)
外层循环控制行数
内层循环控制的是列数
**** 举例
1. 打印星星
   #+BEGIN_SRC java
   class  Java1{
       public static void main(String[] args){
           for(int i=1;i<=5;i++){
               for(int j=0;i<=5;j++){
                   System.out.print("*");
               }
               System.out.println();
           }
       }
   }
   #+END_SRC
2. 打印99乘法表
   1*1=1
   1*2=2 2*2=4
   1*3=3 2*3=6 3*3=9

   1
   11
   111
   1111
   11111

   #+BEGIN_SRC java
       class Java2{
           public static void main(String[] args){
               for(int i=1;i<=9;i++){
                   for(int j=0;j<9;j++){
                       System.out.print("1");
                   }
                   System.out.println();
               }
           }
       }
   #+END_SRC
   #+BEGIN_SRC java
   class Java3{
       public static void main(String[] args){
           for(int i=1;i<=9;i++){
               for(int j=1;j<=i;j++){
                   // int m=i*j;
                   // System.out.print(j+"*"+i+"="+m);
                   System.out.print(j+"*"+i+"="+(i*j)+'\t');
               }
               System.out.println();
           }
       }
   }
   #+END_SRC
*** 跳转语句break、continue
**** break
1. 用于switch语句
2. 用在循环中，结束当前循环
   #+BEGIN_SRC java
   class BreakDemo{
       public static void main(String[] args){
           int i=i;
           while(true){
               if(i == 3){
                   break;
               }else{
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC
3. break tag
   在多层循环时，通过break tag方式，指定在break时要跳出的是哪一层循环
   #+BEGIN_SRC java
   class BreakDemo_1{
       public static void main(String[] args){
           a:for(int i = 0;i<2;i++){
               for(int j = 0;j<5;j++){
                   System.out.println("j="+j);
                   break a;
               }
                   System.out.println("i="+i);
               }
           }
       }
   #+END_SRC
**** continue
跳过本次循环
#+BEGIN_SRC java
class ContinueDemo{
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            if(i%2==0){
                continue;
            }
            System.out.println(i);
        }
    }
}
#+END_SRC

*** 练习
1. 对于下列代码输出的结果是什么——hehe
   当if语句省略大括号的时候，语句体只有一句
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i=3;
           if(i<3)
               System.out.println("haha");
               System.out.println("hehe");
       }
   }
   #+END_SRC
2. 对于下列代码输出的结果是什么——死循环，没有输出
   while(判断条件);{循环体；控制条件；}
   当while()后面出现分号表示执行完判断条件后直接结束，不仅如此{}执行循环体和控制条件
   所以i一直等于0---死循环
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i=0;
           while(i<10);
           {
               System.out.println(i);
               i++;
           }
       }
   }
   #+END_SRC
3. 对于下列代码输出的结果是什么——编译时报错
   要保证每块区域的变量事先都有定义
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i= 5;
           switch(i){
               default:
               int y=5;
               case 4:
                   y+=4;
               case 3:
                   y+=3;
                   break;
               case 2:
                   y+=2;
               case 1:
                   y+=1;
           }
           System.out.println(y);
       }
   }
   #+END_SRC
4. 对于下列代码输出的结果是什么——1,1 2,1
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           Outer:for(int i=1;i<3;i++){
               Inner:for(int j=1;j<3;j++){
                   if(j==2)
                       continue Outer;
                   System.out.println(i+","+j);
               }
           }
       }
   }
   #+END_SRC
5. 百钱买百鸡是我国古代的著名数学题。题目这样描述：3文钱可以买1只公鸡，2文钱可以买1只母鸡，1文钱可以买3只小鸡，用100文钱可以买100只鸡，那么公鸡、母鸡、小鸡各多少只？
   #+BEGIN_SRC java
   //公鸡
   int x=0;
   //母鸡
   int y=0;
   //小鸡
   int z=0;
   //把每组的排列组合都列出来
   //公鸡范围
   for(x=0;x<=33;x++){
       //母鸡的范围
       for(y=0;y<=50;y++){
           //小鸡的范围
           z=100-x-y;
           //小鸡也是整数
           if(z%3==0){
               //判断条件
               if(3*x+2*y+(z/3)==100){
                   System.out.println(x+" "+y+" "+z);
               }
           }
       }
   }
   #+END_SRC
6. 读入一个整数n,输出如下图形：
   当输入n=3时，输出：
         *              空格 2     1   n=3      星星1      1   2*行-1
        *****                  1     2               3      2
       *******                 0     3               5      3
   当输入n=4时，输出：
         *
        *****
       *******
      *********
   #+BEGIN_SRC java
   int n=5;
   for(int x=1;x<=n,i++){
       //空格
       for(int y=0;y<n-x;y++){
           System.out.print(" ");
       }
       //星星
       for(int z=1;z<=2*x-1;z++){
           System.out.print("*");
       }
       System.out.println();
   }
   #+END_SRC
** Java的内存存储
java将占用的内存分为了5块：栈内存、堆内存、方法区(面向对象讲)、本地方法栈、PC计数器（计数器）
*** 栈内存：存储的变量(目前阶段)。
变量在声明的时候存储到栈内存中，不会自动给值，除非在程序中手动给值。
变量在栈内存中使用完成之后要立即释放。
int[] arr=new int[2];
arr通过堆内存中对象的地址找到值
*** 堆内存：存储的是对象。
对象在存储到堆内存中之后，会被堆内存赋予一个默认值；
byte/short/int - 0
long - 0L
float - 0.0f
double - 0.0
char - \u0000
boolean - false
引用数据类型 - null
对象使用完成不一定会从堆内存中立即移出，而是在不确定的某个时刻被回收
int[] arr=new int[2];  new就是在堆内存中开辟一个新空间
*** int[] arr1=new int[]{2,3,5};
系统默认初始值优先于程序初始值
** 数组
存储多个相同数据类型元素的容器
*** 数组格式：
- 数据类型[] 数组名 = new 数据类型[元素的个数或者数组的长度];
  int[]  arr = new int[3];
  表示整型数组arr的元素个数为3个
  支持声明和赋值两个过程
  #+BEGIN_SRC java
  int[] arr=new int[2];
  int[] arr1;
  arr1=new int[3];
  #+END_SRC
- 数组类型[] 数组名 = new 数据类型[]{元素值1,元素值2,元素值3,...,元素值n};
  int[]  arr  = new int[]{1,2,3,4,3};
  具体的值确定了，长度也就确定了
  支持声明和赋值两个过程
  #+BEGIN_SRC java
  int[] arr=new int[]{1,2,1,3};
  int[] arr1;
  arr1 = new int[]{1,2,1,3};
  #+END_SRC
- 数据类型[] 数组名 = {元素值1,元素值2,元素值3,...,元素值n};
  int[]  arr  ={1,2,3};
  给定具体的值，长度就确定了

  int arr1;
  arr1={1,2,3};//错误的写法

  new:创建对象，开辟新的内存空间
      没有开辟空间就无法存储数据
*** 数组的内存地址
#+BEGIN_SRC java
int[] arr=new int[2];
int[] arr1;
arr1=new int[3];
System.out.println(arr);//[I@7852e922
#+END_SRC
[I@7852e922:数组的内存地址
            [ 表示这块区域的对象类型为数组类型
            I 表示这块区域的对象元素的数据类型为整型
            @ 代表后面的是内存的地址值
            7842e922 表示对象的哈希吗值的十六进制的表现形式

*** 数组常用操作
**** 获取数组中的元素
数组名[数组的索引];
arr[2];
数组的索引(下标)就是元素在数组中的位置，索引由0开始，最大的索引是"数组的长度-1"
#+BEGIN_SRC java
int[] nums={1,3,4,1,5};
System.out.println(nums[0]);
System.out.println(nums[1]);
System.out.println(nums[2]);
#+END_SRC
**** 数组的元素赋值
#+BEGIN_SRC java
int[] arr = new int[5];
arr[1]=3;
#+END_SRC
***** 数组越界异常
ArrayIndexOutOfBoundsException
**** 修改数组中的元素
#+BEGIN_SRC java
int[] arr={1,2,3,4};
arr[2] =100;
#+END_SRC
**** 获取数组长度
#+BEGIN_SRC java
int[] arr = {2,8,9,12};
int len = arr.length;
#+END_SRC
**** 数组的遍历
一次输出数组元素的值
1. 遍历数组下标,先获取下标，然后利用下标获取元素
   #+BEGIN_SRC java
   int[] arr  = {2,1,3,5,7,0,4};
   for(int i = 0;i<arr.length;i++){
       System.out.println(arr[i]);
   }
   #+END_SRC
2. 直接获取数组中的元素(只能遍历数组，不能改变数组中的元素)
   把所有的数组元素拷贝一份拿过来进行输出
   #+BEGIN_SRC java
   int[] arr = {2,2,3,4,5};
   for(int i : arr){
       System.out.println(i);
   }
   #+END_SRC
4. 将数组中的元素转成字符串返回
   #+BEGIN_SRC java
   import java.util.Arrays;
   class ArrayDemo_8{
       public static void main(String[] args){
           int[] arr=new int[]{1,23,4};
           String str = Arrays.toString(arr);
           System.out.println(str);
       }
   }
   #+END_SRC
**** 获取数组中最值（最大值/最小值）
1. 定义一个变量记录最大值
   如果第0位小于第1位，那么将第1位的值赋值给max，以此类推
   #+BEGIN_SRC java
   int[] arr = {2,8,9,2,2,5,6};
   int max = arr[0];
   for(int i = 1; i<arr.length;i++){
       if(max <arr[i])
           max = arr[i];
   }
   System.out.println(max);
   #+END_SRC
2. 定义一个变量记录最大值的下标
   #+BEGIN_SRC java
   int[] arr = {2,3,6,5,3,2,,7};
   int max = 0;
   for(int i = 1;i<arr.length;i++){
       if(arr[max] <arr[i])
           max = i;
   }
   System.out.println(arr[max]);
   #+END_SRC
**** 数组逆序
1. 创建新数组，从原数组正着拿，往新数组倒着放，在将新数组的地址给arr
   [1,2,3] [3,2,1]
   i=0   arr.length-1-0
   i=1   arr.length-1-1
   i=2   arr.length-1-2
   #+BEGIN_SRC java
   import java.util.Arrays;
   class ArrayReserver{
       public static void main(String[] args){
           int[] arr={1,2,7,4,5};
           int[] arr1=new int[arr.length];
           for(int i=0;i<arr.length;i++){
               arr1[arr.length-1-i]=arr[i];
           }
           arr=arr1;
           System.out.println(Arrays.toString(arr));
       }
   }
   #+END_SRC
2. 数值的位置变换
   [1,2,5,7,8]
   0 arr.length-1
   1 arr.length-1-1
   2 arr.length-1-2
   变换次数：arr.length/2
   #+BEGIN_SRC java
   import java.util.Arrays;
   public class ArraysApplicationDemo1{
       public static void main(String[] args){
           int[] arr = {2,6,1,8,4,3,0};
           for(int i=0;i<arr.length/2;i++){
               int temp = arr[i];
               arr[i]=arr[arr.length-i-1];
               arr[arr.length-i-1]=temp;
           }
           System.out.println(Arrays.toString(arr));
       }
   }
   #+END_SRC
**** 数组的查找
根据查找数，返回这个查找数在数组出现的下标
***** 查找元素出现的位置(无序数组)
#+BEGIN_SRC java
int[] arr={1,2,5,8,3};
int find=3;
for(int i=0;i<arr.length;i++){
    if(find == arr[i]){
        System.out.println(i);
    }
}
#+END_SRC
#+BEGIN_SRC java
int[] arr={1,5,2,8,3,4};
int num=8;
int count=0;
for(int i:arr){
    if(i==num){
        System.out.println(count);
        break;
    }
    count++;
}
#+END_SRC
#+BEGIN_SRC java
int[] arr = {2,3,4,8,5};
int num = 9;
for(int i = 0;i<arr.length;i++){
    if(arr[i] == num){
        System.out.println(i);
        break;
    }
}
#+END_SRC
***** 查找元素出现的位置(有序数组)(折半查找/二分查找)
#+BEGIN_SRC java
int[] arr={1,2,3,5,6,8,9};
int num=8;
int min=0;
int max=arr.length-1;
int mid=(min+max)/2;
//标志位
boolean flag=true;
//操作循环拿中间下标对应的元素值和查找数进行比较
while(arr[mid]!=num){
    //中间下标对应的数组元素值小于查找数
    if(arr[mid]<num){
        min=mid+1;
    }
    //中间下标对应的数组元素值大于查找数
    if(arr[mid]>num){
        max=mid-1;
    }
    //判断不在范围内的数
    if(min>max){
        System.out.println("没有这个数");
        flag=false;
        break;
    }
    //新的中间下标值
    mid=(min+max)/2;
}
if(flag){
    System.out.println(mid);
}
#+END_SRC
**** 数组排序
排列数组元素顺序
***** 冒泡排序
相邻两个元素进行两两比较，然后交换位置
[[./25.png]]
#+BEGIN_SRC java
int[] arr={2,1,3,6,5};
//嵌套循环
//控制轮数
for(int i=1;i<arr.length;i++){
    //控制参与操作元素的个数
    for(int j=1;j<=arr.length-i;j++){
        //两两比较
        if(arr[j-1]>arr[j]){
            int temp=arr[j-1];
            arr[j-1]=arr[j];
            arr[j]=temp;
        }
    }
}
System.out.println(Arrays.toString(arr));
#+END_SRC
***** 选择排序
选定一位然后依次和其他位进行比较
[[./26.png]]
#+BEGIN_SRC java
int[] arr={2,1,3,6,5};
//操作嵌套循环
//控制轮数
for(int i=1;i<arr.length;i++){
    //参与运算元素的范围
    for(int j=i-1;j<arr.length;j++){
        //
        if(arr[i-1]>arr[j]){
            int temp=arr[j];
            arr[j]=arr[i-1];
            arr[i-1]=temp;
        }
    }
}
System.out.println(Arrays.toString(arr));
#+END_SRC
***** 升序排序
#+BEGIN_SRC java
Arrays.sort(arr);
#+END_SRC
**** 数组的扩容
数组定义完成之后长度无法改变
实际上数组的扩容本质上就是数组的复制
System.arraycopy(要复制的数组,要复制的起始下标,要存放的数组,要存放的起始下标,要复制的元素个数);
#+BEGIN_SRC java
int[] arr1 = {2,1,5,6,8,0,9};
int[] arr2 = new int[5];
System.arraycopy(arr1,3,arr2,1,3);
for(int i : arr2){
    System.out.println(i);
}
#+END_SRC
***** Arrays.copyOf(原数组,改变之后的长度);
#+BEGIN_SRC java
import java.util.Arrays;
class ArrayDemo2{
    public static void main(String[] args){
        int[] arr1 = {2,3,5,6,8,3};
        int[] arr2 = new int[5];

        arr1 = Arrays.copyOf(arr1,15);
        System.out.println(Arrays.toString(arr1));
    }
}
#+END_SRC
**** 时间复杂度
核心代码执行的时间
二分查找：n(数组长度)/2^x=1 x=log2n(log以2为底的) O(log2n)
冒泡、选择：n(n-1)--->n^2-n--->O(n^2)
Arrays.sort():O(nlogn)
**** 空间复杂度
在代码运行过程中产生的要占用的内存
二分查找、冒泡、选择：O(1)
** 二维数组
数组元素是一维数组的数组
*** 定义格式
**** 数据类型[][] 数组名 = new 数据类型[一维数组的个数][每个一维数组元素的个数];
int[][] arr = new int[3][5];
arr[0]---第一个一维数组
arr[0][0]---第一个一维数组的第一个元素
#+BEGIN_SRC java
int[][] arr=new int[2][3];
//[[I@7852e922---二维数组地址值
System.out.println(arr);
//[I@4e25154f
System.out.println(arr[0]);
//0
System.out.println(arr[0][1]);
#+END_SRC
**** 数据类型[][] 数组名 = new 数据类型[一维数组个数][];
int[][] arr = new int[5][];
表示定义了能存储5个元素类型为int的一维数组
#+BEGIN_SRC java
//声明两个一维数组
int[][] arr=new int[5][];
arr[0] = new int[5];
arr[1] = new int[2];
arr[2] = new int[4];
arr[0] = new int[]{1,2,3};
arr[0] = {1,4,5};//不可以
#+END_SRC
***** NullPointerException---空指针异常
#+BEGIN_SRC java
int[][] arr=new int[5][];
//null
System.out.println(arr[0]);
//NullPointerException
System.out.println(arr[0][0]);
#+END_SRC
**** 数据类型[][] 数组名 = new 数据类型[][]{{数组1},{数组2}};
**** 数据类型[][] 数组名 = {数组1，数组2，数组3，...};
int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
既定义包含的一维数组的个数，也定义了每一个一维数组中的元素
#+BEGIN_SRC java
int[][] arr={{2,6},{2,5,7,7},{5},{2,76,5}};
#+END_SRC
*** 注意：
int[] x;int x[];//等效
如果[]在数据类型的后面，就会随着数据类型修饰的内容一起去修饰，
如果[]在变量的后面，那么这个[]只修饰变量

对int[] x,y[]进行了初始化，下列正确的是？BD
A.x[0][0]=y[0];
B.x[0]=y[0][0];
C.x=y;
D.x=y[0];
E.x[0]=y;
*** 二维数组内存图
[[./27.png]]
*** 二维数组的遍历
**** 普通遍历
 #+BEGIN_SRC java
 int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
 //控制的是一维数组的个数
 for(int i = 0;i<arr.length;i++){
     //控制的是每个一维数组的元素
     for(int j = 0;j<arr[i].length;j++){
         System.out.print(arr[i][j]+"\t");
     }
     System.out.println();
 }
 #+END_SRC
**** 增强for循环
#+BEGIN_SRC java
class ArrayDemo5{
    public static void main(String[] args){
        int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
        //定义一个一维数组依次表示二维数组中的每一个元素
        for(int[] as : arr){
            for(int i = 0;i<as.length;i++){
                System.out.println(as[i]);
            }
        }
    }
}
#+END_SRC
#+BEGIN_SRC java
class ArrayDemo6{
    public static void main(String[] args){
        int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
        for(int[] as : arr){
            for(int i : as){
                System.out.println(i);
            }
        }
    }
}
#+END_SRC

*** 数组的常见的异常
#+BEGIN_SRC java
/*
  数组操作中，常见的两个异常
  - 数组的索引越界异常
    + 负数索引（人为的）
    + 超出范围
  - 空指针异常
,*/
public class ArrayDemo_4{
    public static void main(String[] args){
        //数组的索引越界异常
        int[] arr = {5,2,1};
        //数组中3个元素，索引0，1，2
        System.out.println(arr[3]);

        //空指针异常
        int[] arr2 = {1,5,8};
        //执行正常
        System.out.println(arr2[2]);

        //arr2不在保存数组的地址了
        arr2 = null;
        //不能正常执行
        System.out.println(arr2[2]);
    }
}
#+END_SRC
*** 数组获取最值得原理思想
#+BEGIN_SRC java
/*
  计算数组中的最大值
  数组 {4,1,7,5}; 作比较
,*/
public class ArrayDemo_5{
    //定义数组，int类型
    int[] arr ={5,1,2,4,6,8,0,3};
    //定义变量，记录数组中0索引上的元素
    int max = arr[0];

    //遍历数组，获取所有的元素，和变量max比较
    for(int i = 1;i<arr.length-1;i++){
        //变量max，和数组中的每个元素进行比较
        //如果max，小于了数组中的一个元素
        if(max <arr[i]){
            //较大的数组的元素，赋值给max
            max = arr[i];
        }
        //遍历完成，变量max，就是数组最大值
        System.out.println(max);
    }
}
#+END_SRC
*** 二维数组的定义和访问
#+BEGIN_SRC java
/*
  二维数组
  数组中的数组，数组里面存储的还是数组
  定义方式和一维数组很相似
  int[][] arr = new int[3][4];
  [3] --->表示：二维数组中，有三个一维数组
  [4] --->表示：三个一维数组中，每个数组的长度是4
,*/
public class ArrayArrayDemo{
    public static void main(String[] args){
        int[][] arr = new int[3][4];
        System.out.println(arr);

        System.out.println(arr[1]);
        System.out.println(arr[2][3]);
    }
}
#+END_SRC
#+BEGIN_SRC java
/*
  int[][] arr = new int[3][];
  二维数组中定义三个一维数组，每个一维数组长度没有指定
  arr[0]
  arr[1]
  arr[2]
  必须要new
  arr[0] = new int[5];
  arr[1] = new int[4];

  最简单的二维数组定义方式
  int[][] arr = {{1,4},{3,4,5},{0,9,4}};
,*/
public class ArrayArrayDemo_1{
    public static void main(String[] args){
        int[][] arr = {{1,2,3},{4,5},{5,6,7},{0}};

        //问题：打印7，是数组中的元素
        System.out.println(arr[2][1]);

        //问题：输出结果
        System.out.println(arr[3][0]);
    }
}
#+END_SRC
*** 二维数组的遍历
#+BEGIN_SRC java
/*
  二维数组的遍历
  二维数组中，存储4个一维数组，每个一维数组的长度不同

  遍历：for循环，遍历二维数组
  遍历过程中，for遍历一维数组

,*/
public class ArrayArrayDemo_2{
    public static void main(String[] args){
        int[][] arr = {{1,2,3},{4,5},{6,5,2},{0}};

        //外循环，遍历二维数组
        for(int i= 0;i<arr.length;i++){
            //内循环，遍历每个一位数组 arr[0] arr[1] arr[i]
            for(int j=0;j<arr[i].length;i++){
                System.out.println(arr[i][j]);
            }
            System.out.println();
        }
    }
}
#+END_SRC
*** 二维数组的求和练习
#+BEGIN_SRC java
/*
  二维数组的遍历求和
  第一小组销售额为{11,12}万元
  第二小组销售额为{21,22,23}万元
  第三小组销售额为{31,32,33,34}万元
  每个小组就是一个数组，三个数组存储到一个数组中，形成二维数组
  求和：
      每个小组求和
      所有元素求和
,*/
public class ArrayArraydDemo_3{
    public static void main(String[] args){
        //定义变量，保存2个求和的值
        //所有元素的求和
        int sum = 0;
        //每个一维数组的求和
        int groupSum = 0;

        for(int i= 0;i<arr.length;i++){
            for(int j=0;j<arr[i].length;j++){
                //将一维数组的元素求和
                groupSum + = arr[i][j];
            }
            System.out.println("每个小组总金额"+groupSun);
            //将每个一维数组的综合在相加
            sun+=groupSum;
            //每个一维数组求和，清空
            groupSum = 0;
        }
        System.out.println("本公司总金额"+sum);
    }
}
#+END_SRC
*** 随机点名案例
#+BEGIN_SRC java
/*
  存储全班人的姓名
  1. 存储姓名
  2. 预览所有人的姓名
  3. 随机出一个人的姓名
,*/
import java.util.Random;
public class CallName{
    public static void main(String[] args){
        //存储姓名，姓名存储到数组中
        //数组存储姓名，姓名的数据类型，String
        String[] names = {"张三","李四","王五","李蕾","韩梅梅","小明","小花"};

        //预览：遍历数组，打印所有姓名
        for(int i = 0;i<names.length;i++){
            System.out.println(names[i]);
        }
        System.out.println("---------------------------");

        //随机出一个人的名
        //利用随机数，生成一个整数，作为索引，到数组中找到对象的元素
        Random ran = new Random();
        //随机数，范围必须是0 ~ 数组的最大索引
        int index = ran.nextInt(names.length);//index 就是随机数，作为索引
        System.out.println(names[index]);
    }
}
#+END_SRC

** eclipse
source ---src 域名 www.baidu.com
com.baidu.部门.组号...
** 方法
一段具有特殊功能的代码块，需要时可以通过方法名重复的调用，减少冗余代码
*** 书写格式
修饰符 返回值类型 方法的名字（参数列表...）{
    方法体
    return ;
}

    修饰符：固定写法public static
    返回值类型：返回什么样的数据就用对应的数据类型来接
    没有返回值：void
    方法名：标识符
    参数列表：数据类型和参数的个数
    方法体：执行核心代码
    return：方法的返回，将计算的结果返回;结束方法（用于结束方法以及返回方法指定类型的值）
*** 方法的调用
1. 单独调用
2. 输出调用
3. 赋值调用
**** 方法的注意事项
1. 方法被调用才执行
2. 两个明确：返回值的数据类型，参数列表
3. 没有返回值的方法，不能使用输出调用和赋值调用（不能输出，不能调用）
4. return可以出现在没有返回值的方法里，用于结束方法

   作用：
      a.把返回值进行返回
      b.结束方法
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo3{
       public static void main(String[] args){
           printXing(3,6);
       }
       public static void printXing(int x,int y){
           for(int i=1;i<=x;i++){
               for(int j=1;j<=y;j++){
                   if(j==2)
                       //结束方法
                       return;
                       System.out.println("*");
                   }
               System.out.println();
           }
           //如果输出1就是结束方法，不是结束循环
           System.out.println(1);
       }
   }
   #+END_SRC
   [[./MethodDemo3.java]]
5. 要处理所有的数据，保证每一类数据都有返回
6. 抽取成方法是不定的，根据个人经验
**** 单独调用
方法名(参数值)
#+BEGIN_SRC java
package cn.commandoptionesc.method;
    public class MethodDemo{
        public static void main(String[] args){
            //调用方法
            //单独调用
            printXing(3,6);
        }
        //效果不需要进行返回---返回值类型---void
        //参数列表---int x,int y
        public static void printXing(int x,int y){
            for(int i=1;i<=x;i++){
                for(int j=1;j<=y;j++){
                    System.out.print("*");
                }
            System.out.println();
        }
    }
}
#+END_SRC
[[./MethodDemo.java]]
**** 输出调用
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo1{
    public static void main(String() args){
        //sum(2,4);
        //输出调用
        System.out.println(sum(2,4));
    }
    public static int sum(int m,int n){
        /* int sum=m+n;
           return sum;
        */
        return m+n;
    }
}
#+END_SRC
[[./MethodDemo1.java]]
**** 赋值调用
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo2{
    public static void main(String[] args){
        int result=sum(2,5);
        System.out.println(result);
    }
    public static int sum(int m,int n){
        int sum = m+n;
        return sum;
    }
}
#+END_SRC
[[./MethodDemo2.java]]
*** 方法练习
1. 判断一个整数是否是奇数
   #+BEGIN_SRC java
   //两个明确：返回值类型boolean 参数列表 int m
   package cn.commandoptionesc.method;
   public class MethodDemo4{
       public static void main(String[] args){
           boolean boo= isOdd(8);
           System.out.println(boo);
       }
       public static boolean isOdd(int m){
           //把不正常的范围进行优化
           if(m<0){
               System.out.println("rewrite");
               return false;
           }
           //正常的范围
           if(m%2!=0){
               return true;
           }
           //正常范围，但为偶数
           return false;
       }
   }
   #+END_SRC
   [[./MethodDemo4.java]]
2. 判断一个整数是否是质数
   #+BEGIN_SRC java
   //两个明确：返回值类型booblean 参数列表int m
   package cn.commandoptionesc.method;
   public class MethodDemo5{
       public static void main(String[] args){

       }
       public static boolean isPrime(int m){
           //不正常范围
           if(m<2){
               return false;
           }
           //正常范围下的依次判断
           for(int i=2;i<=m/2;i++){
               //判断是否能被整除
               if(m%i==0){
                   return false;
               }
           }
           return true;
       }
   }
   #+END_SRC
   [[./MethodDemo5.java]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo6{
       public static void main(String[] args){
           isPrime(9);
       }
       public static boolean isPrime(int m){
           if(m<2){
               System.out.println("N");
               return;
           }
           for(int i=2;i<=m/2;i++){
               if(m%i==0){
                   System.out.println("N");
                   return;
               }
           }
           System.out.println("Y");
       }
   }
   #+END_SRC
   [[./MethodDemo6.java]]

*** 方法的重载(overload)
在一个类中，出现了方法名相同的方法
1. 如果有最精确的方法就会进行精确的匹配
2. 如果没有精确匹配就会进行相对精确匹配
3. 如果出现了多个相对精确的匹配就会报错
    #+BEGIN_SRC java
        package cn.commandoptionesc.method;
        public class MethodDemo7{
            public static void main(String[] args){
                //方法名和参数列表共同作为方法签名
                //通过方法签名进行区分调用
                //如果有最精确的方法就会进行精确的匹配
                //如果没有精确匹配就会进行相对精确匹配
                //入股出现了多个相对精确的匹配就会报错
                System.out.println(sum(2,3));
            }
            //求和
            //sum(int,int)
            public static int sum(int i,int j){
                System.out.println("int,int");
                return i+j;
            }
            //sum(int,double)
            public static double sum1(int m,double n){
                System.out.println("int,double");
                return m+n;
            }
            //sum(double,double)
            public static double sum2(double d1,double d2){
                System.out.println("double,double");
                return d1+d2;
            }
        }

    #+END_SRC
    [[./MethodDemo7.java]]
*** 方法的传值
1. 基本数据类型
   值的拷贝
2. 引用数据类型
   地址值的拷贝
   如果这个拷贝的地址找到了堆内存并进行了改动，原值就会改动
   如果没有找到堆内存，原值就不会影响
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo8{
       //所有的方法的执行都是在栈中
       public static void main(String[] args){
           int i=2;
           //实参---实际参数
           //如果传入的是基本类型，就是值的拷贝
           m(i);
           //2
           System.out.println(i);
       }
       //形参---接受值
       public static void m(int i){
           i++;
       }
   }
   #+END_SRC
   [[./MethodDemo8.java]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo9{
       public static void main(String[] args){
           int i=2;
           int[] arr={1,2,3};
           m(arr[0]);
           //1
           System.out.println(arr[0]);
       }
       public static void m(int i){
           i++;
       }
   }
   #+END_SRC
   [[./MethodDemo9.java]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo10{
       public static void main(String[] args){
           int[] arr={1,2,3};
           //如果传入的是引用数据类型，实质是地址值的拷贝
           n(arr);

           //10
           System.out.println(arr[0]);
       }
       public static void n(int[] arr){
           arr[0]=10;
       }
   }
   #+END_SRC
   [[./MethodDemo10.java]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo11{
       public static void main(String[] args){
           int[] arr={1,2,3};
           mn(arr);
           //1
           System.out.println(arr[0]);
       }
       public static void mn(int[] arr){
           //拷贝之后的地址值被新的地址值覆盖
           arr=new int[]{2,3,4};
       }
   }
   #+END_SRC
   [[./MethodDemo11.java]]
   #+BEGIN_SRC java
   public class Ex{
       public static void main(String[] args){
           int[] a={1,2,3,4,5};
           expand(a);
           System.out.println(a);

           changeArray(a);
           System.out.println(a[0]);

           pringArray(a);
       }
       public static void expand(int[] a){
           int[] newArray=new int[a.length*2];
           System.out.println(a,0,newArray,0,a.length);
           a=newArray;
           for(int i=0;i<a.length;i++){
               System.out.print(a[i]+"\t");
           }
           System.out.println();
           System.out.println(a);
       }
       public static void changeArray(int[] a){
           a[0]=10;
           System.out.println(a[0]);
       }
       public static void printArray(int[] a){
           for(int i=0;i<a.length;i++){
               System.out.print(a[i]+"\t");
           }
           System.out.println();
       }
   }
   #+END_SRC
*** 方法的递归
sum(10)=10+9+8+7+6+5+4+3+2+1
       =10+9+8+7+6+5+4+3+2+1
       =10+sum(9)
            9+sum(8)
               8+sum(7)
                  7+sum(6)
                     6+sum(5)
                        5+sum(4)
                           4+sum(3)
                              3+sum(2)
                                 2+sum(1)
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo12{
    public static void main(String[] args){
        System.out.println(diGui(10));
        System.out.println(diGui(5));
    }
    //递归方法求和
    public static int diGui(int n){
        //递归结束的条件
        if(n==1){
            return 1;
        }
        //调用方法自己本身
        return n+diGui(n-1);
        //return 10+diGui(9);
        //          9+diGui(8)
        //            8+diGui(7)
        //              7+diGui(6)
        //         ...
        //               2+diGui(1)
    }

    //递归求5的阶乘
    public static int diGui2(int n){
        //结束条件
        if(n==1){
            return 1;
        }
        return n*diGui2(n-1);
    }
}
#+END_SRC
局限性：可能会出现栈溢出错误


** 引用数据类型--类
*** 自定义类
#+BEGIN_SRC java
/*
  定义类
      使用类的形式，对现实中的事物进行描述
  事物：方法，属性
  方法：这个事物具备的功能
  属性：变量

- 格式
            public class 类名{
                属性定义
                    修饰符 数据类型 变量名 = 值
                方法定义
                    修饰符 返回值类型 方法名（参数列表）{
                    }
            }

            要求：使用java中的类，描述生活中的手机这个事物
                手机事物，具备哪些属性，属于他自己的特性
                 颜色，品牌，大小
       ,*/
      public class Phone{
          /*
            定义手机的属性
          ,*/
          String color;
          String brand;
          double size;
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        测试，刚定义好的Phone类
        创建引用类型变量的格式

            数据类型 变量名 = new 数据类型();

            实现引用类型的步骤
                1. 导入包
                2. 创建引用类型的变量
                3. 变量.类型中的功能
       ,*/
      public class PhoneTest{
          public static void main(String[] args){
              Phone p = new Phone();
              // System.out.println(p);输出内存的地址

              p.color = "土豪金";
              p.brand = "苹果";
              p.size = 5.0;

              System.out.println(p.color+"..."+p.brand+"..."+p.size);
          }
      }
    #+END_SRC

*** 自定义类练习

    #+BEGIN_SRC java
      /*
        电饭锅，包含属性（品牌、容量大小、颜色等）
        定义类，描述事物，电饭锅
            属性：品牌，大小，颜色

            定义类，类名字，电饭锅
       ,*/
      public class DianFanGuo{
          //定义三个属性
          String brand;
          double size;
          String color;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        定义汽车类，类名Car
            属性：品牌 排气 类型
       ,*/
      public class Car{
          String brand;
          double paiLiang;
          String type;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        学生，包含属性（姓名，年龄，性别等）
        定义类，类型Studeng
            三个属性：姓名，年龄，性别
       ,*/
      public class Student{
          String names;
          int age;
          char sex;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        定义的测试类
            同时测试，电饭锅，汽车，学生

       ,*/
      public class Test{
          public static void main(String[] args){
              //创建电饭锅引用类型
              DianFanGuo dfg = new DianFanGuo();

              dfg.brand = "特斯拉";
              dfg.color = "红色";
              dfg.size = 30;

              System.out.println(dfg.brand +"..."+ dfg.color+"..."+dfg.size);


              Car c = new Car();
              c.brand = "巨力";
              c.type = "拖拉机";
              c.color = "蓝色";
              c.paiLiang = 0.5;

              System.out.println(c.brand+"..."+c.type+"..."+c.color+"..."+c.paiLiang);

              Student stu = new Student();
              stu.name = "张三";
              stu.age = 20;
              stu.sex = '男';

              System.out.println(stu.name+"..."+stu.age+"..."+stu.sex);
          }
      }
    #+END_SRC
** ArrayList集合
*** ArrayList创建变量的步骤
    #+BEGIN_SRC java
      /*
        ArrayList集合的使用
        也是引用数据类型
        步骤：
            1. 导入 java.util包中
            2. 创建引用类型的变量
                数据类型<要存储元素的数据类型>   变量名 = new 数据类型<要存储元素的数据类型>();
                集合存储的数据类型：要将数据类型存储到集合的容器中
                创建集合引用变量的时候，必须要指定好，存储的类型是什么

                ArrayList<String> array = new ArrayList<String>();

            3. 变量名.方法

            注意：集合存储的数据，8个基本类型对应8个引用类型
            存储引用类型，不存储基本类型
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo{
          public static void main(String[] args){
              //创建集合容器，指定存储的数据类型
              //存储字符串
              ArrayList<String> array = new ArrayList<String>();

              //创建集合容器，存储整数
              ArrayList<Integer> array2 = new ArrayList<Integer>();

              //创建集合容器，存储手机类型
              ArrayList<Phone> array3 = new ArrayList<Phone>();
          }
      }
    #+END_SRC
*** ArrayList的常见方法
    #+BEGIN_SRC java
      /*
        ArrayList集合中的方法
        add()  --->  向集合中添加元素，数据存储进去
            方法中的参数类型，与你定义集合对象时候的类型是一致的
            ArrayList<Integer> array = new ArrayList<Integer>();
            array.add(3);

        get(int index)  --->  取出集合中的元素，get方法的参数，写入索引

        size()  --->  返回集合的长度，集合存储元素的个数
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo_1{
          public static void main(String[] args){
              //定义集合，存储字符串元素
              ArrayList<String> array = new ArrayList<String>();
              //调用集合方法add存储元素
              array.add("abc");
              array.add("live");
              //输出集合的长度，调用集合方法size，size方法的返回值类型 int
              int size = array.size();
              System.out.println(size);

              //获取出集合中的一个元素，获取1索引的元素
              //集合的方法get，获取元素后结果数据类型
              String s = array.get(1);
              System.out.println(s);

              System.out.println(array.get(0));
              System.out.println(array.get(1));
          }
      }
    #+END_SRC
*** ArrayList集合的遍历

    #+BEGIN_SRC java
      /*
        集合的遍历
        实现思想也是索引思想
        集合的索引从0开始，到size()-1
        方法get(int index)
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo_2{
          public static void main(String[] args){
              ArrayList<Integer> array = new ArrayList<Integer>();
              array.add(121);
              array.add(125);
              array.add(123);
              array.add(120);
              array.add(128);

              //对集合进行遍历
              //使用方法size+get组合进行遍历
              for(int i = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }
          }
      }
    #+END_SRC
*** ArrayList集合补充方法

    #+BEGIN_SRC java
      /*
        集合ArrayList方法的补充
        add(int 索引，存储的元素)将元素添加到指定的索引上
        set(int 索引，修改后的元素)将指定索引的元素，进行修改
       ,*/
      public class ArrayListDemo_3{
          public static void main(String[] args){
              ArrayList<Integer> array = new ArrayList<Integer>();
              array.add(1);
              array.add(2);
              array.add(3);
              array.add(4);

              //在索引2上，添加元素7
              array.add(2,7);
              //使用方法size+get组合进行遍历
              for(int i = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }

              //将0索引上的元素，修改为10
              array.set(0,10);
              //使用方法size+get组合进行遍历
              for(int j = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }

              //将4索引上的元素，删除
              arry.remove(4);

              //清空索引上的元素
              array.clear();
          }
      }
    #+END_SRC

** 随机点名器案例

   #+BEGIN_SRC java
     /*
       随机点名器，集合改进（学生的姓名和年龄）
       现实中有学生这个事物，使用定义类的形式，描述学生事物
       属性：姓名，年龄

       姓名存储了数组，将容器换成是集合
       String[] s = {"" ,""};
       集合中，存储的是学生的姓名吗？应该存储Student类型

       存储学生：
           学生类型，存储到集合中
       总览：遍历集合
       随机：随机数，作为索引，到集合中找到元素
       三个功能，共享的数据，集合容器
      ,*/
     import java.util.ArrayList;
     import java.util.Random;
     public class CallName{
         public static void main(String[] args){
             //定义集合，存储的是StudentName类型变量
             ArrayList<StudentName> array = new ArrayList<StudentName>;
             //调用添加方法
             add(array);
             //调用遍历集合
             printArrayList(array);

             randomStudentName(array);
         }

         /*
           随机数，当做集合的索引，到集合中找到元素
          ,*/
         public static void randomStudentName(ArrayList<StudentName> array){
             Random r = new Random();
             int num = r.nextInt(array.size());
             //随机数，索引，到集合中get
             StudentName s = array.get(num);
             System.out.println(s.name+"..."+s.age);
         }

         /*
           总览学生的信息，遍历集合
         ,*/
         public static void printArrayList(ArrayList<StudentName> array){
             for(int i = 0;i<array.size();i++){
                 //存储集合的时候，集合.add(sn1)  sn1是StudentName类型变量
                 //获取的时候，集合.get()，获取出来的是什么，还是StudentName类型的变量
                 StudentName s = array.get(i);
                 System.out.println(s.name+"..."+s.age);
             }
         }
         /*
           定义方法，实现存储学生的姓名和年龄
           创建StudentName类型变量，存储到集合中
         ,*/
         public static void add(ArrayList<StudentName>array){
             StudentName sn1 = new StudentName();
             StudentName sn2 = new StudentName();
             StudentName sn3 = new StudentName();
             StudentName sn4 = new StudentName();
             StudentName sn5 = new StudentName();

             sn1.name = "张三1";
             sn1.age = 20;
             sn2.name = "张三2";
             sn2.age = 21;
             sn3.name = "张三3";
             sn3.age = 22;
             sn4.name = "张三4";
             sn4.age = 23;
             sn5.name = "张三5";
             sn5.age = 24;

             //将StudentName变量，存储到集合中
             array.add(sn1);
             array.add(sn2);
             array.add(sn3);
             array.add(sn4);
             array.add(sn5);
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       描述学生事物的类
           属性：姓名和年龄
       学生类型的变量,存储到集合中
      ,*/
     public class StudentName{
         String name;
         int age;
     }
   #+END_SRC

** 库存管理案例

   #+BEGIN_SRC java
     /*
       定义，描述商品的类
       商品 4个属性
           商品名字  大小       价格   库存
           String   double   double  int
         定义类，类名Goods
      ,*/
     public class Goods{
         String brand;
         double size;
         double price;
         int count;
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       实现库存管理案例：
           1. 存储商品信息
               创建出集合存储商品类型的变量,将商品类型的变量，存储到集合中

           2. 查看库存清单
               将集合进行遍历，获取出集合中存储的Goods类型
               输出每一个Goods类型的属性
               计算求和：总库存、总金额

           3. 修改商品的库存
               集合遍历，获取集合中存储的Goods类型变量
               变量调用Goods类的属性count，值进行修改（键盘输入）

           4.
      ,*/
     import java.util.Scanner;
     import java.util.ArrayList;
     public class Shopping{
         public static void main(String[] args){
             //创建ArrayList集合，存储Goods类型
             ArrayList<Goods> array = new ArrayList<Goods>();
             //调用添加商品信息的方法
             addGoods(array);

             //进入死循环，如果不选择3退出，就一直在运行
             while(true){
                 //调用选择功能的方法，获取到用户输入的功能序号
                 int num = chooseFunction();
                 //对序号判断，如果=1 进入查看库存功能；=2 进入修改库存功能；=3 结束
                 switch(num){
                 case 1:
                     //进入查看库存，调用查看库存的方法，传递存储商品信息的结合
                     printStore(array);
                     break;
                 case 2:
                     //进入修改库存功能，调用修改库存的方法，传递集合
                     update(array);
                     break;
                 case 3:
                     return ;
                 default:
                     System.out.println("无此功能");
                     break;
                 }
             }
         }
         /*
           定义方法，实现选择菜单，用户根据功能选择菜单
          ,*/
         public static int chooseFunction(){
             System.out.println("-------------------库存管理-------------------");
             System.out.println("1.查看库存清单");
             System.out.println("2.修改商品库存数量");
             System.out.println("3.退出");
             System.out.println("请输入要执行的操作序号:");
             Scanner sc = new Scanner(System.in);
             int num = sc.nextInt();
             return num;
         }

         /*
           方法定义，修改库存
           键盘的输入，将Goods中的属性值，修改
          ,*/
         public static void update(ArrayList<Goods> array){
             Scanner sc = new Scanner(System.in);
             for(int i = 0;i<array.size();i++){
                 //集合方法get获取的是集合的元素，元素类型Goods
                 Goods g = array.get(i);
                 System.out.println("请输入"+g.brand+"的库存数");
                 //Goods属性，count进行修改
                 g.count = sc.nextInt();
             }
         }

         /*
           定义方法，查看库存清单，遍历集合
          ,*/
         public static void printStore(ArrayList<Goods> array){
             System.out.println("----------------------------");
             System.out.println("品牌型号    尺寸     价格      库存数");

             //定义变量，保存总库存数，和总金额
             int totalCount = 0;
             double totalMoney = 0;

             for(int i = 0;i<array.size();i++){
                 //get(索引)获取出集合中的元素，存储的是Goods类，获取的也是Goods类型
                 //使用Goods类型变量，接收get方法结果
                 Goods g = array.get(i);
                 System.out.println(g.brand +"..."+g.price+"..."+g.size+"..."+g.count);
                 totalCount = totalCount + g.count;
                 totalMoney = totalMoney + totalCount*g.price;
             }
         }


         /*
           定义一个方法，将商品的信息存储到集合中.
           集合是所有方法的共享数据，参数传递
          ,*/
         public static void addGoods(ArrayList<Goods> array){
             //创建商品类型变量 Goods类型的变量
             Goods g1 = new Goods();
             Goods g2 = new Goods();
             g1.brand = "MacBook";
             g1.size = 13.3;
             g1.price = 9999.99;
             g1.count = 3;

             g2.brand = "Macbook air";
             g2.size = 15.6;
             g2.price = 999999.99;
             g2.count = 1;

             array.add(g1);
             array.add(g2);
         }
     }
   #+END_SRC

** 数组方法练习
*** 实现数组的遍历
    定义方法，实现数组的遍历
    遍历中，输出结果[11,33,565,66,78,89]
    int[] arr ={3,4,45,7};
    结果包含字符串,[],
    实现步骤：
        1. 定义方法实现数组的遍历
        2. 先打印[ 中括号
        3. 遍历数组
           输出数组的元素和逗号
           判断是否遍历到了数组的最后一个元素，如果是最后一个元素，输出]中括号

           #+BEGIN_SRC java
             public class ArrayMethidTest{
                 public static void main(String[] args){
                     int[] arr = {4,6,7,1};
                 }
                 public static void printArray(int[] arr){
                     //输出一半中括号，不要换行打印
                     System.out.print("[");
                     //数组遍历
                     for(int i=0;i<arr.length;i++){
                         //判断遍历到的元素，是不是数组的最后一个元素
                         //如何判断 循环变量 到达 length-1
                         if(i == arr.length-1){
                             //输出数组的元素和]
                             System.out.print(arr[i]+"]");
                         }else{
                         //不是数组的最后一个元素，输出数组和逗号
                             System.out.print(arr[i]+",");
                         }
                     }
                     System.out.println();
                 }
             }
           #+END_SRC

*** 数组逆原理
      数组的逆序
      数组中的元素，进行位置上的交换
      逆序不等于反向遍历
      就是数组中最远的两个索引，进行位置交换，实现数组的逆序
      使用的是数组的指针思想，就是变量，思想，可以随时变换索引
      反转 reverse

      逆序的实现思想，数组最远端位置的交换
      数组的指针思想：就是数组的索引(指针是可以随时指向数组的任意一个索引的)
      需要两个指针 ---> 一个大指针，一个小指针
      大指针 ---> 最大索引
      小指针 ---> 0索引
      数组换位，借用第三方的变量，临时性存储

    #+BEGIN_SRC java
      /*

            实现步骤：
                1. 定义方法，实现数组的逆序
                2. 遍历数组实现数组的最远索引换位置
                    使用临时的第三方变量
       ,*/
      public class ArrayMethodTest_1{
          public static void main(String[] args){
              int[] arr = {1,2,3,4};
              reverse(arr);
              printArray(arr);
          }

          /*
            定义方法，实现数组的逆序
            返回值：没有返回值
            参数： 数组就是参数
           ,*/
          public static void reverse(int[] arr){
              //利用循环，实现数组遍历，遍历过程中，最远端换位
              //for的第一项，定义两个变量,最后，两个变量++ ，--
              for(int min = 0,max = arr.length-1;min<max;min++,max--){
                  //数组中的元素，进行位置交换
                  //min索引和max索引的元素
                  int temp = arr[min];
                  //max索引上的元素，赋值给min索引
                  arr[min] = arr[max];
                  //临时变量，保存的数据，赋值到max索引上
                  arr[max] = temp;
              }
          }
          public static void printArray(int[] arr){
              System.out.print("[");
              for(int i=0;i<arr.length;i++){
                  if(i==arr.length-1){
                      System.out.print(arr[i]+"]");
                  }else{
                      System.out.print(arr[i]+",");
                  }
              }
          }
      }
    #+END_SRC

*** 数组元素排序
    规则：比较大小位置交换
**** 选择排序(selectSort)：
     数组中的每个元素都进行比较
     数组中每个元素和其他元素进行比较换位置
     #+BEGIN_SRC java
       public class ArrayMethodTest_2{
           public static void main(String[] args){
               int[] arr = {3,1,5,7,9,0,2};
               selectSort(arr);
               printArray(arr);
           }
           /*
             定义方法，实现数组的选择排序
             返回值：没有
             实现步骤：
                 1. 嵌套循环实现排序
                     外循环，控制的是一共比较了多少次
                     内循环，控制的是每次比较了多少个元素
                 2. 判断元素的大小值
                     小值，存储到小的索引
            ,*/
           public static void selectSort(int[] arr){
               for(int i = 0;i<arr.length-1;i++){
                   //内循环，是每次都在减少，修改变量的定义
                   for(int j = i+1;j<arr.length;j++){
                       if(arr[i]<arr[j]){
                           //数组换位
                           int temp = arr[i];
                           arr[i] = arr[j];
                           arr[j] = temp;
                       }
                   }
               }
           }
           public static void printArray(int[] arr){
               System.out.print("[");
               for(int i = 0;i<arr.length;i++){
                   if(i == arr.length - 1){
                       System.out.print(arr[i] + "]");
                   }else{
                       System.out.print(arr[i]+",");
                   }
               }
               System.out.println();
           }
       }
     #+END_SRC
**** 冒泡排序(bubbleSort)：
     数组中相邻元素进行比较
     数组的相邻元素换位置

     #+BEGIN_SRC java
       public class ArrayMethodTest_3{
           public static void main(String[] args){
               bubbleSort(arr);
               printArray(arr);
           }
           /*
             定义方法，实现数组的冒泡排序
             返回值：没有
             参数：数组
            ,*/
           public static void bubbleSort(int[] arr){
               for(int i = 0;i<arr.length-1;i++){
                   for(int j = 0;j<arr.length-i-1;j++){
                       if(arr[j]>arr[j+1]){
                           int temp = arr[j];
                           arr[j] = arr[j+1];
                           arr[j+1] = temp;
                       }
                   }
               }
           }
           public static void printArray(int[] arr){
               System.out.print("[");
               for(int i = 0;i<arr.length;i++){
                   if(i == arr.length -1){
                       System.out.print(arr[i] + "]");
                   }else{
                       System.out.print(arr[i] + ",");
                   }
               }
               System.out.println();
           }
       }
     #+END_SRC

**** 折半查找
     前提：被查找数组中的元素，必须有序排列
     折半后的指针索引和被查找元素比较
     元素>中间索引上的元素
         小指针 = 中间索引 + 1
     元素<中间索引上的元素
         大指针 = 中间索引 - 1
     小指针的索引>大指针索引，结束
     没找到的情况下，得到一个-1的索引
     元素 == 数组中间索引上的元素，也结束
     结果就是中间索引

     #+BEGIN_SRC java
       public class ArrayMethodTest_4{
           public static void main(String[] args){
               int[] arr = {1,3,5,7,9,11,15};
               int index = binarySearch(arr,11);
               System.out.println(index);
           }
           /*
             定义方法，实现，折半查找
             返回值：索引
             参数：数组，被找到的元素
             实现步骤：
                 1. 需要的变量定义
                     三个，三个指针
                 2. 进行循环折半
                     可以折半的条件 min<=max
                 3. 让被找元素，和中间索引元素进行比较
                     元素>中间索引    小指针 = 中间+1
                     元素<中间索引    大指针 = 中间-1
                     元素==中间索引    找到了，结束了，返回中间索引
                 4. 循环结束，无法折半
                     元素没有找到，返回-1
            ,*/
           public static int binarySearch(int[] arr,int key){
               //定义三个指针变量
               int min = 0;
               int max = arr.length -1;
               int mid = 0;
               //循环折半，条件min<=max
               while(min<=max){
                   //公式，计算中间索引
                   mid = (min+max)/2;
                   //让被找元素，和中间索引元素进行比较
                   if(key>arr[mid]){
                       min = mid + 1;
                   }else if(key<arr[mid]){
                       max = mid - 1;
                   }else{
                       //找到元素，返回元素索引
                       return mid;
                   }
               }
               return -1;
           }
       }
     #+END_SRC

** 超市管理系统

   #+BEGIN_SRC java
     /*
       自定义类，描述商品信息
       商品属性
           编号：int
           品名，String
           价格，double
           数量，int
           总价，double
     ,*/
     public class FruitItem{
         int ID;
         String name;
         double price;
         int number;
         double money;
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       超市管理系统
       实现：
           1. 商品数据的初始化
           2. 用户的菜单选择
           3. 根据选择执行不同的功能
               Creat，添加商品
               Update，修改商品
               Read，查看商品
               Delete，修改商品

        所有功能，必须定义方法实现
        主方法main 调用作用
      ,*/
     public class Shop{
         public static void main(String[] args){
             //创建ArrayList集合，存储商品类型，存储数据类型FruiteItem类型
             ArrayList<FruitItem> array =new ArrayList<FruitItem>();
             init(array);
             while(true){
                 //调用菜单方法
                 mainMenu();
                 //调用用户选择序号方法
                 int choose =  chooseFunction();
                 switch(choose){
                 case 1:
                     //调用1：货物清单
                     showFruitList(array);
                     break;
                 case 2:
                     //调用2：添加货物
                     addFruit(array);
                     break;
                 case 3:
                     //调用3：删除货物
                     deleteFruit(array);
                     break;
                 case 4:
                     //调用4：修改货物
                     updateFruit(array);
                     break;
                 case 5:
                     return ;
                 default:
                     System.out.println("输入有误");
                     break;
                 }
             }
         }
         /*
           定义方法，实现商品的修改功能
           返回值：无
           参数：集合


           提示用户选择的是修改功能
           提示用户输入需要修改的商品编号
           遍历集合，获取每个FruitItem的变量
           变量调用ID属性，属性和用户输入的编号比较
           如果相同：
               修改调FruitItem中的属性值
               键盘输入
          ,*/
         public static void updateFruit(ArrayList<FruitItem> array){
             System.out.println("选择的是修改功能");
             System.out.println("请输入商品的编号");

             Scanner sc = new Scanner(System.in);
             int ID = sc.nextInt();
             //遍历结合，获取每个FruitItem变量
             for(int i = 0;i<array.size();i++){
                 FruitItem item = new FruitItem();
                 //获取FruitItem的属性ID，和用户输入的ID比较
                 if(item.ID == ID){
                     System.out.println("输入新的商品编号");
                     item.ID = sc.nextInt();

                     System.out.println("输入新的商品名字");
                     item.name = sc.next();

                     System.out.println("输入新的商品价格");
                     item.price = sc.nextDouble();

                     System.out.println("商品修改成功");
                     return ;
                 }
             }
             System.out.println("您输入的编号不存在");
         }
         /*
           定义方法，实现商品的删除功能
           返回值：无
           参数：集合

           删除依靠的是商品的编号
           提示用户选择的是删除功能
           键盘输入商品的编号
           遍历结合，获取集合中的每个Fruititem变量
           变量通用属性 ID 和用户的输入编号对比，相同就删除
          ,*/
         public static void deleteFruit(ArrayList<FruitItem> array){
             System.out.println("选择的是删除功能");
             System.out.println("请输入删除的编号");
             Scanner sc = new Scanner(System.in);

             int ID = sc.nextIne();
             //遍历集合
             for(int i = 0;i<array.size();i++){
                 //获取到每个FruitItem变量
                 FruitItem item = array.get(i);
                 //变量，调用属性ID，和用户输入的编号比较
                 if(item.ID == ID){
                     //移除集合中的元素
                     //集合的方法remove实现
                     array.remove(i);
                     System.out.println("删除成功");
                     return ;
                 }
             }
             System.out.println("您输入的编号不存在");
         }
         /*
           定义方法，实现商品的添加功能
           返回值：无
           参数：集合
           提示用户输入的是添加商品的功能

           提示用户输入的是什么

           创建FruitItem变量，变量调用的属性
           将输入的每个商品属性进行赋值
          ,*/
         public static void addFruit(ArrayList<FruitItem> arrau){
             System.out.println("选择的是添加商品功能");
             //创建Scanner变量
             Scanner sc = new Scanner(System.in);
             System.out.println("请输入商品的编号");
             //输入商品的编号
             int ID = sc.nextInt();
             //输入商品的名字
             System.out.println("请输入商品的名字");
             String name = sc.next();
             //输入商品的单价
             System.out.println("输入商品的单价");
             double price = sc.nextDouble();
             //创建FruitItem变量
             FruitItem item = new FruitItem();
             //item.属性赋值
             item.ID = ID;
             item.name = name;
             item.price = price;
             array.add(item);
         }
         /*
           定义方法，实现显示货物清单功能
           返回值：无
           参数：无
           参数：集合
           遍历集合，获取集合中的每个FruitItem变量，变量，调用属性
          ,*/
         public static void showFruitList(ArrayList<FruitItem> array){
             System.out.println();
             System.out.println("=======================商品库存清单========================");
             System.out.println("商品编号      商品名称     商品单价");
             //遍历集合
             for(int i = 0;i<array.size();i++){
                 //集合get方法，获取出每个FruitItem变量，可以使用FruitItem接受get结果
                 FruitItem item = array.get(i);
                 //变量item调用类中属性
                 System.out.println(item.ID+"  "+item.name+"  "+item.price);
             }
         }
         /*
           定义方法，实现接受用户的键盘输入
           返回编号
          ,*/
         public static int chooseFunction(){
             Scanner sc = new Scanner(System.in);
             return sc.nextInt();
         }
         /*
           定义方法，实现主菜单
           提示用户用户有哪些选择
           方法返回值：无
           参数：无
          ,*/
         public static void mainMenu(){
             System.out.println("                            ");
             System.out.println("-----------------欢迎光临----------------");
             System.out.println("1. 货物清单 2. 添加货物 3. 删除货物 4. 修改货物 5. 退出");
             System.out.println("请您输入要操作的功能序号");
         }
         /*
           定义方法，实现商品数据的初始化
           先将一部分数据，存储集合中
           返回值：无
           参数：集合
           方法名：init
          ,*/
         public static void init(ArrayList<FruitItem> array){
             //创建出多个FruitItem类型，并且属性赋值
             FruitItem f1 = new FruitItem();
             f1.ID = 9527;
             f1.name = "少林寺";
             f1.price = 12.7;

             FruitItem f2 = new FruitItem();
             f2.ID = 9522;
             f2.name = "哈密瓜";
             f2.price = 11.2;

             FruitItem f3 = new FruitItem();
             f3.ID = 9231;
             f3.name = "ABC";
             f3.price = 34.3;

             //创建3个FruitItem类型变量，存储到集合中
             array.add(f1);
             array.add(f2);
             array.add(f3);
         }
     }
   #+END_SRC
* 面向对象
** 面向对象引入
在java中所有的非静态的属性和方法都可以通过对象调用
*** 理解什么是面向过程、面向对象
- 面向过程：
  关注实现细节，复用性
  遇到一件事，思考”我该怎么做”，然后一步步实现过程
  关注的是一系列功能具体实现的细节
- 面向对象
  把所有的实现细节整合到对象中，只要找到对象就能拿到对应的功能
  遇到一件事，思考“我该让谁来做”。那个“谁”就是对象，总而言之一群对象合力把事情解决好了。
  + 面向对象基于面向过程，面向对象优于面向过程？
    如果使用场景越简单就优先于采用面向过程，反之采用面向对象
*** 面向对象举例(组装电脑)
- 面向过程
  查询组件报价，自己买，自己组装，组装好。
- 面向对象
  找个懂电脑的人帮我买，帮我组装，过程不过问。
*** 对象在代码中的体现
- 类的真正意义就是描述事物，属性和功能统称为事物中的成员
  事物的成员分为两种：成员属性和成员功能
  + 成员属性在代码中的体现就是成员变量
  + 成员功能在代码中的体现就是成员方法
- 定义类的格式
  #+BEGIN_SRC java
  public class 类名{
      //可编写0~n个属性
      数据类型 变量名1;
      数据类型 变量名2;

      //可编写~n个方法
      修饰符 返回值类型 方法名(参数){
          执行语句;
      }
  }
  #+END_SRC
  + 汽车类
    #+BEGIN_SRC java
    public class Car{
        String color;
        int number;

        void run(){
            System.out.println(color + ":"+number);
        }
    }
    #+END_SRC
- 创建对象的格式
  + 类名 对象名 =new 类名();
      Car c=new Car();
      创建Car类的对象
    对象在堆内创建后，类的成员变量，跟随对象进入到堆内存中，赋值默认值
- 小案例
  #+BEGIN_SRC java
  /*
    类的方式，描述现实中的事物 小汽车

    小汽车 属性和功能
        属性：颜色 轮胎个数  变量定义
        功能：跑 方法
    属性和方法，都属于类的成员
    属性又叫做成员变量
    方法又叫做成员方法
  ,*/
  public class Car{
      //定义Car类的属性

      //定义颜色属性
      String color;
      //定义轮胎个数
      int count;

      public static void main(String[] args){

      }

      public void run(){
          System.out.println("小汽车再跑..."+color+"..."+count);
      }

  }
  #+END_SRC
  #+BEGIN_SRC java
  /*
    测试,自定义的类Car
    创建出Car类的变量
    变量，调用属性，成员变量
    变量，调用方法

  ,*/
  public class CarTest{
      public static void main(String[] args){
          //创建出Car类的变量/创建出Car类的对象
          Car c=new car();
          //对象.调用类中的属性和方法
          c.color="无色";
          c.count=5;
          c.run();
      }
  }
  #+END_SRC
*** 类与对象之间的关系
对着一类事物进行抽取，把这类事物共有的特征抽取成了属性，把共有的行为抽取成了方法，把这一类事物抽取成了类
类是对象的概括
对象是类的具体实现
[[./img/28.png]]
#+BEGIN_SRC java
package cn.commandoptionesc.object;
public class ObjectDemo{
    public static void main(String[] args){
        //创建Person类的对象
        //构造方法---用于构建对象
        Person p=new Person();
        //给属性进行赋值
        p.age=10;
        p.name="lili";
        p.gender="女";
        //输出
        System.out.println(p.age);
        //方法调用
        p.eat();
        //基本类型，传入的就是值的拷贝
        //m(p.age);
        //传入的是引用数据类型，就是对象的地址值的拷贝
        n(p);
        //0
        System.out.println(p.age);
    }
    public static void m(int i){
        i++;
    }
    public static void n(Person p){
        p.age=10;
        p.eat();
        }
    }
    //Person类
    class Person{
        //特征---属性
        String name;
        int age;
        char gender;

        //构造方法---1.与类同名 2.没有类型修饰
        //java规定如果类中没有构造方法，JVM就会在底层自动添加一个无参构造
        public Person(){}
        //与类同名的普通方法
        public void Person(){}

        //行为---方法
        public void eat(){
            System.out.println(name+"在吃东西。。。");
        }
        public void sleep(){
            System.out.println("在睡觉");
        }
    }
#+END_SRC
*** 构造方法
与类同名且没有返回值类型修饰的方法，用于创建对象以及属性初始化
如果类中没有构造方法，JVM会自动添加一个无参构造
如果类中已经有构造方法，JVM就不会再自动添加一个无参构造
允许重载
#+BEGIN_SRC java
package cn.commandoptionesc.object;
public class ObjectDemo1{
    public static void main(String[] args){
        //创建Person类的对象
        //构造方法---用于构建对象
        Person p=new Person(16);
        System.out.println(p.age);
    }
}
//Person类
class Person{
    //构造方法---1.与类同名 2.没有类型修饰
    //java规定如果类中没有构造方法，JVM就会在底层自动添加一个无参构造
    public Person(){
    }
    //有参构造
    //构造方法允许重载
    //如果类中提供了构造方法，JVM就不会再自动添加一个无参构造
    public Person(int a){
        age=a;
    }
    //与类同名的普通方法
    public void Person(){
    }
}
#+END_SRC
*** this关键字
**** this.
代表的是当前类的对象，可以指代类还没有创建出来的对象。还可以指代当前类正在活动的对象，可以调用类中的属性和方法。
#+BEGIN_SRC java
package cn.commandoptionesc.object;
    public class ThisDemo{
        public static void main(String[] args){
            //创建对象
            Student s1=new Student();
            //this指代的对象就是s1
            System.out.println("s1:"+s1);
            Student s2=new Student(12);
            System.out.println("s2:"+s2);
            s1.study();
        }

    }
    //学生类
    class Student{
        //属性
        String name;
        int age;
        char gender;
        //学号
        String no;

        //
        public Student(){
            System.out.println("this:"+this);
        }

        public Student(int age){
            this.age=age;
            System.out.println("this2:"+this);
        }

        //方法
        public void study(){
            //this可以代替当前类，还没有创建出来的对象
            System.out.println(this.name+"在好好学习");
            System.out.println("this3:"+this);
        }
    }
#+END_SRC
**** this()
this()---this语句---在当前构造方法中调用本类其他形式的构造方法,一定要放在首行
#+BEGIN_SRC java
package cn.commandoptionesc.object;
    public class ThisDemo2{
        public static void main(String[] args){
            //创建对象
            Student s1=new Student();
            //this指代的对象就是s1
            System.out.println("s1:"+s1);
            Student s2=new Student(12);
            System.out.println("s2:"+s2);
            s1.study();
        }

    }
    //学生类
    class Student{
        //属性
        String name;
        int age;
        char gender;
        //学号
        String no;
        public Student(int age){
            this.age=age;
        }

        //
        public Student(int age,String name){
            //System.out.println("this:"+this);
            //this.age=age;
            //this()---this语句---在当前构造方法中调用奔雷其他形式的构造方法
            //调用构造方法的age
            this(age);
            this.name=name;
        }

        public Student(int age,char gender,String name){
            // this.name=name;
            //this.age=age;
            this(age,name);
            this.gender=gender;
            //System.out.println("this2:"+this);
        }

        //方法
        public void study(){
            //this可以代替当前类，还没有创建出来的对象
            //System.out.println(this.name+"在好好学习");
            //System.out.println("this3:"+this);
        }
    }

#+END_SRC
[[./Source Code/ExtendsDemo2.java]]
*** 构造代码块
在方法外，类内出现{}就是构造代码块，可以进行初始化，在每个构造方法前，优先执行，调用任意的构造方法，构造代码块都要执行
#+BEGIN_SRC java
package cn.commandoptionesc.object;
public class ObjectDemo2{
    public static void main(String[] args){
        //创建对象
        Baby b=new Baby();
        System.out.println("b.name:"+b.name+","+"b.age:"+b.age);


        Baby b1=new Baby("lol",12);
        System.out.println("b1.name:"+b1.name+","+"b1.age:"+b1.age);
    }
}
//婴儿类
class Baby{
    //属性
    int age;
    String name;
    char gender;

    //构造代码块---属性初始化
    //构造代码块会在每个构造方法之前先执行
    {
        this.name="lili";
        this.age=1;
        //检验构造代码块是否在每个构造方法前执行
        System.out.println("构造代码块");
    }

    //构造方法
    public Baby(){
        /* this.name="lili";
        this.age=1;*/
    }

    //有参构造
    public Baby(int age){
        /* this.name="lili";
        this.age=1;*/
        //this.age=age;
    }

    //
    public Baby(String name,int age){
        /* this.name=name;
        this.age=age;*/
        /*this.name="lili";
        this.age=1;*/
        System.out.println("有参构造");
    }
    //方法
    public void Cry(){
        System.out.println(this.name+"在哇哇哇的哭");
    }
}

#+END_SRC
*** 局部代码块
在方法中{}---用于控制变量的生命周期，提高内存利用率
#+BEGIN_SRC java
package cn.commandoptionesc.object;
public class ObjectDemo3{
    public static void main(String[] args){
        int j=7;
        //局部（方法）代码块
        //控制变量的生命周期
        {
            int i=10;
            System.out.println(i+j);
        }

        //1000行
    }
}
#+END_SRC
*** 匿名对象
没有名称的对象---可以调用属性和方法
弊端：使用一次就要创建一个对象，开辟新的空间
主要用于参数的传递
#+BEGIN_SRC java
package cn.commandoptionesc.object;
public class ObjectDemo2{
    public static void main(String[] args){
        //创建对象
        Baby b=new Baby();
        System.out.println("b.name:"+b.name+","+"b.age:"+b.age);


        Baby b1=new Baby("lol",12);
        System.out.println("b1.name:"+b1.name+","+"b1.age:"+b1.age);


        //创建匿名对象,调用属性和方法
        new Baby("lilei",13).Cry();


        //用于参数传递
        //给对象传值
        m(Baby());
    }
    public static void m(Bybu b){}
    }
    //婴儿类
    class Baby{
        //属性
        int age;
        String name;
        char gender;

        //构造代码块---属性初始化
        //构造代码块会在每个构造方法之前先执行
        {
            this.name="lili";
            this.age=1;
            //检验构造代码块是否在每个构造方法前执行
            System.out.println("构造代码块");
        }

        //构造方法
        public Baby(){
            /* this.name="lili";
            this.age=1;*/
        }

        //有参构造
        public Baby(int age){
            /* this.name="lili";
            this.age=1;*/
            //this.age=age;
        }

        //
        public Baby(String name,int age){
            /* this.name=name;
            this.age=age;*/
            /* this.name="lili";
            this.age=1;*/
            System.out.println("有参构造");
        }
        //方法
        public void Cry(){
            System.out.println(this.name+"在哇哇哇的哭");
        }
    }

#+END_SRC
#+BEGIN_SRC java
/*
  有名字对象，引用类型变量，可以反复使用
  匿名对象，没有引用变量，只能使用一次

  匿名对象，可以当做参数进行传递
  匿名对象，可以当做方法的返回值
,*/
import java.util.Scanner;
public class PersoneTest{
    public static void main(String[] args){
        //创建一个普通变量
        Persone p = new Persone();

        new Persone().eat();

        //匿名对象，可以当做参数进行传递
        method(new Persone());
        //匿名对象，可以当做方法的返回值
        Persone p1 = method();
        p1.eat();
    }

    //匿名对象，可以当做方法的返回值
    //方法返回值是Persone类型
    //方法return语句，返回的是这个类的对象
    public static Persone method(){
        //Persone p = new Persone();
        return new Persone();
    }

    //调用方法method，传递Persone类型对象
    public static void method(Persone p){
        p.eat();
    }
}
#+END_SRC
*** 成员变量与局部变量（在类内方法外非静态的属性和方法-成员变量，成员方法）
|          |                                          |                                    |
|----------+------------------------------------------+------------------------------------|
| 区别     | 成员变量                                 | 局部变量                           |
| 定义位置 | 方法外类中                               | 方法或者代码块内                   |
| 作用范围 | 整个类                                   | 方法或者代码块内                   |
| 内存变量 | 堆                                       | 栈                                 |
| 生命周期 | 随着类的对象的创建而产生                 | 随着方法或者代码块的执行而产生     |
|          | 对象使用完成之后在某个特定的时间进行销毁 | 方法调用完成或者执行完成就立即销毁 |
|----------+------------------------------------------+------------------------------------|
|          |                                          |                                    |
- 位置
  成员变量：在方法外类内
  局部变量：方法内或者代码块内
- 作用范围
  成员变量：整个类
  局部变量：方法或者代码块内
- 内存变量
  成员变量：堆
  局部变量：栈
- 生命周期
  成员变量：随着类的对象的创建而产生，对象使用完成之后在某个特定的时间进行回收
  局部变量：随着方法或者代码块的执行而产生，方法调用完成或者执行完成就立即清除
** 面向对象特征
   封装、继承、多态、抽象
*** 封装
    封装的体现形式---方法，对属性进行私有化，通过公共的访问方式去访问私有属性，可以提高代码的数据安全性
    #+BEGIN_SRC java

    #+END_SRC
    [[./Source Code/ExtendsDemo.java]]
*** 继承关系
    多个类中存在相同的内容，就把相同的内容抽取到一个新类中，让新类和原来的类就通过extends关键字就产生了关联关系
    子类可以拿到父类部分信息
    - 继承形式：
      java支持单集成（父类只能有一个，子类可以有多个）
      c语言支持多技能
      #+BEGIN_SRC java
          class A{
              m();
          }
          class B{
              n();
          }
          //多继承同时拿到m和n方法，极高的提高代码的复用性
          class C extends B,A{}
      #+END_SRC
      #+BEGIN_SRC java
          class A{
              m(return 1;);
          }
          class B{
              m(return true;);
          }
          //单技能可以避免方法的混用，提高代码的复用性
          class c extends A,B{}
      #+END_SRC
*** 方法的重写
    在父子类中出现了方法的签名一致的方法，要遵循方法重写的原则：两等两小一大
    父子类的方法签名一致
    如果父类的方法返回值是基本类型或者/void，那么子类的方法的返回值类型和父类一致
    基本数据类型的数据级别一直，只是范围不一样
    如果父类的方法返回值类型是引用数据类型，那么子类的方法返回值的类型要么和父类一致，要么是父类的子类
    #+BEGIN_SRC java

        class A{}
        class B extends A{}

        class C{
            public A m(){
                return null;
            }
        }
        class D extends C{
            public B/A m(){
                return null;
            }
        }
    #+END_SRC
    父类的方法被访问权限修饰符修饰，那么子类的方法的访问权限修饰符要么和父类一致，要么比父类的范围大
    #+BEGIN_SRC java
        Class A{
            public void m(){}
        }
        class B extends A{
            public void m(){}
        }
    #+END_SRC
*** 访问权限修饰符
    |           | 本类 | 子类     | 同包类 | 其他类 |
    |-----------+------+----------+--------+--------|
    | public    | 可以 | 可以     | 可以   | 可以   |
    | protected | 可以 | 可以     | 可以   | 不可以 |
    | private   | 可以 | 同包子类 | 可以   | 不可以 |
    | 默认      | 可以 | 不可以   | 不可以 | 不可以 |
*** 继承
**** 重写
     访问权限修饰符（public protected 默认 private）
     - private：
       父类中被private修饰的内容、构造方法、构造代码块对于子类而言都是拿不到的
       #+BEGIN_SRC java
           package cn.commandoptionesc.extendsx;
           public class ExtendsDemo1{
               public static void main(String[] args){

               }
           }

           //
           class A{
               //私有化的方法  对子类不可见
               private void m(){

               }
           }

           class B extends A{
               //新方法
               int m(){
                   return 1;
                   }
               }

       #+END_SRC
       [[./Source Code/ExtendsDemo1.java]]
     - protected:
       #+BEGIN_SRC java
           package cn.commandoptionesc.extendsx.b;
           import cn.commandoptionesc.extendsx.a.A;
               public class B{
                   public static void main(String[] args){
                   //对象调用方法---访问
                   //new A().m();
                   B b=new B();
                   b.m();
               }
           }
           class C extends A{
               public static void main(String[] args){
                   B b=new b();
                   //被protected修饰的方法，子类对象要在子类中使用
                   //bm();
               }
           }
       #+END_SRC
       #+BEGIN_SRC java
           package cn.commandoptionesc.extendsx.a;
           public class A{
               //
               protected void m(){

               }
           }
       #+END_SRC
       [[./Source Code/A.java]]
       [[./Source Code/B.java]]
**** super关键字
     父类的对象，用于调用父类的属性和方法
     子类的所有的构造方法都要默认调用父类的无参构造（通过super()）
     如果父类提供其他形式的构造方法，子类就要使用相应形式的super(),要在首行
     父类对象优先子类对象的存在
     父类构造代码块--->父类构造方法--->子类构造代码块--->子类构造方法
     #+BEGIN_SRC java
         package cn.commandoptionesc.extendsx;
         public class ExtendsDemo2{
             public static void main(String[] args){
                 new Pig().eat();
             }
         }
         //动物类
         class Animal{
             public Animal(){

             }
             public Animal(int age){

             }
             //方法
             public void eat(){
                 System.out.println("在吃东西...");
             }

             public void sleep(){
                 System.out.println("在睡觉...");
             }
         }
         class Pig extends Animal{
             //父类对象优先子类对象存在
             //子类所有的构造方法都要去调用父类无参构造（默认）
             public Pig(){
                 //super()----super语句，在子类中调用父类的构造方法
                 //子类所有的构造方法都含有super()
                 //本构造方法中有了其他形式的super()就没有super（）
                 //super(1);
             }
             public Pig(int age){
                 //super()
                 //this();
                 super(age);
             }
             public void eat(){
                 System.out.println("在呼呼呼的吃...");
                 System.out.println("慢慢的吃饱了...");
                 System.out.println("吃饱了就想睡觉...");
                 //父类方法
                 //非静态的方法可以通过对象调用
                 //super.sleep();------代表父类的对象调用sleep()方法
                 super.sleep();
                 sleep();
             }
         }
     #+END_SRC
**** 多态
     - 在代码操作过程中可以灵活展现多种形式
     - 程序的时期---多态时期
       + 编译时多态(重载)：就是在编译时期进行绑定代码
         #+BEGIN_SRC java
             public void m(){}
             public void m(int n){}
         #+END_SRC
       + 运行时多态(重写)：就是运行时期进行代码的绑定
         重写，向上造型---前提是集成
     - 向上造型
       子类类型被提升为父类类型
       向上造型的对象可以调用哪些方法看父类，具体的执行看子类（父类---目录 子类---正文）
     - 向下造型
       Fu f = new Zi();
       Zi z = (Zi)f;
       多态中的向下转型，父类类型强制转回子类类型
       好处：调用子类特有的功能
     - 优点：
       + 参数的统一化
       + 功能调用的统一
       + 解耦（高内聚、低耦合）
     #+BEGIN_SRC java
         package cn.commandoptionesc.duotai;
         public class DTDemo{
             public static void main(String[] args){
                 //告诉别人要养宠物，宠物是猫
                 //声明类---父类，实际创建类---子类 向上造型
                 Pet p=new Cat();

                 //调用方法
                 //向上造型创建的对象调用方法执行，由子类具体执行
                 p.eat();

                 //向上造型创建的对象可以调用哪些方法看父类
                 //p.play();
                 p.sleep();
                 n(p);
                 n(new Dog());
                 n(new Cat());
             }
             //参数的统一
             //只要等到运行时期才能明确向上造型的对象由谁实际创建
             public static void n(Pet p){
                 p.eat();
             }
         }
         //宠物类
         class Pet{
             //方法
             public void eat(){
                 System.out.println("在吃东西...");
             }
             public void sleep(){
                 System.out.println("在睡觉...");
             }
         }

         //猫
         class Cat extends Pet{

             //重写方法
             public void eat(){
                 System.out.println("一点一点的吃...");
             }

             public void play(){
                 System.out.println("在舔爪子...");
             }
         }

         //狗
         class Dog extends Pet{

             //重写
             public void eat(){
                 System.out.println("大口大口的吃...");
             }
             public void bark(){
                 System.out.println("在汪汪汪的叫...");
             }
         }

     #+END_SRC
     #+BEGIN_SRC java
         /*
           图形类(Shape),长和宽(属性),求面积，求周长(方法)
           ---矩形类---(含参构造---赋值) 周长和面积
           ---正方形类---(含参构造---赋值)周长和面积
           ---圆形---（含参构造---赋值）周长和面积
         */

     #+END_SRC

** static关键字(静态)
可以修饰：变量、方法、代码块、内部类
属于类的信息全部存储在方法区内
类是一个模板，对象是这个模板将要具有的具体特征和行为。
[[./Source Code/29.png]]
- 修饰变量
  用static修饰的变量就叫做静态变量，也叫类变量
  静态变量是随着类（所有信息）的加载（方法区的静态常量池）而加载静态区，接着赋予初始值
  静态变量优先于对象存在，可以通过类名来调用，也可以通过对象调用，静态变量底层就是一个被所有对象共享的地址。
  静态变量---共享---属性是否适合共享？
  #+BEGIN_SRC java
  package cn.commandoptionesc.staticx;
  public class StaticDemo{
      public static void main(String[] args){
          //创建对象
          Person p=new Person();
          //赋值
          p.name="梅超风";
          p.age=30;
          p.gender='女';

          Person p1=new Person();
          p1.name="欧阳锋";
          p1.age=50;
          p1.gender='男';

          Person p2=new Person();
          p2.name="lili";
          p2.age=43;
          p2.gender='中';

          System.out.println(p2.toString());
          System.out.println(p1.toString());
          System.out.println(p.toString());
      }
  }
  //Personl类
  class Person{
      //属性
      String name;
      int age;
      //static修饰变量
      static char gender;


      //toString()方法
      public String toString(){
          return "name:"+name+",age:"+age+",gender:"+gender;
      }
  }
  #+END_SRC
- 修饰方法
  被static修饰的方法叫静态方法
  随着类的加载而加载到方法区的静态区，不会对静态方法进行赋予初始值，只是存放，当被调用的时候自动加载到栈中执行。与类
  同级，类方法，通过类名点调用也可以通过对象调用。
  #+BEGIN_SRC java
  System.arraycopy();
  Arrays.copyof();
  Arrays.toString();
  Arrays.sort();
  Systemm.out.println();
  #+END_SRC
  静态方法也是存储在方法区，只不过加载的时候没有运行，什么时候调用，什么时候去栈中运行。

  注意：
      静态变量不可以定义到静态方法中
      静态方法中，不可以直接调用非静态的方法。另外也不能存在this和super这样的关键字。静态是优先于对象存在的。
      - 方法或者构造方法中可以定义静态变量？
        不可以，方法要等到调用的时候，内容才执行，静态变量要与类同级。
      - 静态方法里可以使用this？
        不可以，静态方法是类级别的，this是对象级别的。
      - main静态方法，"直接"调用非静态的属性和方法？
        不可以，静态信息不能调用非静态的信息，非静态的可以调用静态的（出现非静态的说明，加载过程已经走完了）
        #+BEGIN_SRC java
        package cn.commandoptionesc.staticx;
        public class StaticDemo{
            public static void main(String[] args){
                //静态不能调用非静态方法
                //n();
                //静态可以调用非静态方法
                m();
            }
            public void n(){}
            public static void m(){ }
        }
        #+END_SRC
        [[./Source Code/StaticDemo1.java]]
      - 静态方法可以重载
      - 静态方法不可以重写
        但是父子类中可以存在方法签名一致的静态方法，这种方式叫做隐藏
        隐藏时需注意：父类方法和子类方法要么都是静态的，要么都是非静态的
        #+BEGIN_SRC java
        package cn.commandoptionesc.staticx;
        public class StaticDemo1{
            public static void main(String[] args){

            }
        }
        class AA{
            public void m(){}
            public static void n(){}
        }
        class B extends A{
            //注解---@Override:表示下面的方法是重写方法
            @Override
            public void m(){}
            //静态方法没有重写
            //静态方法与类同级
            //重写为多态服务---多样性---对象
            //@Override
            public static void n(){}
        }
        #+END_SRC
        [[./Source Code/StaticDemo2.java]]
- 修饰代码块
  在方法外类内static{}
  用static修饰的代码块
  它是随着类的加载而加载到方法区中，在类创建对象前去执行一次（被static修饰的内容都只加载一次）
  父类静态--->子类静态--->父类对象--->子类对象
  #+BEGIN_SRC java
  package cn.commandoptionesc.staticx;
  public class StaticDemo4{
      public static void main(String[] args){
          new SD();
      }
  }
  class SD1{
      static{
          System.out.println("静态代码块1");
      }
      {
          System.out.println("构造代码块1");
      }
  }
  class SD extends SD1{
      static int i;
      //静态代码块
      //随着类的加载而加载但是只加载一次，与类同级
      static{
          //静态变量
          i = 9;
          System.out.println("静态代码块");
      }
      {
          System.out.println("构造代码块");
      }
      public SD(){
          System.out.println("无参构造");
      }
  }
  #+END_SRC
  [[./Source Code/StaticDemo4.java]]

  #+BEGIN_SRC java
  package cn.commandoptionesc.staticx;
  public class StaticDemo5{
      public static void main(String[] args){
          new DB();
      }
  }
  class DA{
      static DC d=new DC();
      static{
          System.out.println("DA 1");
      }
      {
          System.out.println("DA 2");
      }

      public DA(){
          System.out.println("DA 3");
      }
  }
  class DB extends DA{
      static{
          System.out.println("DB 1");
      }
      {
          System.out.println("DB 2");
      }

      public DB(){
          System.out.println("DB 3");
      }
  }
  class DC{
      public DC(){
          System.out.println("DC");
      }
  }
  class DD extends DC{
      public DD(){
          System.out.println("DD");
      }
  }
  #+END_SRC
  [[./Source Code/StaticDemo5.java]]

  #+BEGIN_SRC java
  package cn.commandoptionesc.staticx;
  public class StaticDemo6{
      public static void main(String[] args){
          new DB();
      }
  }
  class DA{
      //static DC d;
      //属性与对象一个级别，但是属性和构造代码块执行顺序一致
      //谁在前面谁先执行
      DD dd = new DD();
      static{
          System.out.println("DA 1");
      }

      {
          System.out.println("DA 2");
      }

      public DA(){
          System.out.println("DA 3");
      }
  }
  class DB extends DA{
      static{
          System.out.println("DB 1");
      }

      {
          System.out.println("DB 2");
      }

      public DB(){
          System.out.println("DB 3");
      }
  }
  class DC{
      public DC(){
          System.out.println("DC");
      }
  }
  class DD extends DC{
      public DD(){
          System.out.println("DD");
      }
  }
  #+END_SRC
  [[./Source Code/StaticDemo6.java]]

  #+BEGIN_SRC java
  package cn.commandoptionesc.staticx;
  public class StaticDemo7{
      public static void main(String[] args){
          System.out.println(new SDText().i1);
          System.out.println(new SDText().i2);
          System.out.println(new SDText().i3);
      }
  }
  class SDText{
      // 定义了成员变量并且优质，执行构造代码块的内容，给成员变量进行赋值，最后的结果值就是6
      int i1 = 1;
      {
          i1 = 6;
      }

      int i2=1;
      {
          i2+=6;
      }

      //java开始进行编译和执行，读到a=1，发现没有具体的类型，从上下文开始找，发现没有，会把a看成（标记）成成员变量
      //此时这个标记就只能赋值，坐不了其他任何操作，往下找到了同名的定义，就会把标记的值给同名变量，同名变量自己赋值
      //就把前面的赋值过程覆盖了
      {
          i3 = 4;
      }
      int i3=2;

      /*{
          i4+=3;
      }

      int i4=1;
      */
  }
  #+END_SRC


** 封装
面向对象思想的三个特征：封装，继承，多态
*** 关键字private
1. 私有，属于成员修饰符，不能修饰局部变量
2. 被private修饰的成员，只能在自己的的本类中被使用
3. 对私有变量提供公共的访问方式：方法
4. 类中不需要对外提供的内容都需要私有化，包括属性和方法，并提供setXxx与getXxx方法对其进行访问
5. 私有仅仅是封装的体现形式
#+BEGIN_SRC java
/*
  描述显示生活中的人的事物
  属性：姓名 年龄
  功能：说话
,*/
public class Person2{
    //人的姓名，成员变量
    String name;
    //人的年龄，成员变量
    private int age;

    //变量age被私有，提供方法，让外面的类使用
    //定义方法，对age变量进行赋值，方法名字必须set开头
    public void setAge(int a){
        //对参数a进行范围的限制
        if(a<0||a>200){
            //如果a超过范围，手动将age赋值为20
            age=20;
        }else{
            //如果a没有超过范围，直接对age赋值
            age=a;
        }
    }
    //定义方法，对变量age获取值使用，方法名字get
    public int getAge(){
        return age;
    }

    public void speak(){
        System.out.println(name+"..."+age);
    }
}
#+END_SRC

#+BEGIN_SRC java
/*
  定义好的Person2类进行测试
  创建对象，对象调用属性和方法
,*/
public class PersonTest2{
    public static void main(String[] args){
        //创建Person类的对象 new
        Person2 p=new Person2();
        //对长远变量赋
        //p.age=20;
        //对成员变量age赋值,只能调用set方法赋值
        p.setAge(20);
        p.setname="张三";

        //调用类中的方法
        p.speak();

        //输出成员变量age值，必须调用get方法
        System.out.println(p.getAge());
    }
}
#+END_SRC

    #+BEGIN_SRC java
      /*
        类描述人：
            属性：姓名和年龄
            方法：说话

        私有化所有的属性（成员变量），必须写对应的get/set方法
        凡是自定义的类，自定义成员变量，应该私有化，提供get/set
       ,*/
      public class Person3{
          private String name;
          private int age;

          //set方法为变量name和age赋值
          public void setAge(int a){
              age=a;
          }
          public void setName(String b){
              name=b;
          }

          //get方法为变量name和age获取值
          public int getAge(){
              return age;
          }
          public String getName(){
              return name;
          }
          public void speak(){
              System.out.println("人在说话："+name+"..."+age);
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class PersonTest3{
          public static void main(String[] args){
              Person3 p=new Person3();
              //调用set方法，对成员变量赋值
              p.setAge(18);
              p.setName("旺财");
              p.speak();

              //调用get方法，获取成员变量的值
              System.out.println(p.getName());
              System.out.println(p.getAge());
          }
      }
    #+END_SRC
*** 关键字this
    本类的对象引用
    哪个对象调用的this就表示哪个对象
    区分成员变量和局部变量和局部变量的同名问题
    方法中访问成员变量就写this.

    *this案例_描述人：*
    #+BEGIN_SRC java
      /*
        类描述人：
            属性：姓名和年龄
            方法：说话

        私有化所有的属性（成员变量），必须写对应的get/set方法
        凡是自定义的类，自定义成员变量，应该私有化，提供get/set
       ,*/
      public class Person4{
          private String name;
          private int age;

          //set方法为变量name和age赋值
          public void setAge(int a){
              age=a;
          }
          public void setName(String b){
              name=b;
          }

          //get方法为变量name和age获取值
          public int getAge(){
              return age;
          }
          public String getName(){
              return name;
          }
          public void speak(){
              String name="二麻子";
              int age=10;
              System.out.println("人在说话："+this.name+"..."+this.age);
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class PersonTest4{
          public static void main(String[] args){
              Person3 p=new Person3();
              //调用set方法，对成员变量赋值
              p.setAge(18);
              p.setName("旺财");
              p.speak();
          }
      }
    #+END_SRC

    *this案例_年龄比较：*
    #+BEGIN_SRC java
      public class Person5{
          private int age;

          public void setAge(int age){
              this.age=age;
          }
          public int getAge(){
              return age;
          }

          /*
            定义一个方法：
                比较是否是同龄人，是返回true，不是就返回false
                谁和谁比呀？我自己和别人比
            方法的返回值:true false
            方法参数：别人
           ,*/
          public boolean compare(Person5 p){
              //自己和别人比年龄,自己是this和p比较
              return this.age==p.age;
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class PersonTest5{
          public static void main(String[] args){
              //测试Person类中的年龄比较功能
              //创建2个Person对象
              Person5 p1=new Person5();
              Person5 p2=new Person5();

              p1.setAge(14);
              p1.setAge(16);

              //p1对象调用自己的方法compare传递p2对象
              boolean b=p1.compare(p2);
              System.out.println(b);
          }
      }
    #+END_SRC

*** 随机点名器案例重构

    #+BEGIN_SRC java
      public class Student0{
          private String name;
          private int age;

          public void setName(String name){
              this.name=name;
          }
          public void setAge(int age){
              this.age=age;
          }
          public String getName(){
              return name;
          }
          public int getAge(){
              return age;
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      import java.util.Random();
      import java.util.ArrayList;
      public class CallName0{
          /*
            随机点名案例：
            1.创建集合，将Student对象存储到集合中
            2.总览所有学生的信息
                将存储到集合中的Student对象遍历出来
            3.随机学生
                随机数，作为索引，到集合中去查找元素
           ,*/
          public static void main(String[] args){
              //定义集合ArrayList，存储Student类型
              ArrayList<Student0> array=new ArrayList<Student0>();
              addStudent0(array);
              printStudent0(array);
              randomStudent0(array);
          }

          /*
            随机数生成学生信息
           ,*/
          public static void randomStudent0(ArrayList<Student0> array){
              Random r=new Random();
              int index=r.nextInt(array.size());
              Student0 s=array.get(index);
              System.out.println(s.getName());
          }

          /*
            定义方法，总览学生信息
            遍历集合
           ,*/
          public static void printStudent0(ArrayList<Student0> array){
              for(int i=0;i<array.size();i++){
                  Student0 s=array.get(i);
                  System.out.println(s.getName()+"..."+s.getAge());
              }
          }

          /*
            定义方法，存储Student对象，到集合中
           ,*/
          public static void addStudent0(ArrayList<Student0> array){
              Student0 s1=new Student0();
              s1.setName("lisi1");
              s1.setAge(16);

              Student0 s2=new Student0();
              s2.setName("lisi2");
              s2.setAge(18);

              Student0 s3=new Student0();
              s3.setName("lisi3");
              s3.setAge(10);

              Student0 s4=new Student0();
              s4.setName("lisi4");
              s4.setAge(18);

              array.add(s1);
              array.add(s2);
              array.add(s3);
              array.add(s4);
          }
      }
    #+END_SRC

** final
   final修饰变量，那么这个变量就叫做常量，常量的值一旦赋值就不能改变了
   final修饰的是成员属性，那么需要在对象创建完成之前赋予初始化的值。
   如果是静态常量，只要在类加载之前给静态变量赋值即可
   final修饰方法，表示这个方法是最终方法，不能被重写。可以
** 类、对象、封装的总结
*** 类与对象
    - 类，用于描述多个对象的共同特征，它是对象的模板
      + 类的定义：使用关键字class类定义java中的类
        + 格式：
          class 类名{

          //属性
          数据类型 变量名;

          ...

          //方法
          修饰符 返回值类型 方法名（参数）{  }

          }
    - 对象，用来描述显示中的个体，它是类的实例
       + 创建对象：
         + 格式：
           类名 对象名=new 类名（）;
*** 封装的体现：
    - 封装（private关键字）
      + 封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式
      + 封装的体现：
        + 变量：使用private修饰，这就是变量的封装
        + 方法：也是一种封装，封装了多条代码
      + private关键字，私有的意思
        + 它可以用来修饰类中的成员（成员变量，成员方法）
        + private的特点：
          private修饰的成员只能在当前类中访问，其他类中无法直接访问
    - this关键字(重载：方法名一样，参数列表不同，同一个类的事情)
      + this关键字，本类对象的引用
        + this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用
        + this什么时候存在？
          当创建对象的时候，this存在
        + this的作用：
          用来区别同名的成员变量与局部变量（this.成员变量）
          public void setName(String name){
              this.name=name;
          }
** 继承
   - 格式
     class 子类 extends父类{}
   - 好处和注意事项
     + 好处
       1. 提高了代码的复用性，提高软件开发的效率
       2. 让类与类之间产生了关系，提供了多态的前提
     + 注意
       1. 类只支持单继承，不允许多继承，就是说一个类只能有一个直接父类
       2. 多类可以继承一个父类
       3. 多层继承是可以的，即一个类的父类可以在去继承另外的父类，例如c类继承自b
          类，而b类又可以继承a类，这时c类也可称作a类的子类
       4. 子类和父类是一种相对的概念，B类是A类的子类，同时又是C类的父类

     #+BEGIN_SRC java
       /*
         定义员工类
             属性和方法
                 属性成员变量，姓名
                 成员方法，工作
        ,*/
       class Emloyee{
           String name;

           public void work(){
               System.out.println("员工在工作");
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         定义研发部员工
             属于员工中的一种
             研发员工继承员工类

             关键字 extends
             子类是Develop，父类是Employee
             子类自动拥有父类中可以继承的属性和方法
        ,*/
       public class Develop extends Employee{

       }
     #+END_SRC

     #+BEGIN_SRC java
       public class Test{
           public static void main(String[] args){
               //创建研发员工类的对象
               Develop d=new Develop();
               //子类的对象d 能否调用父类中的成员呢？
               d.name="张三";
               d.work();
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       public class WeiHu extends Employee{
           public void print(){
               System.out.println(name);
           }
       }
     #+END_SRC
*** 继承的体系
     + 事物抽取，都是每个具体事物的共性抽取，在java里子类的共性抽取形成了父类
     + 父类内容最共性,子类不但拥有共性，还拥有自己的特性
*** 关键字super
     1. 继承后，子类父类"成员变量"的特点
        当子父类中出现了"同名"成员变量时，在子类中访问调用父类中的成员变量，必须使用关键字super来完成
        子类继承父类（超类/基类） ;子类（派生类）
        子类的对象调用成员变量:子类自己有，使用自己的,子类没有，调用父类的
        + 格式
          super.父类中的成员变量;
          (this.调用自己本类成员)

          #+BEGIN_SRC java
            public class Fu{
                int i=1;
            }
          #+END_SRC

          #+BEGIN_SRC java
            public class Zi extends Fu{
                int i=2;
                public void show(){
                    int i=3;
                    System.out.println(i);
                    System.out.println(this.i);
                    System.out.println(super.i);
                }
            }
          #+END_SRC

          #+BEGIN_SRC java
            public class JiChengTest{
                public static void main(String[] args){
                    Zi z=new Zi();
                    System.out.println(z.i);
                    z.show();
                }
            }
          #+END_SRC
     2. 继承后，子类父类"成员方法"的特点
        子类的对象，调用方法的时候
        子类自己没有，调用的是父类的

        方法的重载：方法名一样，参数列表不同，同一个类的事情
        方法的重写 Override：子类中出现和父类一模一样的方法的时候，子类重写父类的方法，覆盖
        + 格式
          super.父类的成员方法();
        #+BEGIN_SRC java
          public class Phone{
              public void call(){
                  System.out.println("手机在打电话");
              }
              public void sendMessage(){
                  System.out.println("手机发短信");
              }
              public void showNum(){
                  System.out.println("手机号码来电显示");
              }
          }
        #+END_SRC

        #+BEGIN_SRC java
          public class PhoneTest{
              public static void main(String[] args){
                  Phone p=new Phone();
                  p.call();
                  p.sendMessage();
                  p.showNum();

                  AndPhone ap=new AndPhone();
                  ap.showNum();
              }
          }
        #+END_SRC

        #+BEGIN_SRC java
          public class AndPhone extends Phone{
              public void showNum(){
                  //父类中的方法showNum已经可以显示号码，子类 直接用
                  super.showNum();
                  System.out.println("显示大头像");
                  System.out.println("显示姓名");
              }
          }
        #+END_SRC
     3. 注意事项
        子类重写父类方法，必须要保证子类方法的权限大于等于父类权限
        java当中的四大权限：public protected default private

        #+BEGIN_SRC java
          public class Fu2{
              void show(){

              }
          }
        #+END_SRC

        #+BEGIN_SRC java
          public class Zi2 extends Fu2{
              public void show(){
              }
          }
        #+END_SRC

** 抽象类
*** 产生
    方法功能声明相同，但方法功能主体不同。
    那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。
    那么此方法就是一个抽象方法。
*** 关键字abstract（抽象）
**** 抽象方法定义的格式
     public abstract 返回值类型 方法名（参数）;
**** 抽象类定义的格式
      abstract class 类名{  }
**** 抽象类的使用方式
     定义类继承抽象类，将抽象类方法进行重写，创建子类的对象
     抽象类，不能实例化对象，不能new
     不能创建对象的原因：无法使用"对象.调用抽象方法",因为抽象方法没有主体，根本就不能运行
      #+BEGIN_SRC java
        /*
          定义类开发工程师类
              EE开发工程师：作用
              Android开发工程师：工作

              根据共性进行抽取，然后形成一个父类Developer
              定义方法，工作：怎么工作，具体干什么
         ,*/
        public class Developer{
            //定义方法工作方法，但是怎么工作，说不清楚，讲不明白
            //所以，没有主体的方法，必须使用关键字abstrace修饰
            //抽象的方法，必须存在于抽象的类中，类也必须用abstract修饰
            public abstract void work();
        }
      #+END_SRC
      #+BEGIN_SRC java
        /*
          定义类，JavaEE的开发人员
          继承抽象类Develop,重写抽象的方法
         ,*/
        public class JavaEE extends Developer{
            //重写父类的抽象方法
            //去掉abstract修饰符，加上方法主体
            public void work(){
                System.out.println("JavaEE的工程师在开发B/S软件");
            }
        }
      #+END_SRC
      #+BEGIN_SRC java
        /*
          测试抽象类
              创建他的子类的对象，使用子类的对象调用方法
         ,*/
        public class Android extend Developer{
            public void work(){
                System.out.println("Android工程师开发手机软件");
            }
        }
      #+END_SRC
      #+BEGIN_SRC java
        /*
          测试抽象类
              创建他的子类的对象，使用子类的对象调用方法
         ,*/
        public class DeveloperTest{
            public static void main(String[] args){
                JavaEE ee=new JavaEE();
                ee.work();

                Android and =new Android();
                and.work();
            }
        }
      #+END_SRC
**** 抽象类的特点
     1. 抽象类和抽象方法都需要被abstract修饰，抽象方法一定要定义在抽象类中
     2. 抽象类不可以直接创建对象，原因：调用抽象方法没有意思
     3. 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类
**** 抽象类的设计思想
     + 抽象类作用
       继承的体系，抽象类强制子类重写抽象的方法
**** 抽象类的细节
     + 抽象类一定是个父类？
       是的，因为不断抽取而来的
     + 抽象类中是否可以不定义抽象方法
       是可以的，那这个抽象类的存在到底有什么意义？
       是不让该类创建对象，方法可以直接让子类去使用
     + 抽象关键字abstract不可以和哪些关键字共存？
       1. private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，
          abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾
       2. final
       3. static
**** 抽象案例--员工类系列

     #+BEGIN_SRC java
       /*定义员工类
             内容，都是所有子类的共性抽取
                 属性：姓名，工号
                 方法：工作
        ,*/
       public class Employee1{
           //定义成员变量姓名
           private String name;
           //定义成员变量工号
           private String Id;

           //定义工作方法
           public abstract void work();

           public void setName(String name){
               this.name=name;
           }
           public void setId(String Id){
               this.Id=id;
           }
           public String getName(){
               return name;
           }
           public String getId(){
               return Id;
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         定义研发员工类
             属于员工中的一种，继承员工类
        ,*/
       public abstract class Developer1 extends Employee1{

       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         描述JavaEE开发工程师类
             工号，姓名，工作方法
         其他的员工，也具备这些共性，抽取代父类中，自己就不需要定义了
         是研发部员工的一种，继承研发部类
        ,*/
       public class JavaEE1 Developer1{
           //重写他父类的父亲的抽象方法
           public void work(){
               System.out.println("JavaEE的工程师在开发"+super.getName()+"..."+super.getId());
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         定义维护员工类，属于员工中的一种
         继承员工类
         抽象类Maintainer 给自己的员工定义自己有的属性
        ,*/
       public abstract class Maintainer1{

       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         描述的是网络维护工程师
         属于维护部的员工，继承维护部类
        ,*/
       public class Network extends Maintainer{
           public void work(){
               System.out.println("网络工程师在检查网络是否顺畅"+super.getName()+"..."+super.getId());
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         测试员工案例
             创建最下面的子类的对象
        ,*/
       public class YuanGongTest{
           public static void main(String[] args){
               JavaEE ee=new JavaEE();
               Network net=new Network();

               ee.setName("郑三");
               ee.setId("研发部01");

               net.setName("李四");
               net.setId("维护部02");

               ee.work();
               net.work();
           }
       }
     #+END_SRC
**** 总结
***** 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父亲，子类会自动拥有父类所有课继承的属性和方法
      - 继承的好处：
        + 提高了代码的可维护性
        + 提高了代码的复用性
        + 让类与类之间产生了继承关系
      - 机场的弊端：
        + 类与类之间的耦合度过高
      - 继承的特点：
        + java中的类只能够单继承，不能多继承，可以多层继承
        + 所有的类都直接或者间接的继承了Object类，Object类成为祖宗类
      - 继承的注意事项：
        + 使用关键字extends让类与类之间 产生继承关系
        + 父类私有的成员，子类不能继承，因为根本看不到
        + 不能为了继承某个功能而随意进行继承操作，必须符合is a的关系
          苹果 is a 水果
          男人 is a 人
          狗   is a 人，这种请款就不能继承了
      - 继承中的成员变量关系：
        + 不同名变量：
          子类直接继承使用
        + 同名变量：
          默认访问的是子类自己的成员变量，想访问父类中的同名变量，请使用"super.成员变量;"
      - 继承中的成员方法关系：
        + 不同名的方法：
          子类直接继承使用
        + 同名的方法
          默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用"super.成员方法();"
      - super:用来表示当前对象中包含的父类对象空间的引用
        + 调用父类的成员变量：
          super.成员变量;
        + 调用方法的成员方法;
          super.成员方法();
      - 方法重写（override）：指在父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写
        + 方法重写的注意事项：
          1. 子类的方法声明要与父类相同
          2. 子类要重写方法的方法，方法的权限修饰不能比父类的更低
          3. 父类私有的方法，子类不能够进行方法重写
      - 方法重载（overload）：指在同一个类中，多个方法名称相同，他们的参数列表不同（个数不同，数据类型不同）
***** 抽象
      - 抽象方法：
        方法只有声明部分，没有方法体
      - 抽象类：
        + 包含抽象方法的类，一定是抽象类
        + 使用abstract修饰的类，是抽象类
      - 抽象类的特点
        + 抽象类与抽象方法都必须使用abstract来修饰
        + 抽象类不能直接创建对象(new)
        + 抽象类中可以有抽象方法，也可以没有抽象方法
        + 抽象类的子类
          1. 实现了抽象方法的具体类
          2. 抽象类
      - 抽象类面试题：
        + 抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？
          可以没有抽象方法，有意义，不会让其他人直接创建该类对象
** 接口
*** 接口抽象方法定义
    #+BEGIN_SRC java
      /*
        定义接口
            使用关键字 interface 接口名字
        接口定义
            成员方法，全抽象
            不能定义带有方法体的方法

        定义抽象方法：固定格式

            public abstract 返回值类型 方法名字(参数列表);
            修饰符public  写与不写都是public

        接口中成员变量的定义
            成员变量的定义也有具体的要求

            要求：必须定义为常量
            固定格式：
                public static final 数据类型 变量名 = 值
       ,*/
      public interface MyInterface{
          //public static final int a = 1;
          //在接口中，定义抽象的方法
          public abstract void function();
      }
    #+END_SRC
*** 接口的实现类

    #+BEGIN_SRC java
      /*
        定义类，实现接口，重写接口中的抽象方法
        创建实现类的对象

        类实现接口，可以理解为继承(但是有区别)

        关键字 implements
        class 类 implements 接口{
            重写接口中的抽象方法
        }

                   类             实现        接口
        class MyInterfaceImpl implements MyInterface
       ,*/
      public class MyInterfaceImpl implements MyInterface{
          public void functon(){
              System.out.pritnln("实现类，重写接口抽象方法");
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class MyInterfaceTest{
          public static void main(String[] args){
              //创建接口的实现类的对象
              MyInterfaceImpl my = new MyInterfaceImpl();
              my.function();
          }
      }
    #+END_SRC
*** 接口中的成员变量的特点

    #+BEGIN_SRC java
      /*
        接口中成员的特点
            1. 成员变量的特点，没有变量，都是常量
            固定定义格式：public static final 数据类型 变量名 = 值
            public 权限
            static 可以被类名直接.调用
            final  最终，固定住变量的值

            注意：public static final 修饰符，在接口的定义中，可以省略不写
            但是，不写不等于没有

            三个修饰符还可以选择性书写

            2. 接口中的成员方法特点：
                public abstract  返回值类型 方法名(参数列表);
                修饰符 public abstract 可以不写，选择性属性

            3. 实现类，实现接口，重写接口全部抽象方法，创建实现类对象
                实现类，重写了一部分抽象方法，实现类还是一个抽象类
       ,*/
      public interface MyInter{
          //声明了一个静态的常量
          public static final int x = 3;

          public abstract void show();

          public abstract int getSum(int a,int b);
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class MyInterTest{
          public static void main(String[] args){
              //使用接口中定义的常量
              //常量被静态修饰，可以被类型直接调用，被接口的名字直接调用
              System.out.println(MyInter.x);
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class MyInterImpl implements MyInter{
          //重写接口中的接口方法，public权限是必须的
          public void show(){

          }
          public int getSum(int a,int b){
              return a+b;
          }
      }
    #+END_SRC
*** 类和接口的多实现与类在继承类的同时实现多接口
    接口多实现，没有安全隐患了吗？
    类的多继承，安全隐患问题
    多实现没有安全隐患，原因在于接口中的方法全是抽象，没有主体
    依赖实现类，重写才可以执行，接口多实现中，没有安全问题的
    解决了单继承局限性

    #+BEGIN_SRC java
      public interface A{
          public abstract void a();
      }
    #+END_SRC

    #+BEGIN_SRC java
      public interface B{
          public abstract void b();
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        1.
        类C，同时去实现2个接口，接口A，B
        作为实现类,C 全部重写两个接口的所有的抽象方法，才能建立C类的对象

        2.
        C类在继承一个类的同时，可以实现多个接口
       ,*/
      public class C extends D implements A,B{
          public void a(){
          }
          public void b(){
          }
          public void d(){
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public abstract class D{
          public abstract void d();
      }
    #+END_SRC
*** 接口的多继承

    #+BEGIN_SRC java
      public interface A1{
          public abstract void a();
      }
    #+END_SRC

    #+BEGIN_SRC java
      public interface B1{
          public abstract b();
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        接口与接口之间，是继承关系
        Java支持接口 之间的多继承，一个接口可以同时继承多个接口
       ,*/
      public interface C1 extends A1,B1{
          public abstract void c();
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        实现接口C，重写C接口的全部抽象方法
        而且接口C，继承A，B
        D实现类，重写A,B,C三接口全部抽象方法

        问：Java中有多继承吗？
            类没有多继承
            接口之间多继承
       ,*/
      public class D1 implements C1{
          public void a(){}
          pulibc void b(){}
          public void c(){}
      }

    #+END_SRC
*** 接口思想
    电脑主板的生产厂商
    主板上，安装了三个USB接口
    问：买电脑的人，在USB上接什么设备？
    存储设备，移动硬盘，U盘，键盘，鼠标，电扇，手机......

    主板厂商、外接设备厂商在一起明确USB接口的规范

        interface USB{
            抽象方法();
        }
        移动硬盘 implements USB{
            方法重写
        }

** 多态

**** 多态转型的案例

     #+BEGIN_SRC java
     public abstract class Animalaa{
           public abstract void eat();
       }
     #+END_SRC

     #+BEGIN_SRC java
       public class Cataa extends Animalaa{
           public void eat(){
               System.out.println("猫吃猫粮");
           }
           public void catchMouse(){
               System.out.println("买抓老鼠");
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       public Dogaa extends Animalaa{
           public void eat(){
               System.out.println("狗吃狗粮");
           }

           public void lookHome(){
               System.out.println("狗看家");
           }
       }
     #+END_SRC

     #+BEGIN_SRC java
       /*
         测试类：
             1. 实现动物和cat，dog多态调用
             2. 做类型的强制类型转化，调用子类的特有功能
        ,*/
       public class AnimalaaTest{
           //两个子类，使用两次多态调用
           Animalaa a1 = new Cataa();
           Animalaa a2 = new Dogaa();
           //a1，a2调用子类父类共有方法，运行子类的重写
           a1.eat();
           a2.eat();

           //类型向下转换，强制转换，调用子类的特有功能
           //防止发生异常：a1属于Cataa对象，转成Cataa类，a2属于Dogaa对象，转成Dogaa
           //instanceof判断
           if(a2 instanceof Cataa){
               Cataa c = (Cataa)a2;
               c.catchMouse();
           }
           if(a2 instanceof Dogaa){
               Dogaa d = (Dogaa)a2;
               d.lookHome();
           }
       }
     #+END_SRC
** 案例---笔记本电脑

   #+BEGIN_SRC java
     /*
       自定义的USB接口类
       规范，就是抽象方法
       开，关
      ,*/
     public interface USB{
         public abstract void open();
         public abstract void close();
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       定义笔记本类
       功能：开机，关机，使用USB设备
      ,*/
     public class Computeraa{
         public void openComputeraa(){
             System.out.println("笔记本开机");
         }
         public void closeComputeraa(){
             System.out.println("笔记本关机");
         }

         //使用USB设备方法，哪个设备
         //方法的参数，就是USB设备
         public void useUSB(USB usb){
             usb.open();
             usb.close();
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       自定义的鼠标类
       满足USB接口规范
       实现USB接口，重写抽象方法
      ,*/
     public class Mouseaa implements USB{
         public void open(){
             System.out.println("开启鼠标");
         }
         public void close(){
             System.out.println("关闭鼠标");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class USBTest{
         public static void main(String[] args){
             //创建笔记本对象，调用笔记本的功能
             Computeraa com = new Computeraa();
             com.openComputeraa();

             //调用笔记本使用USB设备的方法
             //参数是USB接口类型，接口不能建立对象
             //调用方法，传递USB接口的实现类的对象
             // Mouse m = new Mouse();
             com.useUSB(new Mouse());
             //使用USB设备，使用键盘
             com.useUSB(new Keyboard());

             com.closeComputeraa();
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class Keyboardaa implements USB{
         public void open(){
             System.out.println("开启键盘");
         }
         public void close(){
             System.out.println("关闭键盘");
         }
     }
   #+END_SRC
** 接口多态总结
*** 接口
**** 理解
     是一个特殊的抽象类，但它不是类，是一个接口
**** 接口特点
     1. 定义一个接口用 interface关键字
        interface Inter{}
     2. 一个类实现一个接口，实现implements关键字
        class Demo implements Inter{}
     3. 接口不能直接创建对象（接口不能new对象）
        通过多态的方式，由子类来创建对象，接口多态
**** 接口中成员的特点
     成员变量：
         只能是final 修饰的常量
         默认修饰符：public static final
     构造方法：
     成员方法：
         只能是抽象方法
         默认修饰符：public abstract final
**** 类与类，类与接口，接口与接口之间的关系
     类与类：继承关系，单继承，可以多层继承
     类与接口：实现关系，单实现，可以多继承
     接口与接口：继承关系，单继承，多继承
     Java中的类可以继承一个父类的同时，实现多个接口
*** 多态
**** 多态使用的前提
     1. 有继承或者实现关系
     2. 要方法重写
     3. 父类引用指向子类对象
**** 多态的成员访问特点
     方法的运行看右边(子类)，其他都看左边
**** 多态的好处
     提高了程序的扩展性
**** 多态的弊端
     不能访问子类的特有功能
**** 多态的分类
     - 类的多态
       abstract class Fu{
           public abstract void method();
       }
       class Zi extends Fu{
           public void method(){
               System.out.println("重写父类抽象方法");
           }
       }
           //类的多态使用
           Fu fu = new Zi();
      - 接口的多态
        interface Fu{
            public abstract void method();
        }
        class Zi implements Fu{
            public void method(){
                System.out.println("重写接口抽象方法");
            }
        }
            //接口的多态使用
            Fu fu = new Zi();
**** instanceof关键字
     格式：
         对象名 instanceof 类型
     返回值：true，false
     作用：判断指定的对象是否为给定类创建的对象
** 构造方法
*** 构造方法的重载

    #+BEGIN_SRC java
      public class Personaaa{
          private String name;
          private int age;

          //写空参数构造方法
          public Personaaa(){

          }

          //写带有两个参数的构造方法
          public Personaaa(String name,int age){
              this.name = name;
              this.age = age;
          }

          public String  getName(){
              return name;
          }
          public String setName(String name){
              this.name = name;
          }
          public int getAge(){
              return age;
          }
          public void setAge(int age){
              this.age = age;
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class PersonaaaTest{
          public static void main(String[] args){
              //创建Personaaa类的对象
              //解释在调用他的构造方法

              //1. 调用空参数构造方法，创建对象
              Personaaa p1 = new Personaaa();
              p1.setAge(18);
              p1.setName("旺财");
              System.out.println(p1.getName());
              System.out.println(p1.getAge());

              //2， 调用有2个参数的构造方法，创建对象
              Personaaa p2 = new Personaaa("小强",17);
              System.out.println(p2.getName());
              System.out.println(p2.getAge());
          }
      }
    #+END_SRC
*** this在构造方法之间调用

    #+BEGIN_SRC java
      /*
        this可以在构造方法之间进行调用
        this.的方式，区分局部变量和成员变量同名情况
        this在构造方法之间的调用，语法this()
       ,*/
      public class Personaaaa{
          private String name;
          private int age;

          public Personaaaa(){
              //调用了有参数的构造方法
              //参数李四，49传递给了变量name，age
              this("李四",49);
          }
          /*
            构造方法，传递String，int
            在创建对象的同时为成员变量赋值
           ,*/
          public Personaaaa(String name,int age){
              this.name = name;
              this.age = age;
          }

          public String getName(){
              return name;
          }
          public void setName(String name){
              this.name = name;
          }
          public int getAge(){
              return age;
          }
          public void setAge(int age){
              this.age = age;
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class PersonaaaaTest{
          public static void main(String[] args){
              //创建Personaaaa的对象，调用的是空参数的构造方法
              //运行的结果null 0
              Personaaaa p = new Personaaaa();

              System.out.println(p.getName());
              System.out.println(p.getAge());
          }
      }
    #+END_SRC
*** super关键字（子父类中构造方法的调用）

    #+BEGIN_SRC java
      public class Personaaaaa{
          int a= 1;
          public Personaaaaa(){
              System.out.println("父类构造方法");
              a = 5;
              }
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        子类中，super（）的方式，调用父类的构造方法
        super（）调用的是父类的空参数构造
        super（参数）调用的是父类的有参数构造方法

        子类的构造方法，有一个默认添加的构造方法
        注意：
            子类构造方法的第一行没有一个隐式代码super()
                public Studentaaaaa(){
                    super();
                }
                子类构造方法第一行super语句，调用父类的构造方法
       ,*/
      public class Studentaaaaa extends Personaaaaa{
          public Studentaaaaa(){
              //默认就是存在的，不写也是存在的
              super();
          }
      }
    #+END_SRC

    #+BEGIN_SRC java

      public class PersonaaaaaTest{
          public static void main(String[] args){
              new Studentaaaaa();
              System.out.println(s.a);
          }
      }
    #+END_SRC


    #+BEGIN_SRC java
      /*
        手动写一个父类Personaaaaaa类的构造方法
        保存，子类报错
       ,*/
      public class Personaaaaaa{
          public Personaaaaaa(int a){

          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        子类构造方法的报错原因：
            找不到父类的空参数构造器
            子类中，没有手写构造，编译器添加默认的空参数
            public Student(){
                super();
            }
        编译成功，必须手动构建方法，请你在super中加入参数
        注意：
            - 子类中所有的构造方法，无论重载多少个，第一行必须是super()
            - 如果父类有多个构造方法，子类只要任意调用一个就可以
       ,*/
      public class Studentaaaaaa extends Personaaaaaa{
          public Studentaaaaaa(){
              super(3);
          }
      }
    #+END_SRC



    #+BEGIN_SRC java
      public class Personaaaaaaa{
          public Personaaaaaaa (int a){
              `
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        构造方法第一行，写this()还是super（）
        不能同时存在，人选其一，保证子类的构造方法调用到父类的构造方法即可

        小结论：无论如何，子类的所有构造方法，直接，简介必须调用到父类构造方法
        子类的构造方法，如果什么都不写，默认的构造方法第一行super（）;
       ,*/
      public class Studentaaaaaaa extends Personaaaaaa{
          public Studentaaaaaaa(){
              //调用的是自己的构造方法
              //间接形式调用到了父类的构造方法
              this("avx");
          }
          public Studentaaaaaaa(String s){
              super(2);
          }
      }
    #+END_SRC
*** super应用

    #+BEGIN_SRC java
      public class Studentaaaaaaaa extends Personaaaaaaaa{
          public Student(String name,int age){
              super(name,age);
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        同时需要在创建工人对象就必须明确姓名和年龄
        new Workeraaaaaaaa 同时给出姓名和年龄
        new Worker("ABC",20);
       ,*/
      public class Workeraaaaaaaa extends Personaaaaaaaa{
          public Workeraaaaaaaa(String name,int age){
              super(name,age);
          }

      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        Studentaaaaaaaa类和Workaaaaaaaa有相同的成员变量，name，age
        继承的思想，共性抽取，形成父类
        Personaaaaaaaa，抽取出来的父类
        成员变量，私有修饰
        同时需要在创建学生和工人对象就必须明确姓名和年龄
        new Studentaaaaaaaa new Workaaaaaaaa 姓名，年龄明确了
       ,*/
      public class Personaaaaaaaa{
          private int age;
          private String name;

          public Personaaaaaaaa(String name,int age){
              this.name = name;
              this.age = age;
          }

          public void setName(String name){
              this.name = name;
          }
          public String getName(){
              return name;
          }
          public void setAge(int age){
              this.age = age;
          }
          public int getAge(){
              return age;
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
y      public class PersonaaaaaaaaTest{
          public static void main(String[] args){
              //创建工人对象，worker,指定姓名年龄
              Workeraaaaaaaa w = new Workeraaaaaaaa("光头强",30);
              System.out.println(w.getName());
              System.out.println(w.getAge());

              //创建学生对象，Student，指定姓名年龄
              Studentaaaaaaaa s = new Studentaaaaaaaa("肥波",5);
              System.out.println(s.getName());
              System.out.println(s.getAge());
          }
      }
    #+END_SRC
** 综合案例-完整的员工

   #+BEGIN_SRC java
     /*
       员工类：
           共性的抽取
           姓名，编号，工作方法(抽象)
      ,*/
     public abstract class Employeeaaaaaaaaa{
         private String name;
         private String id;

         public Employeeaaaaaaaaa(String name,String id){
             this.name = name;
             this.id = id;
         }
         public abstract void work();

         public void setName(String name){
             this.name = name;
         }
         public String getName(){
             return name;
         }

         public void setiId(String id){
             this.id = id;
         }
         public String getId(){
             return id;
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*

      ,*/
     public abstract class Developeraaaaaaaa extends Employeeaaaaaaaa{
         public Developeraaaaaaaa(String name,String id){
             super(name,id);
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public abstract class Manitainer extends Employeeaaaaaaaa{
         public Maintainer(String name,String id){
             super(name,id);
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class JavaEE extends Developeraaaaaaaa{
         public JavaEE(String name,String id){
             super(name,id);
         }
         public void work(){
             System.out.println(super.getName()+"..."+super.getId()+"...开发淘宝");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       网络工程师，维护部的
       历程维护部类
      ,*/
     public class Net extends Maintainer{
         public Net(String name,String id){
             super(name,id);
         }
         public void work(){
             System.out.println(super.getName()+"..."+super.getId()+"...维护网络");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       测试员工类
     ,*/
     public void EmployeeaaaaaaaaTest{
         public static void main(String[] args){
             //创建EE对象，调用方法
             JavaEE ee = new JavaEE("张三","开发部001");
             ee.work();

             //创建Net对象，调用方法
             Net net = new Net("李四","维护部001");
             net.work();
         }
     }
   #+END_SRC
** 总结
*** this关键字
    - this关键字，本类对象的引用
      + this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用
      + this什么时候存在的？
        当创建对象的时候
      + this的作用
        区别同名的成员变量与局部变量（this.成员变量）
*** 构造方法
    用来给类的成员进行初始化操作
    - 格式：
          修饰符 类名（参数列表）{...}
    - 特点
      1. 方法名与类名相同
      2. 没有返回值，也没有返回值类型，连void也没有
    - 构造方法什么时候会被调用?
      只有在创建对象的时候才可以被调用
*** super
    指的是父类的存储空间（理解为父类的引用）
    - 调用父类的成员变量：
      super.成员变量
    - 调用父类的构造方法：
      super(参数)
    - 调用父类的成员方法：
      super.成员方法（）;
*** 继承中的构造方法的注意事项：
    1. 如果我们手动给出了构造方法，编译器不会再给我们提供默认的空参数构造方法
       如果我们没写任何的构造方法，编译器提供给我们一个空参数构造方法
    2. 在构造方法中，默认的第一条语句为super()；
       它是用来访问父类中的空参数构造方法，进行父类成员的初始化操作
    3. 当父类中没有空参数构造方法的时候，怎么办？
       a. 通过super(参数)访问父类有参数的构造方法
       b. 通过this(参数)访问本类中其他构造方法
       注意：
           本类中的其他构造方法已经能够正常访问父类构造方法
    4. super(参数)与this(参数)不能同时在构造方法中存在
** final关键字

   #+BEGIN_SRC java
     /*
       在类定义上，加上修饰符，final
       类：最终类，不能有子类，不可以被继承
       但是使用方式，没有变化，创建对象，调用方法
      ,*/
     public final class Fu{
         public void show(){
             System.out.println("最终类的方法");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class FinaTest{
         public static void main(String[] args){
             Fu f = new Fu();
             f.show();
         }
     }
   #+END_SRC
*** final修饰方法


   #+BEGIN_SRC java
     /*
       定义父类
       一部分方法，写成final修饰
       子类可以继承的，但是不能做重写
      ,*/
     public class Fub{
         public final void show(){
             System.out.println("fu类的最终方法");
         }

         public void function(){
             System.out.println("fu类的一般方法");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class FubTest{
         public static void main(String[] args){
             Zib z = new Zib();
             z.function();
             z.show();

             //被final修饰，一次赋值，终身不变
             final int i = 10;
             System.out.println(i);

             //final修饰引用变量问题
             //变量，保存内存地址，终身不变
             final Zib z2 = new Zib();
             z2.function();
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class Zib extends Fub{
         //父类的方法是final修饰，不可以被重写
         public void function(){
             System.out.println("Zib类的一般方法");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java

     /*
       final修饰成员变量
       成员变量，在堆内存，具有默认值
       final修饰的成员变量，固定的不是内存的默认值
       固定的是，成员变量的手动赋值，绝对不是内存的默认

       成员变量的赋值，两种实现方式，一种是定义的时候，直接 = 赋值
       另一种赋值方式，采用构造方法赋值
       保证：
           被final修饰的成员变量，只能被赋值一次

       成员变量，需要在创建对象前赋值，否则报错
       构造方法，是创建对象中的事情，可以为成员变量赋值
       setXXX方法，创建对象之后的时候，不能为final修饰的成员赋值
     ,*/
     public class Personb{
         final int age;

         public Personb(int age){
             this.age = age;
         }
        /* public void setAge(int age){
             this.age = age;
         }
        */
     }
   #+END_SRC
** static关键字

   #+BEGIN_SRC java
     /*
       定义Person类，
       定义对象的特有数据，和对象的共享数据
       对象的特有数据（非静态修饰） 调用者只能是new对象
       对象的共享数据（静态数据） 调用者可以是new对象，可以是类名

       被静态修饰的成员，可以被类名字直接调用
      ,*/
     public class Personc{
         String name;

         static String className;
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class PersoncTest{
         public static void main(String[] args){
             Personc p1 = new Personc();
             Personc p2 = new Personc();

             p1.name = "哈哈";
             p2.name = "嘻嘻";

             System.out.println(p1.name);
             System.out.println(p2.name);

             //对象调用类的静态成员变量
             p1.className = "阿萨德";
             System.out.println(p2.className);
         }
     }
   #+END_SRC
*** 注意事项

    #+BEGIN_SRC java
      /*
        静态的注意事项
        在静态中不能调用非静态

        为什么呢？为什么静态不能调用非静态，生命周期
        静态优先于非静态存在于内存中

        静态 前人
        非静态 后人

        静态不能写this，不能写super

        问题：static修饰到底什么时候使用，应用场景？
            static 修饰成员变量，成员方法
            成员变量加static，根据具体的事物，具体分析问题
            定义事物的时候，多个事物之间是否有共性的数据
            请你将共性的数据定义为静态的成员变量

        成员方法加static，跟着变量走
            如果方法，没有调用过非静态成员，将方法定义为静态
       ,*/
      public class Studentb{
          private String name;
          private int age;
          public static void function(){
              System.out.println(name+age);
          }

          public void show(){
              System.out.println(name + age);
          }
      }
    #+END_SRC
*** 对象中的静态调用
    多态调用中，编译看谁，运行看谁
    编译都看等号 = 左边的父类，父类编译成功，父类没有编译失败
    运行，静态方法，运行父类中的静态方法
    运行，非静态方法，运行子类的重写方法
    成员变量，编译运行全看父类

** 内部类

   #+BEGIN_SRC java
     /*
       内部类的定义
           将内部类，定义在了外部的成员位置
       类名Outer，内部类名Inner

       成员内部类，可以使用成员修饰符,public  static ....
       也是个了，可以继承，可以实现接口

       调用规则：内部类，可以使用外部类成员，包括私有
       外部类要使用内部类的成员，必须建立内部类对象
      ,*/
     public class Outer{
         //外部类成员位置，定义在内部类
         class Inner{
             public void inner(){
                 System.out.println(a);
             }
         }
     }
   #+END_SRC
   #+BEGIN_SRC java
     public class OuterTest{
         public static void main(String[] args){
             /*
               滴啊用外部类中的内部类方法inner（）
               依靠外部类对象，找到内部类，通过内部类对象，调用内部类的方法
               格式：
                   外部类名.内部类 变量 = new 外部类对象().new 内部类对象（）;
                   变量.内部类方法();
              ,*/
             Outer.Inner in = new Outer().new Inner();
             in.inner();
         }
     }
   #+END_SRC
*** 成员内部类的同名变量调用

    #+BEGIN_SRC java
      public class Outer1{
          int i = 1;
          class Inner1{
              int i =2;
              public void inner(){
                  int i = 3;
                  //打印内部类i
                  System.out.println(this.i);
                  //打印外部类i
                  System.out.println(Outer1.this.i);
              }
          }
      }
    #+END_SRC
    #+BEGIN_SRC java
      public class Outer1Test{
          public static void main(String[] args){
              Outer1.Inner1 in = new Outer1().new Inner1();
              in.inner();
          }
      }
    #+END_SRC
*** 局部内部类

    #+BEGIN_SRC java
      /*
        局部内部类
            将一个类，定义在方法中
       ,*/
      public class Outer2{
          public void out(){
              class Inner2{
                  public void inner(){
                      System.out.println("局部内部类方法");
                  }
              }
              Inner2 in = new Inner();
              in.inner();
          }
      }
    #+END_SRC

    #+BEGIN_SRC java
      public class Outer2Test{
          public static void main(String[] args){
              //调用局部内部类的方法inner
              new Outer2().out();
          }
      }
    #+END_SRC
*** 内部类的实际使用---匿名内部类

    #+BEGIN_SRC java
      public interface Smoking{
          public abstract void smoking();

      }
      /*
        实现类，实现接口 重写接口抽象方法，创建实现类对象
        class XXX implements Smoking{
            public void smoking(){
            }
        }
        XXX x = new XXX();
        x.smoking();
        Smoking s = new XXX();
        s.smoking();

        匿名内部类，简化问题：定义实现类，重写方法，建立实现类对象，合为一步完成
       ,*/
    #+END_SRC

    #+BEGIN_SRC java
      public class SmokingTest{
          public static void main(String[] args){
              //使用匿名内部类
              /*
                定义实现类，重写方法，创建实现类对象，一步搞定
                格式：
                    new 接口或者父类(){
                    重写抽象方法
                    };
                    从new开始到分号结束
                    创建了接口的实现类的对象
               ,*/
              new Smoking(){
                  public void smoking(){
                      System.out.println("人在吸烟");
                  }
              }.smoking();
          }
      }
    #+END_SRC


    #+BEGIN_SRC java
      public abstract class Animala{
          public abstract void eat();
          public abstract void sleep();
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
                 new Animala(){
                  public void eat(){
                      System.out.println("在吃饭");
                  }
                  public void sleep(){
                      System.out.println("在睡觉");
                  }
              };
          以上代码，就是Animal的子类的对象
          多态性，父类引用 = 子类的对象
       ,*/
      public class AnimalaTest{
          public static void main(String[] args){
              Animala a = new Animala(){
                  public void eat(){
                      System.out.println("在吃饭");
                  }
                  public void sleep(){
                      System.out.println("在睡觉");
                  }
                  };
              a.eat();
              a.sleep();
          }
      }
    #+END_SRC
** 访问修饰符

   #+BEGIN_SRC java
     /*
       静态代码块，只执行一次
       构造代码块，new一次，就执行一次，优先于构造方法
       构造方法，new一次，就执行一次
      ,*/
     public  class Personb{
         private String name;
         private int age;

         public Person(String name,int age){
             this.age = age;
             this.name = name;
             System.out.println("我是构造方法");
         }

         //构造代码块
         {
             System.out.println("我是构造代码块");
         }

         //静态代码块
         static{
             System.out.println("我是静态代码块");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     public class PersondTest{
         public static void main(String[] args){
             new Persond("张三",29);
             new Persond("张三2",20);
         }
     }
   #+END_SRC
** 文档注释

   #+BEGIN_SRC java
     /*
       这个类的方法，实现两个整数的求和，获取求和的结果
       这个类的方法，是提供给别人使用的
       写一份使用说明书，文档注释
      ,*/
     /**
      *
      *类GetSum是实现整数求和
      *@author Apple
      *@version 1.0
      */
     public class GetSum{
         /**
          *方法getSum功能计算两个整数的求和
          *调用此方法传递两个int整数，返回求和值
          *@param a
          *@param b
          *@return sum
          */
         public static int getSum(int a,int b){
             return a+b;

         }
     }

   #+END_SRC

   #+BEGIN_SRC java
     /**
      *
      *GetAvg类实现求取平均数功能
      *@author Apple
      *@version 1.6
      */
     public class GetAvg{
         /**
          *
          *@param a
          *@param b
          *@return avg
          *实现获取两个浮点数的平均值
          *调用方法，传递两个浮点数，返回平均值
          */
         public static double getAvg(double a,double b){
             return (a + b)/2;
         }
     }
   #+END_SRC
** 类作为方法的的参数

   #+BEGIN_SRC java
     public class Person{
         private String name = "张三";

         public void eat(){
             System.out.println(name + "。。。在吃饭");
         }
         public void run(){

         }
     }
   #+END_SRC


   #+BEGIN_SRC java
     public class TestArguments{
         public static void main(String[] args){
             //调用方法opeartorPerson,传递Person类型对象
             Person p = new Person();
             operatorPerson(p);

             operatorPerson(new Person());
         }
         /*
          ,* 方法operatorPerson，参数类型是Person类型
          ,*调用方法operatorPerson，必须传递Person类型的对象
          ,*/
         public static void opreatorPerson(Person p){
             //可以使用引用数据类型p调用Person类的功能
             p.eat();
             p.run();
         }
     }
   #+END_SRC
** 类作为方法的返回值

   #+BEGIN_SRC java
     public class GetPerson{
         /*
          ,*
          ,*方法返回值是Person类型
          ,*方法的return语句后面一定是Person类型的对象
          ,*/
         public Person get(){
             Person p = new Person();
             return p;
         }
     }
   #+END_SRC
