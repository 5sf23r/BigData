* 目录                                                                          :TOC_10:QUOTE:
#+BEGIN_QUOTE
- [[#框架][框架]]
  - [[#基本概念][基本概念]]
  - [[#常用框架][常用框架]]
    - [[#ssh老三大框架][SSH(老三大框架)]]
      - [[#struts2][Struts2]]
      - [[#spring][Spring]]
      - [[#hibernate][Hibernate]]
    - [[#ssm][SSM]]
      - [[#springmvc][SpringMVC]]
      - [[#spring-1][Spring]]
        - [[#概述][概述]]
        - [[#spring-ioc][Spring IOC]]
          - [[#iocdi---控制反转依赖注入][IOC(DI) - 控制反转(依赖注入)]]
          - [[#ioc入门案例][IOC入门案例]]
          - [[#ioc的实现原理][IOC的实现原理]]
          - [[#ioc获取对象的方式][IOC获取对象的方式]]
          - [[#别名标签][别名标签]]
          - [[#spring创建对象的方式][Spring创建对象的方式]]
          - [[#单例和多例][单例和多例]]
          - [[#懒加载机制][懒加载机制]]
          - [[#配置初始化和销毁的方法][配置初始化和销毁的方法]]
          - [[#spring中关键方法的执行顺序][Spring中关键方法的执行顺序]]
        - [[#spring-di][Spring DI]]
          - [[#iocdi---控制翻转依赖注入][IOC(DI) - 控制翻转（依赖注入）]]
          - [[#set方法注入][set方法注入]]
          - [[#自动装配][自动装配]]
          - [[#基于构造方法的注入][基于构造方法的注入]]
      - [[#mybatis][MyBatis]]
#+END_QUOTE
* 框架
** 基本概念
所谓的框架其实就是程序的架子，在这个程序的架子中，搭建起程序的基本的骨架，针对程序的通用问题给出了便捷的解决方案，可以使开发人员基于框架快速开发具体的应用程序。框架和具体业务无关，可以套用在不同项目中。
** 常用框架
*** SSH(老三大框架)
**** Struts2
**** Spring
**** Hibernate
*** SSM
**** SpringMVC
**** Spring
[[./Img/Spring.png]]
***** 概述
Spring是一个Service层的框架，可以整合许多其它框架进行工作。Spring的主要技术是IOC(DI)、AOP
1. IOC(DI) - 控制反转(依赖注入)
2. AOP - 面向切面编程
***** Spring IOC
****** IOC(DI) - 控制反转(依赖注入)
*所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程交由Spring框架来处理，从此在开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要时由Spring框架提供，这个由spring框架管理对象创建和生命周期的机制称之为控制反转。* 而在创建对象的过程中Spring可以依据配置对对象的属性进行设置，这个过称之为依赖注入,也即DI。

/IOC+接口可以实现软件分层时的彻底解耦，最终实现"高内聚，低耦合/"中的低耦合
****** IOC入门案例
1. 创建一个java项目
   spring并不是非要在javaweb环境下才可以使用，一个普通的java程序中也可以使用Spring。
2. 导入Spring的lib目录下IOC相关的jar包
   [[./Img/1.png]]
3. 创建Spring的配置文件
   Spring采用xml文件作为配置文件，xml文件名字任意，但通常都取名为applicationContext.xml，通常将该文件放置在类加载的目录里下(src目录)，方便后续使用。

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

     </beans>
   #+END_SRC

4. 创建bean类，并在Spring中进行配置交由Spring来管理

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
         <bean id="person" class="cn.tedu.domain.Person"></bean>
     </beans>
   #+END_SRC

5. 在程序中通过Spring容器获取对象并使用

   #+BEGIN_SRC java
     /**
      ,* SpringIOC方式创建并管理bean
      ,*/
     @Test
     public void test02(){
         //1.初始化Spring容器
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         //2.通过Spring容器获取bean
         Person p = (Person) context.getBean("person");
         p.eat();
         p.say();
         //3.关闭Spring容器
         ((ClassPathXmlApplicationContext)context).close();
     }
   #+END_SRC

****** IOC的实现原理
在初始化一个Spring容器时，Spring会去解析指定的xml文件，当解析到其中的<bean>标签时，会根据该标签中的class属性指定的类的全路径名，通过反射创建该类的对象，并将该对象存入内置的Map中管理。其中键就是该标签的id值，值就是该对象。之后，当通过getBean方法来从容器中获取对象时，其实就是根据传入的条件在内置的Map中寻找是否有匹配的键值，如果有则将该键值对中保存的对象返回，如果没有匹配到则抛出异常。
- 由此可以推测而知：

  #+BEGIN_SRC
    默认情况下，多次获取同一个id的bean，得到的将是同一个对象。
    不可以配置多个id相同的bean
    可以配置多个id不同但class相同的bean
  #+END_SRC

  #+BEGIN_SRC java
    /**
     ,* 默认情况下多次获取同一个id的bean得到的是同一个对象
     ,* 不可以配置id相同的bean
     ,* 可以配置多个id不同但class相同的bean
     ,*/
    @Test
    public void test03(){
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        Person p1 = (Person) context.getBean("person");
        Person p2 = (Person) context.getBean("person");
        System.out.println(p1);
        System.out.println(p2);
        ((ClassPathXmlApplicationContext)context).close();
    }
  #+END_SRC

****** IOC获取对象的方式
通过context.getBeans()方法获取bean时，可以通过如下两种方式获取:
1. 传入id值
2. 传入class类型
通过class方式获取bean时，如果同一个类配置过多个bean，则在获取时因为无法确定到底要获取哪个bean会抛出异常。而id是唯一的，不存在这样的问题，所以建议大家尽量使用id获取bean。

#+BEGIN_SRC java
  /**
   ,* 获取对象的方式
   ,*  通过id获取bean
   ,*      如果找不到，抛异常NoSuchBeanDefinitionException
   ,*      如果找到唯一的，返回对象
   ,*      因为id不重复，不可能找到多个
   ,*  通过class获取bean
   ,*      如果找不到,抛出异常NoSuchBeanDefinitionException
   ,*      如果找到唯一，返回对象
   ,*      如果找到多个，抛出异常NoUniqueBeanDefinitionException
   ,*/
  @Test
  public void  test04(){
      ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

      //获取对象方式1：通过id获取
      //Person p = (Person)context.getBean("person");
      //p.eat();
      //p.say();
      //获取对象方式2：通过class获取
      Person p = context.getBean(Person.class);
      p.eat();
      p.say();

      ((ClassPathXmlApplicationContext)context).close();
  }
#+END_SRC

****** 别名标签
在Spring中提供了别名标签<alias>可以为配置的<bean>起一个别名，要注意的是这仅仅是对指定的<bean>起的一个额外的名字，并不会额外的创建对象存入map。

<alias name="要起别名的bean的id" alias="要指定的别名"/>

#+BEGIN_SRC java
  /**
   ,* 别名标签
   ,*  可以通过别名标签为bean的id起一个别名，此后除了可以通过别名指代id
   ,*  <alias name="person" alias="pers"></alias>
   ,*/
  @Test
  public void test05(){
      ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
      //Person p = (Person) context.getBean("person");
      Person p = (Person) context.getBean("pers");
      System.out.println(p);
      ((ClassPathXmlApplicationContext)context).close();
  }
#+END_SRC

#+BEGIN_SRC html
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="person" class="cn.tedu.domain.Person"></bean>
    <alias name="person" alias="pers"></alias>
  </beans>
#+END_SRC

****** Spring创建对象的方式
1. 通过类的无参构造方法创建对象(反射创建对象)
   在入门案例中使用的就是这种方式。
   当用最普通方式配置一个<bean>时,默认就是采用类的无参构造创建对象。
   在Spring容器初始化时，通过<bean>上配置的class属性反射得到字节码对象，通过newInstance()创建对象

   #+BEGIN_SRC
     Class c = Class.forName("类的全路径名称")
     Object obj = c.newInstance()
   #+END_SRC

   这种方式下spring创建对象，要求类必须有无参的构造，否则无法通过反射创建对象，会抛出异常。

   #+BEGIN_SRC java
     public class Person{
         public Person(){
             System.out.println("Person被创建了...");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /**
      ,* SpringIOC创建对象方式1 - 反射创建对象 * bean必须有无参构造才可以
      ,*/
     @Test
     public void test01() throws Exception {
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         Person p = (Person) context.getBean("person");
         System.out.println(p);
         ((ClassPathXmlApplicationContext)context).close();
     }
   #+END_SRC

2. 通过静态工厂创建对象
   很多的时候，我们面对的类是无法通过无参构造去创建的，例如该类没有无参构造、是一抽象类等等情况 ，此时无法要求spring通过无参构造创建对象，此时可以使用静态工厂 方式创建对象。

   #+BEGIN_SRC java
     public class Person{
         public Person(String name){
             System.out.println("Person被创建了..");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /**
      ,* 静态工厂 */
     public class PersonStaticFactory {
         private PersonStaticFactory(){
         }
         public static Person getInstance(){
             return new Person("zs");
         }
     }
   #+END_SRC

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <bean id="person" class="cn.tedu.factory.PersonStaticFactory" factory-method="getInstance"></bean>
     </beans>
   #+END_SRC

   #+BEGIN_SRC java
     @Test
     public void test02(){
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         Person p = (Person) context.getBean("person");
         System.out.println(p);
         ((ClassPathXmlApplicationContext)context).close();
     }
   #+END_SRC

3. 实例工厂创建对象
   实例工厂也可以解决类是无法通过无参构造创建的问题，解决的思路和静态工厂类似，只不过实例工厂提供的方法不是静态的。Spring需要先创建出实例工厂的对象，在调用实例工厂对象上指定的普通方法来创建对象。所以实例工厂也需要配置到Spring中管理。

   #+BEGIN_SRC java
     public class Person{
         public Person(String name){
             System.out.println("Person被创建了..");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /**
      ,* 实例工厂 */
     public class PersonInstanceFactory {
         public Person getInstance(){
             return new Person("ls");
         }
     }
   #+END_SRC

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <bean id="personInstanceFactory" class="cn.tedu.factory.PersonInstanceFactory"></bean>
       <bean id="person" factory-bean="personInstanceFactory" factory-method="getInstance"></bean>
     </beans>
   #+END_SRC

4. Spring工厂创建对象
   Spring内置了工厂接口，也可以通过实现这个接口来开发Spring工厂，通过这个工厂创建对象。

   #+BEGIN_SRC java
     public class Person{
         public Person(String name){
             System.out.println("Person被创建了..");
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     package cn.tedu.factory;
     import cn.tedu.domain.Person;
     import org.springframework.beans.factory.FactoryBean;
     /**
      ,* Spring工厂
      ,*/
     public class PersonSpringFactory implements FactoryBean<Person> {
         /**
          ,* 生产bean对象方法
          ,*/
         @Override
         public Person getObject() throws Exception {
             return new Person("ww");
         }
         /**
          ,* 获取bean类型方法
          ,*/
         @Override
         public Class<?> getObjectType() {
             return Person.class;
         }
         /**
          ,* 告知当前bean是否要采用单例模式
          ,*/
         @Override
         public boolean isSingleton() {
             return true;
         }
     }
   #+END_SRC

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <bean id="person" class="cn.tedu.factory.PersonSpringFactory"></bean>
     </beans>
   #+END_SRC

   #+BEGIN_SRC java
     @Test
     public void test04(){
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         Person p = (Person) context.getBean("person");
         System.out.println(p);
         ((ClassPathXmlApplicationContext)context).close();
         ((ClassPathXmlApplicationContext)context).close();
     }
   #+END_SRC
****** 单例和多例
Spring容器管理的bean在默认情况下是单例的，也即，一个bean只会创建一个对象，存在内置map中，之后无论获取多少次该bean，都返回同一个对象。

Spring默认采用单例方式，减少了对象的创建，从而减少了内存的消耗。但是在实际开发中是存在多例的需求的，Spring也提供了选项可以将bean设置为多例模式。

#+BEGIN_SRC html
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">

    <!--scope属性控制当前bean的创建模式: singleton:则当前bean处在单例模式中,默认就是此模式 prototype:则当前bean处在多例模式中-->
    <bean id="cart" class="cn.tedu.beans.Cart" scope="prototype"></bean>
  </beans>
#+END_SRC
- bean在单例模式下的生命周期:
  bean在单例模式下，Spring容器启动时解析xml发现该bean标签后，直接创建该bean的对象存入内部map中保存，此后无论调用多少次getBean()获取该bean都是从map中获取该对象返回，一直是一个对象。此对象一直被Spring容器持有，直到容器退出时，随着容器的退出对象被销毁。
- bean在多例模式下的生命周期:
  bean在多例模式下，Spring容器启动时解析xml发现该bean标签后，只是将该bean进行管理，并不会创建对象，此后每次使用getBean()获取该bean时，Spring都会重新创建该对象返回，每次都是一个新的对象。这个对象Spring容器并不会持有，什么销毁取决于使用该对 象的用户自己什么时候销毁该对象。
****** 懒加载机制
Spring默认会在容器初始化的过程中，解析xml，并将单例的bean创建并保存到map中，这样的机制在bean比较少时问题不大，但一旦bean非常多时，Spring需要在启动的过程中花费大量的时间来创建bean，花费大量的空间存储bean，但这些bean可能很久都用不上，这种在启动时,在时间和空间上的浪费显得非常的不值得。

所以Spring提供了懒加载机制。所谓的懒加载机制就是可以规定指定的bean不在启动时立即创建，而是在后续第一次用到时才创建，从而减轻在启动过程中对时间和内存的消耗。懒加载机制只对单例bean有作用，对于多例bean设置懒加载没有意义。
- 懒加载的配置方式:
  1. 为指定bean配置懒加载

     #+BEGIN_SRC html
       <?xml version="1.0" encoding="UTF-8"?>
       <beans xmlns="http://www.springframework.org/schema/beans"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring -beans-3.2.xsd"
              <bean id="cart" class="cn.tedu.beans.Cart" lazy-init="true"></bean>
       </beans>
     #+END_SRC
  2. 为全局配置懒加载

     #+BEGIN_SRC html
       <?xml version="1.0" encoding="UTF-8"?>
       <beans xmlns="http://www.springframework.org/schema/beans"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://www.springframework.org/schema/beans
                                  http://www.springframework.org/schema/beans/spring -beans-3.2.xsd"
              default-lazy-init="true"
              >
         <bean id="cart" class="cn.tedu.beans.Cart"></bean>
       </beans>
     #+END_SRC
  如果同时设定全局和指定bean的懒加载机制，且配置不相同，则对于该bean局部配置覆盖全局配置。

- 实验：通过断点调试，验证懒加载机制的执行过程

  #+BEGIN_SRC java
    package cn.tedu.beans;
    public class Cart {
        public Cart() {
            System.out.println("Cart init...");
        }
    }
  #+END_SRC

  #+BEGIN_SRC html
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
      <bean id="person" class="cn.tedu.domain.Person"></bean>
    </beans>
  #+END_SRC

  #+BEGIN_SRC java
    @Test
    /**
     ,* SpringIOC 懒加载机制
     ,*/
    public void test10(){
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        Cart cart1 = (Cart) context.getBean("cart");
        Cart cart2 = (Cart) context.getBean("cart");
        System.out.println(cart1 == cart2);
    }
  #+END_SRC

****** 配置初始化和销毁的方法
在Spring中如果某个bean在初始化之后或销毁之前要做一些额外操作可以为该bean配置初始化和销毁的方法，在这些方法中完成要功能。

实验：通过断点调试模式，测试初始化方法和销毁方法的执行

#+BEGIN_SRC java
  package cn.tedu.beans;
  public class ProdDao {
      public ProdDao() {
          System.out.println("ProdDao 被创建。。。");
      }
      public void init(){
          System.out.println("init。。连接数据库。。。。。");
      }
      public void destory(){
          System.out.println("destory。。断开数据库。。。。。");
      }
      public void addProd(){
          System.out.println("增加商品。。");
      }
      public void updateProd(){
          System.out.println("修改商品。。");
      }
      public void delProd(){
          System.out.println("删除商品。。"); }
      public void queryProd(){
          System.out.println("查询商品。。");
      }
  }
#+END_SRC

#+BEGIN_SRC html
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="prodDao" class="cn.tedu.beans.ProdDao" init-method="init" destroy-method="destory"></bean>
  </beans>
#+END_SRC

#+BEGIN_SRC java
  @Test
  /**
   ,* SpringIOC 初始化和 销毁方法
   ,*/
  public void test11(){
      ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
      ProdDao prodDao = (ProdDao) context.getBean("prodDao");
      prodDao.addProd();
      context.close();
  }
#+END_SRC

****** Spring中关键方法的执行顺序
在Spring创建bean对象时，先创建对象(通过无参构造或工厂)，之后立即调用init方法来执行初始化操作，之后此bean就可以哪来调用其它普通方法,而在对象销毁之前，Spring容器调用其destory方法来执行销毁操作。
***** Spring DI
****** IOC(DI) - 控制翻转（依赖注入）
所谓的IOC称之为控制反转，简单来说就是将对象的创建的权利及对象的生命周期的管理过程交由Spring框架来处理，从此在开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要时由Spring框架提供，这个由spring框架管理对象创建和生命周期的机制称之为控制反转。
*而在创建对象的过程中Spring可以依据配置对对象的属性进行设置，这个过称之为依赖注入,也即DI。*
****** set方法注入
通常的javabean属性都会私有化，而对外暴露setXxx()getXxx()方法，此时Spring可以通过这样的setXxx()方法将属性的值注入对象。
1. Spring普通属性注入：

   #+BEGIN_SRC java
     package cn.tedu.beans;
     import java.util.List;
     import java.util.Map;
     import java.util.Properties;
     import java.util.Set;
     public class Hero {
         private int id;
         private String name;
         private List<String> jobs;
         private Set<String> set;
         private Map<String,String> map;
         private Properties prop;
         public void setId(int id) {
             this.id = id;
         }
         public void setName(String name) {
             this.name = name;
         }
         public void setJobs(List<String> jobs) {
             this.jobs = jobs;
         }
         public void setSet(Set<String> set) {
             this.set = set;
         }
         public void setMap(Map<String, String> map) {
             this.map = map;
         }
         public void setProp(Properties prop) { t
                 his.prop = prop;
         }
         @Override
         public String toString() {
             return "Hero [id=" + id + ", name=" + name + ", jobs=" + jobs
                 + ", set=" + set + ", map=" + map + ", prop=" + prop + "]";
         }
     }
   #+END_SRC

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <bean id="hero" class="cn.tedu.beans.Hero">
         <property name="id" value="123"></property>
         <property name="name" value="亚瑟 "></property>
         <property name="jobs">
           <list>
             <value>上单</value>
             <value>打野</value>
             <value>辅助</value>
             <value>中单</value>
           </list>
         </property>
         <property name="set">
           <set>
             <value>aaa</value>
             <value>bbb</value>
             <value>ccc</value>
             <value>aaa</value>
           </set>
         </property>
         <property name="map">
           <map>
             <entry key="addr" value="王者荣耀"></entry>
             <entry key="addr" value="英雄联盟"></entry>
             <entry key="skill" value="风火轮"></entry>
             <entry key="age" value="19"></entry>
           </map>
         </property>
         <property name="prop">
           <props>
             <prop key="k1">v1</prop>
             <prop key="k2">v2</prop>
             <prop key="k3">v3</prop>
             <prop key="k4">v4</prop>
           </props>
         </property>
       </bean>
     </beans>
   #+END_SRC

   #+BEGIN_SRC java
     @Test
     /**
      ,* SpringDI set方式属性注入 - Spring内置的可直接注入类型的注入
      ,*/
     public void test1(){
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         Hero hero = (Hero) context.getBean("hero");
         System.out.println(hero);
     }
   #+END_SRC
2. 自定义bean的注入:

   #+BEGIN_SRC java
     package cn.tedu.beans;
     import java.util.List;
     import java.util.Map;
     import java.util.Properties;
     import java.util.Set;
     public class Hero {
         private int id;
         private String name;
         private List<String> jobs;
         private Set<String> set;
         private Map<String,String> map;
         private Properties prop;
         private Dog dog;
         private Cat cat;
         public void setId(int id) {
             this.id = id;
         }
         public void setName(String name) {
             this.name = name;
         }
         public void setJobs(List<String> jobs) {
             this.jobs = jobs;
         }
         public void setSet(Set<String> set) {
             this.set = set;
         }
         public void setMap(Map<String, String> map) {
             this.map = map;
         }
         public void setProp(Properties prop) {
             this.prop = prop;
         }
         public void setDog(Dog dog) {
             this.dog = dog;
         }
         public void setCat(Cat cat) {
             this.cat = cat;
         }
         @Override
         public String toString() {
             return "Hero [id=" + id + ", name=" + name + ", jobs=" + jobs
                 + ", set=" + set + ", map=" + map + ", prop=" + prop + ", dog=" + dog + ", cat=" + cat + "]";
         }
     }
   #+END_SRC

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring -beans-3.2.xsd">
       <bean id="hero" class="cn.tedu.beans.Hero">
         <property name="id" value="123"></property>

         <property name="name" value="亚瑟 "></property>

         <property name="jobs">
           <list>
             <value>上单</value>
             <value>打野</value>
             <value>辅助</value>
             <value>中单</value>
           </list>
         </property>
         <property name="set">
           <set>
             <value>aaa</value>
             <value>bbb</value>
             <value>ccc</value>
             <value>aaa</value>
           </set>
         </property>
         <property name="map">
           <map>
             <entry key="addr" value="王者荣耀"></entry>
             <entry key="addr" value="英雄联盟"></entry>
             <entry key="skill" value="风火轮"></entry>
             <entry key="age" value="19"></entry>
           </map>
         </property>
         <property name="prop">
           <props>
             <prop key="k1">v1</prop>
             <prop key="k2">v2</prop>
             <prop key="k3">v3</prop>
             <prop key="k4">v4</prop>
           </props>
         </property>
         <property name="dog" ref="dog"></property>
         <property name="cat" ref="cat"></property>
       </bean>
       <bean id="dog" class="cn.tedu.beans.Dog"></bean> <bean id="cat" class="cn.tedu.beans.Cat"></bean>
     </beans>
   #+END_SRC

   #+BEGIN_SRC java
     @Test
     /**
      ,* SpringDI set方式属性注入 - 非Spring内置的可以直接注入类型的注入
      ,*/
     public void test2(){
         ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
         Hero hero = (Hero) context.getBean("hero");
         System.out.println(hero);
     }
   #+END_SRC
****** 自动装配
在Spring的set方式实现的注入过程中，支持自动装配机制，所谓自动装配机制，会根据要设置的javabean属性的名字或类型到spring中自动寻找对应id或类型的<bean>进行设置，从而省去依次配置的过程，简化了配置。
1. 为指定<bean>开启自动装配:

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
         <bean id="dog" class="cn.tedu.domain.Dog">
             <property name="name" value="旺财"></property>
             <property name="age" value="3"></property>
         </bean>
         <bean id="cat" class="cn.tedu.domain.Cat">
             <property name="name" value="汤姆"></property>
             <property name="age" value="2"></property>
         </bean>
         <bean id="cat2" class="cn.tedu.domain.Cat">
             <property name="name" value="阿花"></property>
             <property name="age" value="1"></property>
         </bean>
         <!--
                autowire 实现自动装配
                 byName
                     会自动找和当前bean属性名一样的id的bean进行注入
                         找不到就不注入
                         找到唯一的就注入
                         不可能找到多个
                 byType
                     会自动找和当前bean属性类型一致的bean进行注入
                         找不到就不注入
                         找到唯一的就注入
                         找到多个抛出异常
         -->
         <bean id="hero" class="cn.tedu.domain.Hero" autowire="byName">
             <property name="name" value="亚瑟"></property>
             <property name="age" value="55"></property>
             <!--
             <property name="dog" ref="dog"></property>
             <property name="cat" ref="cat"></property>
             -->
         </bean>
     </beans>
   #+END_SRC
2. 为全局配置自动装配:

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
         <bean id="dog" class="cn.tedu.domain.Dog">
             <property name="name" value="旺财"></property>
             <property name="age" value="3"></property>
         </bean>
         <bean id="cat" class="cn.tedu.domain.Cat">
             <property name="name" value="汤姆"></property>
             <property name="age" value="2"></property>
         </bean>
         <bean id="cat2" class="cn.tedu.domain.Cat">
             <property name="name" value="阿花"></property>
             <property name="age" value="1"></property>
         </bean>
         <!--
                autowire 实现自动装配
                 byName
                     会自动找和当前bean属性名一样的id的bean进行注入
                         找不到就不注入
                         找到唯一的就注入
                         不可能找到多个
                 byType
                     会自动找和当前bean属性类型一致的bean进行注入
                         找不到就不注入
                         找到唯一的就注入
                         找到多个抛出异常
         -->
         <bean id="hero" class="cn.tedu.domain.Hero" autowire="byName">
             <property name="name" value="亚瑟"></property>
             <property name="age" value="55"></property>
             <!--
             <property name="dog" ref="dog"></property>
             <property name="cat" ref="cat"></property>
             -->
         </bean>
     </beans>
   #+END_SRC

   #+BEGIN_SRC java
     package cn.tedu.domain;

     public class Hero {
         private String name;
         private int age;
         private Dog dog;
         private Cat cat;

         public String getName() {
             return name;
         }

         public void setName(String name) {
             this.name = name;
         }

         public int getAge() {
             return age;
         }

         public void setAge(int age) {
             this.age = age;
         }

         public Dog getDog() {
             return dog;
         }

         public void setDog(Dog dog) {
             this.dog = dog;
         }

         public Cat getCat() {
             return cat;
         }

         public void setCat(Cat cat) {
             this.cat = cat;
         }

         @Override
         public String toString() {
             return "Hero{" +
                 "name='" + name + '\'' +
                 ", age=" + age +
                 ", dog=" + dog +
                 ", cat=" + cat +
                 '}';
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     package cn.tedu.domain;

     public class Cat {
         private String name;
         private int age;

         public String getName() {
             return name;
         }

         public void setName(String name) {
             this.name = name;
         }

         public int getAge() {
             return age;
         }

         public void setAge(int age) {
             this.age = age;
         }

         @Override
         public String toString() {
             return "Cat{" +
                 "name='" + name + '\'' +
                 ", age=" + age +
                 '}';
         }
     }

   #+END_SRC

   #+BEGIN_SRC java
     package cn.tedu.domain;

     public class Dog {
         private String name;
         private int age;

         public String getName() {
             return name;
         }

         public void setName(String name) {
             this.name = name;
         }

         public int getAge() {
             return age;
         }

         public void setAge(int age) {
             this.age = age;
         }

         @Override
         public String toString() {
             return "Dog{" +
                 "name='" + name + '\'' +
                 ", age=" + age +
                 '}';
         }
     }

   #+END_SRC

   #+BEGIN_SRC java
     package cn.tedu.test;

     import cn.tedu.domain.Hero;
     import org.junit.Test;
     import org.springframework.context.ApplicationContext;
     import org.springframework.context.support.ClassPathXmlApplicationContext;

     public class Test01 {
         /**
          ,* Setter方式实现DI 自定义bean类型的注入
          ,*/
         @Test
         public void test01(){
             ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
             Hero hero = (Hero) context.getBean("hero");
             System.out.println(hero);
             ((ClassPathXmlApplicationContext)context).close();
         }
     }
   #+END_SRC
****** 基于构造方法的注入
对象属性设置的另一种方式是在对象创建的过程中通过构造方法传入并设置对象的属性。 spring也可以通过这样的构造方法实现属性的注入。

#+BEGIN_SRC java
  package cn.tedu.domain;

  public class Dog {
      private String name;
      private int age;

      public String getName() {
          return name;
      }

      public void setName(String name) {
          this.name = name;
      }

      public int getAge() {
          return age;
      }

      public void setAge(int age) {
          this.age = age;
      }

      @Override
      public String toString() {
          return "Dog{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      }
  }
#+END_SRC

#+BEGIN_SRC java
  package cn.tedu.domain;

  public class Student {
      private int id;
      private String name;
      private Dog dog;

      public Student() {
      }

      public Student(int id, String name, Dog dog) {
          this.id = id;
          this.name = name;
          this.dog = dog;
      }

      @Override
      public String toString() {
          return "Student{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  ", dog=" + dog +
                  '}';
      }
  }

#+END_SRC

#+BEGIN_SRC html
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
      <bean id="dog" class="cn.tedu.domain.Dog">
          <property name="name" value="旺财"></property>
          <property name="age" value="5"></property>
      </bean>
      <bean id="student" class="cn.tedu.domain.Student">
          <!--
          index 构造器在中第几个参数
          name 构造器中叫什么名字的参数
          type 构造器中什么类型的参数
          value 给什么值
          ref 给什么值，通过引用
          -->
          <constructor-arg index="0" name="id" type="int" value="3"></constructor-arg>
          <constructor-arg name="name" value="zs"></constructor-arg>
          <constructor-arg index="2" ref="dog"></constructor-arg>
      </bean>
  </beans>
#+END_SRC

#+BEGIN_SRC java
  package cn.tedu.test;

  import cn.tedu.domain.Student;
  import org.junit.Test;
  import org.springframework.context.ApplicationContext;
  import org.springframework.context.support.ClassPathXmlApplicationContext;

  /**
   ,* Spring IOC DI 基于构造器的注入
   ,*/
  public class Test01 {
      @Test
      public void test01(){
          ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
          Student student = (Student) context.getBean("student");
          System.out.println(student);
          ((ClassPathXmlApplicationContext)context).close();
      }
  }
#+END_SRC

***** 注解
****** 注解回顾
******* 注解概念
- 注释：
  给人看的提示信息，人看了提示信息了解程序的内容 java中注释的格式:// /**/ /** */
- 注解：
  sun在jdk5.0开始提供的新特性给程序看的提示信息，程序看后可以根据有无注解及注解上属性的不同配置执行不同的逻辑。java中的注解的格式:@AnnoName(key=value,...)
注解在开发中，可以作为轻量化配置来使用，比起使用xml作为配置文件，更加的轻便易用，在java开发中大量的使用。
******* jdk内置注解
| @Override         | 声明重写父类方法的注解，要求编译器帮我们检查是否成功的覆盖，如果没有成功覆盖 父类方法，编译器将会进行报错提示。 |
| @Deprecated       | 声明方法被过时，不再建议使用，要求编译器在编译的过程中对于这样的方法的调用提 出警告，提示方法过时。             |
| @SuppressWarnings | 压制警告，提示编译器，在编译的过程中对指定类型的警告不再提示                                                    |
******* 自定义注解开发
1. 开发一个注解类
   开发一个注解类的过程，非常类似于开发一个接口，需要通过@interface关键字来声明
2. 使用元注解修饰注解的声明
   所谓的元注解是用来修饰注解声明的注解，可以控制被修饰的注解的特性。
   - @Target
     用来声明被修饰的注解可以用在什么位置。可以在@Target的属性中设置ElementType类型的数组来指定可以使用的位置。如果不用此元注解修饰，默认注解可以用在任意位置
   - @Retention
     用来声明被修饰的注解会被保留到什么阶段。
     可以在该注解的属性中通过RetentionPolicy类型的值来指定注解被保留到何时。
     1. RetentionPolicy.SOURCE
        此注解将会被保留到源码阶段，.java中，在编译过程中被删除。这种类型的注解通常是给编译器看的。
     2. RetentionPolicy.CLASS
        此注解将会被保留在源码阶段 和 编译阶段 ，.java和.class中，在类加载的过 程中被删除。这种类型的注解通常是给类加载器看的。
     3. RetentionPolicy.RUNTIME
        此注解将会被保留在源码阶段、编译阶段和运行阶段，.java和.class和内存中的字节码中都会存在。这种类型的注解通常用来在运行阶段进行反射，控制程序运行过程。只有RUNTIME级别的注解才可以通过反射技术进行反射。
   - @Documented
     可以控制自定义注解是否可以被文档提取到doc文档中
   - @Inherited可以控制自定义注解是否具有继承性
3. 为自定义注解增加属性
   为注解类声明属性的过程非常类似于为接口定义方法。
   但要求：
   1. 注解中的所有的属性必须是public的，可以显式声明，也可以不声明，不声明默认就是public的。
   2. 注解中的属性只能是八种基本数据类型：String类型、Class类型、枚举类型、其他注解类型及以上类型的一维数组。
   3. 注解中声明的属性，需要在使用注解时为其赋值，赋值的方式就是使用注解时，在注解后跟一对小括号，在其中通过属性名=属性值的方式，指定属性的值。
   4. 也可以在声明注解时，在注解的属性后通过default关键字声明属性的默认值，声明过默认值的属性可以在使用注解时不赋值，则默认采用默认值，也可以手动赋值覆盖默认值。
   5. 如果属性是一维数组类型，而在传入的数组中只有一个值，则包括数组的大括号可以省略，如果注解的属性只有一个需要赋值，且该属性的名称叫做value，则在使用注解时value= 可以不写
******* 反射注解
1. 反射注解的原理
   RetentionPolicy.RUNTIME级别的注解会保留到运行其，可以通过反射技术获取，从而可以根据是否有注解或注解属性值的不同控制程序按照不同方式运行。以下反射相关的类型中都提供了反射注解的方法:

   类Class<T>、类Method、类Field、类Constructor<T>、类Package
   | boolean                  | isAnnotationPresent(Class<? extends Annotation> annotationClass) 如果指定类型的注释存在于此元素上，则返回 true，否则返回 false |
   | <A extends Annotation> A | getAnnotation(Class<A> annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。                        |
   | Annotation[]             | getAnnotations() 返回此元素上存在的所有注释。                                                                                  |
2. 反射注解案例

   #+BEGIN_SRC java
     package cn.tedu.test;
     import java.lang.annotation.ElementType;
     import java.lang.annotation.Retention;
     import java.lang.annotation.RetentionPolicy;
     import java.lang.annotation.Target;
     @level("刑警")
     class Police{
     }
     public class AnnoTest02 {
         public static void main(String[] args) {
             System.out.println("敬了个礼，您好，您超速了，罚款200元。。。");
             if(Police.class.isAnnotationPresent(level.class)){
                 level anno = Police.class.getAnnotation(level.class);
                 if("协警".equals(anno.value())){
                     System.out.println("哥们少罚点，50块得了~~");
                 }else if("交警".equals(anno.value())){
                     System.out.println("哥们抽根烟，这是200块，收好我走人~~");
                 }else if("刑警".equals(anno.value())){
                     System.out.println("赶紧交钱走人，别查出 别的事。。。");
                 }else{
                     System.out.println("xxx"); }
             }else{
                 System.out.println("打一顿，扭送警察局。。");
             }
         }
     }
   #+END_SRC

****** Spring注解方式实现IOC和DI
******* Spring注解
Spring除了默认的使用xml配置文件的方式实现配置之外，也支持使用注解方式实现配置，这种方式效率更高，配置信息清晰，代码在哪对应的配置就在哪，方便开发阶段修改，推荐使用。所谓注解就是给程序看的提示信息，很多时候都用来作为轻量级配置的方式。 关于注解的知识点，参看java基础课程中java基础加强部分的内容。
******* Spring注解方式实现IOC
1. 导入开发包
   [[./Img/3.png]]
2. 编写配置文件，并导入context约束

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.2.xsd
                                ">
     </beans>
   #+END_SRC
   可以将以上头信息加入MyEclipse模版，方便后续自动生成。
3. 开启包扫描
   在配置文件中，开启包扫描，指定spring自动扫描哪些个包下的类。只有在指定的扫描包下 的类上的IOC注解才会生效。

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.2.xsd
                                ">

       <!-- 开启包扫描 -->
       <context:component-scan base-package="cn.tedu.beans"></context:component-scan>
       <!--
           <bean id="person" class="cn.tedu.beans.Person"></bean> <bean id="cat" class="cn.tedu.beans.Cat"></bean>
           <bean id="dog" class="cn.tedu.beans.Dog"></bean>
       -->
     </beans>
   #+END_SRC
4. 使用注解注册bean
   在配置的包中的类上使用@Component注解，则这个类会自动被注册为bean，使用当前类 的class为<bean>的class，通常情况下使用类名首字母小写为<bean>id。
   - 案例：

     #+BEGIN_SRC java
       package cn.tedu.beans;
       import org.springframework.stereotype.Component;

       @Component
       public class Person{
       }
     #+END_SRC
5. bean的id
   通常情况下注解注册bean使用类名首字母小写为bean的id，但是如果类名的第二个字母为 大写则首字母保留原样.

   #+BEGIN_SRC html
     cn.tedu.beans.Person --> <bean id="person" class="cn.tedu.beans.Person"/>
     cn.tedu.beans.PErson --> <bean id="PErson" class="cn.tedu.beans.Person"/>
     cn.tedu.beans.NBA --> <bean id="NBA" class="cn.tedu.beans.NBA"/>
   #+END_SRC
   也可以通过在@Component中配置value属性，明确的指定bean的id
   - 案例：
     可以使bean类实现BeanNameAware接口，并实现其中的setBeanName方法，Spring容器会在初始化bean时，调用此方法告知当前bean的id。通过这个方式可以获取bean的id信息。

     #+BEGIN_SRC java
       package cn.tedu.beans;
       import org.springframework.beans.factory.BeanNameAware;
       import org.springframework.beans.factory.annotation.Autowired;
       import org.springframework.beans.factory.annotation.Qualifier;
       import org.springframework.stereotype.Component;
       @Component("per")
       public class Person implements BeanNameAware{
           @Override
           public void setBeanName(String name) {
           }
       }
     #+END_SRC
6. 注解方式实现工厂注册bean
   Spring默认通过反射创建bean，如果某些bean没有无参构造器或创建过程非常复杂，则无法通过简单的反射创建bean，此时可以通过指定创建bean的工厂，令SpringIOC通过工厂来创建bean，从而进行注册。 可以通过配置文件方式配置bean工厂，同样也可以通过注解配置bean工厂。
   1. 配置工厂类
      工厂类必须放在包扫描目录下，且被@Component注解修饰
   2. 配置工厂类中生产bean的方法
      工厂中生产bean的方法要被@Bean修饰 则此方法会被SpringIOC调用，并将返回的对象注册为Spring的bean，默认自动推 断id，也可以通过value属性手工指定id。

      #+BEGIN_SRC java
        @Component
        public class Pesron5Factory {
            @Bean("per5")
            public Person5 getInstance(){
                return new Person5("xx");
            }
        }
      #+END_SRC
******* Spring注解方式实现DI
1. 导入开发包
   [[./Img/3.png]]
2. 编写配置文件，并导入context约束

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.2.xsd
                                ">
     </beans>
   #+END_SRC
3. 配置开启注解实现DI选项

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:util="http://www.springframework.org/schema/util"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.2.xsd
                                http://www.springframework.org/schema/util
                                http://www.springframework.org/schema/util/spring-util-3.2.xsd
                                ">
       <!-- 开启IOC包扫描 -->
       <context:component-scan base-package="cn.tedu.domain"/> <!-- 开启注解配置DI -->
       <!-- 开启注解配置DI -->
       <context:annotation-config></context:annotation-config>
     </bean>
   #+END_SRC
4. 注解方式注入spring内置支持的类型数据 - 非集合类型
   Spring中可以通过@Value注解来实现spring内置支持的类型的属性的注入。

   #+BEGIN_SRC java
     package cn.tedu.domain;
     import org.springframework.beans.factory.annotation.Value;
     import org.springframework.stereotype.Component;
     @Component
     public class Student {
         @Value("zs") private String name;
         @Value("19") private int age;
         @Override
         public String toString() {
             return "Student [name=" + name + ", age=" + age + "]";
         }
     }
   #+END_SRC
   这种方式可以实现spring内置支持类型的注入，但是这种方式将注入的值写死在了代码中，后续如果希望改变注入的值，必须来修改源代码，此时可以将这些值配置到一个properties 配置文件中，再在spring中进行引入。
5. 注解方式注入spring内置支持的类型数据 - 集合类型
   引入util名称空间，通过适当的util标签注册数据

   #+BEGIN_SRC html
     <?xml version="1.0" encoding="UTF-8"?>
     <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:util="http://www.springframework.org/schema/util"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
                                http://www.springframework.org/schema/context
                                http://www.springframework.org/schema/context/spring-context-3.2.xsd
                                http://www.springframework.org/schema/util
                                http://www.springframework.org/schema/util/spring-util-3.2.xsd
                                ">
       <!-- 开启IOC包扫描 -->
       <context:component-scan base-package="cn.tedu.domain"/>
       <!-- 开启注解配置DI -->
       <context:annotation-config></context:annotation-config>
       <!-- 引入Properties文件 -->
       <context:property-placeholder location="classpath:/stu.properties"/>
       <!-- 配置集合数据 -->
       <util:list id="l1">
         <value>aaa</value>
         <value>bbb</value>
         <value>ccc</value>
       </util:list>
       <util:set id="s1">
         <value>111</value>
         <value>222</value>
         <value>333</value>
       </util:set>
       <util:map id="m1">
         <entry key="k1" value="v1"></entry>
         <entry key="k2" value="v2"></entry>
         <entry key="k3" value="v3"></entry>
       </util:map>
       <util:properties id="p1">
         <prop key="p1">v1</prop>
         <prop key="p2">v2</prop>
         <prop key="p3">v3</prop>
       </util:properties>
     </beans>
   #+END_SRC
   再在类的属性中通过@Value注入赋值

   #+BEGIN_SRC java
     package cn.tedu.domain;
     import java.util.List;
     import java.util.Map;
     import java.util.Properties;
     import java.util.Set;
     import org.springframework.beans.factory.annotation.Value;
     import org.springframework.stereotype.Component;
     @Component
     public class Student {
         @Value("${name}") private String name;
         @Value("${age}") private int age;
         @Value("#{@l1}") private List<String> list;
         @Value("#{@s1}") private Set<String> set;
         @Value("#{@m1}")
         private Map<String,String> map;
         @Value("#{@p1}") private Properties prop;
         @Override
         public String toString() {
             return "Student [name=" + name + ", age=" + age + ", list=" + list
                 + ", set=" + set + ", map=" + map + ", prop=" + prop + "]";
         }
     }
   #+END_SRC
6. 使用注解注入自定义bean类型数据
   在bean中的属性上通过@Autowired实现自定义bean类型的属性注入
   - 代码：

     #+BEGIN_SRC java
       package cn.tedu.domain;
       import java.util.List;
       import java.util.Map;
       import java.util.Properties;
       import java.util.Set;
       import org.springframework.beans.factory.annotation.Autowired;
       import org.springframework.beans.factory.annotation.Value;
       import org.springframework.stereotype.Component;
       @Component
       public class Student {
           @Autowired private Dog dog;
           @Autowired private Cat cat;
           @Override
           public String toString() {
               return "Student [dog="+ dog + ", cat=" + cat + "]";
           }
       }
     #+END_SRC

   当Spring容器解析到@Component注解时，创建当前类的bean在spring容器中进行管理，在创建bean的过程中发现了@Autowired注解，会根据当前bean类型，寻找在spring中是否存在该类型的bean，找到直接注入，如果找不到还会检查是否有子孙类、实现类存在，如果存在唯一的则自动注入，如果还是没有找到或找到多个无法注入，则还会按照属性名对应id去查找对应的bean，如果存在则注入，如果还是没有找到则抛出异常。也可以额外配置@Qualifier(value="dog1")注解强制要求按照id寻找bean，则此时会直接 使用给定的id寻找bean，而不会进行基于类型的匹配。
   - 也可以使用@Resource(name="id")指定注入给定id的bean，但是这种方式不建议大家使 用。
******* 其他注解
1. @Scope(value="prototype")
   配置修饰的类的bean是单例还是多例，如果不配置默认为单例
   - 案例:

     #+BEGIN_SRC java
       package cn.tedu.domain;
       import org.springframework.context.annotation.Scope;
       import org.springframework.stereotype.Component;
       @Component @Scope("prototype")
       public class Teacher {

       }
     #+END_SRC
2. @Lazy
   配置修饰的类的bean采用懒加载机制
   - 案例:

     #+BEGIN_SRC java
       package cn.tedu.domain;
       import org.springframework.context.annotation.Lazy;
       import org.springframework.stereotype.Component;

       @Component
       @Component
       @Lazy
       public class Teacher {
           public Teacher() {
               System.out.println("teacher construct..");
           }
       }
     #+END_SRC
3. @PostConstruct
   在bean对应的类中,修饰某个方法,将该方法声明为初始化方法，对象创建之后立即执行。
4. @PreDestroy
   在bean对应的类中,修饰某个方法,将该方法声明为销毁的方法，对象销毁之前调用的方法。
   - 案例：

     #+BEGIN_SRC java
       package cn.tedu.beans;
       import javax.annotation.PostConstruct;
       import javax.annotation.PreDestroy;
       import org.springframework.stereotype.Component;

       @Component
       public class Dog {
           public Dog() {
           }
           System.out.println("Dog...被创建出来了...");
       }
       @PostConstruct public void init(){
           System.out.println("Dog的初始化方法。。。");
       }
       @PreDestroy
       public void destory(){
           System.out.println("Dog的销毁方法。。。");
       }
     #+END_SRC
5. @Controller @Service @Repository @Component
   这四个注解的功能是完全相同的，都是用来修饰类，将类声明为Spring管理的bean的。其中@Component一般认为是通用的注解,而@Controller用在软件分层中的控制层，一般用在web层，而@Service用在软件分层中的业务访问层，一般用在service层，而@Repository用在软件分层中的数据访问层，一般用在dao层
***** 利用Spring IOC DI 实现软件分层解耦
****** 软件分层思想回顾
在软件领域有MVC软件设计思想，指导着软件开发过程。在javaee开发领域，javaee的经典三层架构MVC设计思想的经典应用。而在软件设计思想中，追求的是"高内聚低耦合"的目标，利用Spring的IOC 和 DI 可以非常方便的实现这个需求。
****** Spring IOC DI 改造EasyMall
在层与层之间设计接口，面向接口编程:

[[./Img/4.png]]
不再直接创建对象，而是通过Spring注入:

如果存在多个实现类，则通过指定名称声明<bean>的id，实现使用指定实现类的
***** SpringAOP基础 - 代理设计模式
****** 改造过后的EasyMall的问题
改造过后的EasyMall成功解决了耦合的问题，但是在很多地方仍然存在非该层应该实现的功能，造成了无法“高内聚”的现象，同时存在大量存在重复代码，开发效率低下。此时可以通过代理设计模式，将这部分代码提取到代理者中，简化层中的代码。
****** 静态代理模式

#+BEGIN_SRC java
  import org.junit.Test;
  import java.lang.reflect.InvocationHandler;
  import java.lang.reflect.Method;
  import java.lang.reflect.Proxy;

  interface Star{
      public void qianming();
      public void chifan();
  }
  public class Test02 {
      /**
       ,* 静态代理
       ,*  优点：好理解
       ,*  缺点：所有方法都要实现 代码存在大量重复
       ,*/
      @Test
      public void test01(){
          FBB fbb = new FBB();

          class ZuLi implements Star{
              @Override
              public void qianming() {
                  System.out.println("你谁啊？");
                  fbb.qianming();
                  System.out.println("记录一下..");
              }
              @Override
              public void chifan() {
                  System.out.println("你谁啊？");
                  fbb.chifan();
                  System.out.println("记录一下..");
              }
          }

          ZuLi proxy = new ZuLi();

          proxy.qianming();
          proxy.chifan();
      }
  }

#+END_SRC

静态代理设计模式特点:
- 优点:
  结构清晰 易于理解
- 缺点:
  如果被代理者有多个方法，则代理者也需要开发多个方法，其中往往存在大量重复代码，仍然存在代码重复。
静态代理设计模式解决了软件分层过程中额外的功能代码侵入模块的问题，将额外的功能代码提取到了代理者中进行，但是静态代理实现的代理者中存在大量重复的代码，并没有解决代码 重复问题。所以在真正开发中--包括spring的底层，基本不会使用静态代理。
****** 动态代理 - jdk内置的动态代理
在jdk中提供了动态代理实现的工具类，直接使用该工具类就可以创建出代理者，并且可以通过内置的回调函数指定代理在工作时的执行逻辑，从而实现基于jdk原生api的动态代理机制。
#+BEGIN_SRC java
  package cn.tedu.javaproxy;
  import java.lang.reflect.InvocationHandler;
  import java.lang.reflect.Method;
  import java.lang.reflect.Proxy;
  import org.junit.Test;
  public class JavaProxyTest {
      @Test
      public void test01(){ //被代理者
          final FBB fbb = new FBB();
          //java动态代理方式 生成fbb的代理者
          /**
           ,* classLoader:用来生成代理者类的类加载器，通常可以传入被代理者类的类加载器
           ,* interfaces: 要求生成的代理者实现的接口们，通常就是实现和被代理者相同的接口，保证具有和被代理者相同的方法
           ,* invocationHandler: 用来设定回调函数的回调接口，使用者需要写一个类实现此接口，从而实现其中的invoke方法，
           ,* 在其中编写代码处理代理者调用方法时的回调过程，通常在这里调用真正对象身上的方法，并且在方法之前或之后做额外操作。
           ,*/
          SJSkill proxy = (SJSkill) Proxy.newProxyInstance( FBB.class.getClassLoader(),FBB.class.getInterfaces() ,new InvocationHandler() {
              @Override
              public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
                  if("拍电影".equals(method.getName())){ System.out.println("不好意思，给多少钱不拍了~~"); return null;
                  }else{
                      System.out.println("检验权限。。。。"); Object returnObj = method.invoke(fbb, args); System.out.println("记录日志。。。。");
                      return returnObj;
                  }
              }
          });
          //从此之后，不允许直接调用被代理者身上的方法，而是要通过代理者来调用 //fbb.吃();
          //fbb.唱歌();
          proxy.吃();
          proxy.唱歌();
          proxy.拍电影();
      }
  }
#+END_SRC

#+BEGIN_SRC java
  package cn.tedu;

  import org.junit.Test;
  import java.lang.reflect.InvocationHandler;
  import java.lang.reflect.Method;
  import java.lang.reflect.Proxy;

  interface Star{
      public void qianming();
      public void chifan();
  }

  class FBB implements Star{
      public void qianming(){
          System.out.println("fbb签名..");
      }
      public void chifan(){
          System.out.println("fbb吃饭..");
      }
      public void shufa(){
          System.out.println("fbb写书法..");
      }
  }

  public class Test02 {
      /**
       ,* 动态代理 - java动态代理
       ,*  优点：代理代码只需要写一遍就可以对多个方法进行代理
       ,*  缺点：基于接口实现代理，如果方法不属于任何接口，则无法代理
       ,*/
      @Test
      public void test02(){
          //被代理者 - 范冰冰
          FBB fbb = new FBB();

          //代理者 - 助理
          Star proxy = (Star) Proxy.newProxyInstance(
                  //类加载器
                  FBB.class.getClassLoader(),
                  //要实现的接口们
                  FBB.class.getInterfaces(),
                  //回调函数 - 代理者执行的逻辑
                  new InvocationHandler() {
                      /**
                       ,* @param proxy 代理者 - 助理
                       ,* @param method 被调用的方法
                       ,* @param args 被调用的方法的参数
                       ,*/
                      @Override
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                          System.out.println("你谁啊？");
                          Object retuObj = method.invoke(fbb, args);
                          System.out.println("记录一下..");
                          return retuObj;
                      }
                  }
          );

          //有事找助理，不能找范冰冰
          proxy.qianming();
          proxy.chifan();
          //proxy.shufa();
      }
#+END_SRC

java动态代理的特点:
- 优点:
  不需要像静态代理一样被代理方法都要实现一遍，而只需要在回调函数中进行处理就可以了，重复代码只需编写一次。
- 缺点:
  java的动态代理是通过代理者实现和被代理者相同的接口来保证两者具有相同的方法的，如果被代理者想要被代理的方法不属于任何接口，则生成的代理者自然无法具有这个方法，也就无法实现对该方法的代理。 所以java的动态代理机制是基于接口进行的，受制于要代理的方法是否有接口的支持。
****** 动态代理 - 第三方包cglib实现的动态代理
CGLIB是第三方提供的动态代理的实现工具，不管有没有接口都可以实现动态代理。CGLIB实现动态代理的原理是生成的动态代理是被代理者的子类，所以代理者具有和父类即被代理者 相同的方法，从而实现代理，这种方式基于继承，不再受制于接口。
1. 导入CGLIB相关包
   之前导入的spring包中就包含了CGLIB
2. 开发CGLIB程序

   #+BEGIN_SRC java
     import org.junit.Test;
     import org.springframework.cglib.proxy.Enhancer;
     import org.springframework.cglib.proxy.MethodInterceptor;
     import org.springframework.cglib.proxy.MethodProxy;
     import java.lang.reflect.Method;

     interface Star{
         public void qianming();
         public void chifan();
     }

     class FBB implements Star{
         public void qianming(){
             System.out.println("fbb签名..");
         }
         public void chifan(){
             System.out.println("fbb吃饭..");
         }
         public void shufa(){
             System.out.println("fbb写书法..");
         }
     }

     public class Test02 {

         /**
          ,* 动态代理 - cglib动态代理
          ,*  优点：基于继承实现代理，无论方法是否属于接口都可以代理
          ,*  缺点：不是java原生的，需要导如第三方包才能使用
          ,*/
         @Test
         public void test03(){
             FBB fbb = new FBB();
             //1.创建增强器
             Enhancer enhancer = new Enhancer();
             //2.指定要实现的接口们，不是必须的
             enhancer.setInterfaces(fbb.getClass().getInterfaces());
             //3.指定父类，必须的
             enhancer.setSuperclass(fbb.getClass());
             //4.指定回调函数
             enhancer.setCallback(new MethodInterceptor() {
                     @Override
                     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable {
                         System.out.println("你谁啊？");
                         Object retObj = method.invoke(fbb,args);
                         System.out.println("记录一下..");
                         return retObj;
                     }
                 });
             //5.创建代理者
             FBB proxy = (FBB) enhancer.create();

             //6.有事找代理，不能直接找FBB
             proxy.qianming();
             proxy.chifan();
             proxy.shufa();
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     import java.lang.reflect.Method;
     import org.junit.Test;
     import org.springframework.cglib.proxy.Enhancer;
     import org.springframework.cglib.proxy.MethodInterceptor;
     import org.springframework.cglib.proxy.MethodProxy;

     public class CglibProxyTest {
         @Test
         public void test01(){
             final FBB fbb = new FBB();
             //1.创建增强器
             Enhancer enhancer = new Enhancer();
             //2.设定接口 -- 此方法要求生成的动态代理额外实现指定接口们 ，单cglib动态代理不是靠接口实现的，所 以可以不设置
             enhancer.setInterfaces(fbb.getClass().getInterfaces());
             //3.设定父类 -- 此处要传入被代理者的类，cglib是通过集成被代理者的类来持有和被代理者相同的方法 的，此方法必须设置
             enhancer.setSuperclass(fbb.getClass());
             //4.设定回调函数 -- 为增强器设定回调函数，之后通过增强器生成的代理对象调用任何方法都会走到此回调 函数中，实现调用真正被代理对象的方法的效果
             enhancer.setCallback(new MethodInterceptor() {
                     @Override
                     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                         if("拍电影".equals(method.getName())){
                             System.out.println("对不起，不拍了~~~"); return null;
                         }else{
                             System.out.println("检查权限。。。");
                             Object returnObj = method.invoke(fbb, args);
                             System.out.println("记录日志。。。");
                             return returnObj;
                         }
                     }
                 });
             //5.创建代理者
             FBB proxy = (FBB) enhancer.create(); proxy.吃();
             //6.有事找代理，不能直接找FBB
             proxy.唱歌();
             proxy.拍电影();
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     import org.junit.Test;
     import org.springframework.cglib.proxy.Enhancer;
     import org.springframework.cglib.proxy.MethodInterceptor;
     import org.springframework.cglib.proxy.MethodProxy;
     import java.lang.reflect.Method;

     interface 动物{
         public void 吃();
         public void 叫();
     }

     class 狗 implements 动物{
         public void 吃(){
             System.out.println("狗在么么么的吃..");
         }
         public void 叫(){
             System.out.println("狗在汪汪汪的叫..");
         }
         public void 看家(){
             System.out.println("狗在看家..");
         }
     }

     public class Test01 {
         /**
          ,* 改造不喜欢的方法 - 代理设计模式 - 动态代理 - cglib动态代理
          ,*/
         @Test
         public void test05(){
             狗 dog = new 狗();
             //1.创建增强器
             Enhancer enhancer = new Enhancer();
             //2.指定要实现接口们 - 不是必须的
             enhancer.setInterfaces(dog.getClass().getInterfaces());
             //3.指定要继承的父类 - 必须的
             enhancer.setSuperclass(dog.getClass());
             //4.指定回调函数
             enhancer.setCallback(new MethodInterceptor() {
                     @Override
                     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable {
                         if("叫".equals(method.getName())){
                             System.out.println("狗在呵呵呵的叫..");
                             return null;
                         }else{
                             Object retObj = method.invoke(dog,args);
                             return retObj;
                         }
                     }
                 });
             //5.创建代理对象
             狗 proxy = (狗) enhancer.create();

             //6.有事找代理，不要找dog
             proxy.吃();
             proxy.叫();
             proxy.看家();
         }
     }
   #+END_SRC

   CGLIB动态代理原理图：

   [[./Img/5.png]]

   CGLIB动态代理的特点:
   - 优点:
     无论是否有接口都可以实现动态代理，使用场景基本不受限
   - 缺点:
     第三方提供的动态代理机制，不是原生的，需要导入第三方开发包才可以使用。
****** 使用代理改造EasyMall
使用代理改造EasyMall，将功能代码提取到代理者中，实现“高内聚”的效果。
1. 静态代理

   #+BEGIN_SRC java
     package cn.tedu.service;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.beans.factory.annotation.Qualifier;
     import org.springframework.stereotype.Service;
     import cn.tedu.domain.User;
     @Service("userService")
     public class StaticProxyUserServiceImpl implements UserService{
         @Autowired
         @Qualifier("userServiceImpl")
         private UserService userService = null;
         @Override
         public void addUser(User user) {
             System.out.println("开启事务...");
             System.out.println("检查权限...");
             System.out.println("addUser访问开始.."+System.currentTimeMillis());
             userService.addUser(user);
             System.out.println("addUser访问结束.."+System.currentTimeMillis());
             System.out.println("提交/回滚事务...");
         }
         @Override
         public User loginUser(String username, String password) {
             System.out.println("开启事务...");
             System.out.println("检查权限...");
             System.out.println("loginUser访问开始.."+System.currentTimeMillis());
             User user = userService.loginUser(username, password);
             System.out.println("loginUser访问结束.."+System.currentTimeMillis());
             System.out.println("提交/回滚事务...");
             return user;
         }
         @Override
         public void logoutUser() {
             System.out.println("开启事务...");
             System.out.println("检查权限...");
             System.out.println("logoutUser访问开始.."+System.currentTimeMillis());
             userService.logoutUser();
             System.out.println("logoutUser访问结束.."+System.currentTimeMillis());
             System.out.println("提交/回滚事务...");
         }
         @Override
         public void updateUser() {
             System.out.println("开启事务...");
             System.out.println("检查权限...");
             System.out.println("updateUser访问开始.."+System.currentTimeMillis());
             userService.updateUser();
             System.out.println("updateUser访问结束.."+System.currentTimeMillis());
             System.out.println("提交/回滚事务...");
         }
     }
   #+END_SRC
2. java动态代理

   #+BEGIN_SRC java
     package cn.tedu.service;
     import java.lang.reflect.InvocationHandler;
     import java.lang.reflect.Method;
     import java.lang.reflect.Proxy;
     import java.util.Arrays;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.beans.factory.annotation.Qualifier;
     import org.springframework.context.annotation.Bean;
     import org.springframework.stereotype.Component;
     @Component
     public class JavaProxyUserServiceImplFactory {
         @Autowired
         @Qualifier("userServiceImpl")
         private UserService userService = null;
         @Bean(name="userService")
         public UserService getProxy() {
             UserService proxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),userService.getClass().getInterfaces(),new InvocationHandler() {
                     @Override
                     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                         if(Arrays.asList(UserService.class.getMethods()).contains(method)) { System.out.println("开启事务...");
                             System.out.println("检查权限...");
                             System.out.println(method.getName()+"访问开始.."+System.currentTimeMillis());
                             Object obj = method.invoke(userService, args);
                             System.out.println(method.getName()+"访问结束.."+System.currentTimeMillis()); System.out.println("提交/回滚事务...");
                             return obj; }else {
                             return method.invoke(userService, args); }
                     }
                 });
             return proxy;
         }
     }
   #+END_SRC
3. cglib动态代理：

   #+BEGIN_SRC java
     package cn.tedu.service;
     import java.lang.reflect.Method;
     import java.util.ArrayList;
     import java.util.Arrays;
     import java.util.List;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.beans.factory.annotation.Qualifier;
     import org.springframework.cglib.proxy.Enhancer;
     import org.springframework.cglib.proxy.MethodInterceptor;
     import org.springframework.cglib.proxy.MethodProxy;
     import org.springframework.context.annotation.Bean;
     import org.springframework.stereotype.Component;
     @Component
     public class CglibProxyUserServiceImplFactory {
         @Autowired @Qualifier("userServiceImpl")
         private UserService userService = null;
         @Bean(name="userService") public UserService getProxy() {
             //1.创建增强器
             Enhancer enhancer = new Enhancer();
             //2.配置接口 enhancer.setInterfaces(userService.getClass().getInterfaces()); //3.配置父类
             enhancer.setSuperclass(userService.getClass()); //4.配置回调函数
             enhancer.setCallback(new MethodInterceptor() {
                     @Override
                     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable {
                         List<String> mlist = new ArrayList<String>(); for(Method m : UserService.class.getMethods()) {
                             mlist.add(m.getName());
                         }
                         if(mlist.contains(method.getName())) {
                             System.out.println("开启事务...");
                             System.out.println("检查权限...");
                             System.out.println(method.getName()+"访问开始.."+System.currentTimeMillis());
                             Object obj = method.invoke(userService, args);
                             System.out.println(method.getName()+"访问结束.."+System.currentTimeMillis());
                             System.out.println("提交/回滚事务...");
                             return obj; }else {
                             return method.invoke(userService, args);
                         }
                     }
                 });
             //5.生成代理
             UserService proxy = (UserService) enhancer.create();
             return proxy;
         }
     }
   #+END_SRC

***** SpringAOP详解
****** Spring aop中的基本概念
1. 连接点(Joinpoint):
   在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的 时候。在Spring AOP中，一个连接点总是表示一个方法的执行。
   - 通俗讲:
     层于层之间调用的过程中，目标层中可供调用的方法，就称之为连接点。
2. 切入点(Pointcut):
   匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行(例如，当执行某个特定名称的方法时)。切入点表达式如何和连接点匹配是AOP的核心:Spring缺省使用AspectJ切入点语法。
   - 通俗讲:
     在连接点的基础上增加上切入规则 选择出需要进行增强的连接点 这些基于切入规则选出来的 连接点 就称之为切入点。
3. 切面(Aspect):
   一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在SpringAOP中，切面可以使用基于模式)或者基于@Aspect注解的方式来实现。
   - 通俗讲:
     + 狭义上就是当spring拦截下切入点后 将这些切入点交给处理类进行功能的增强，这个处理类就称之为切面。
     + 广义上来讲将spring底层的代理切入点和处理类加在一起实现的对层与层之间调用过 程进行增强的机制称之为切面。
4. 通知(Advice):
   在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知(通知的类型将在后面部分进行讨论)。许多AOP框架(包括Spring)都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。
   - 通俗讲:
     在spring底层的代理拦截下切入点后，将切入点交给切面类，切面类中就要有处理这些切入点的方法，这些方法就称之为通知(也叫增强增强方法)。针对于切入点执行的过程， 通知还分为不同的类型，分别关注切入点在执行过程中的不同的时机。
5. 目标对象(Target Object):
   被一个或者多个切面所通知的对象。也被称做被通知(advised)对象。既然SpringAOP是通过运行时代理实现的，这个对象永远是一个被代理(proxied)对象。既然SpringAOP是通过运行时代理实现的，这个对象永远是一个被代理(proxied)对象。
   - 通俗讲:
     就是真正希望被访问到的对象。spring底层的动态代理对他进行了代理，具体能不能真的访问到目标对象，或在目标对象真正执行之前和之后是否做一些额外的操作，取决于切面
   [[./Img/6.png]]
****** spring的aop入门案例
1. 导入aop相关开发包
2. 创建配置文件，并导入aop约束
3. 创建基本的层级结构调用过程
4. 创建一个切面类
5. 定义通知
6. 配置切面、通知、切入点规则
7. 执行方法，发现切面确实起作用
#+BEGIN_SRC html
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="
         http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         https://www.springframework.org/schema/context/spring-context.xsd
         http://www.springframework.org/schema/aop
         http://www.springframework.org/schema/aop/spring-aop.xsd
  ">
      <!-- 开启包扫描 -->
      <context:component-scan base-package="cn.tedu.service"></context:component-scan>
      <context:component-scan base-package="cn.tedu.web"></context:component-scan>
      <context:component-scan base-package="cn.tedu.aspect"></context:component-scan>
      <!-- 开启注解方式DI -->
      <context:annotation-config/>
      <!-- 配置切面 -->
      <aop:config>
          <aop:aspect ref="firstAspect">
              <aop:before method="myFirst" pointcut="within(cn.tedu.service.UserServiceImpl)"></aop:before>
          </aop:aspect>
      </aop:config>
  </beans>
#+END_SRC
#+BEGIN_SRC java
  package cn.tedu.aspect;

  import org.springframework.stereotype.Component;

  @Component
  public class FirstAspect {
      public void myFirst(){
          System.out.println("first...");
      }
  }

#+END_SRC
****** 切入点表达式
1. within表达式
   通过类名进行匹配，粗粒度的切入点表达式；within(包名.类名)，则这个类中的所有的连接点都会被表达式识别，成为切入点。
   #+BEGIN_SRC html
     <aop:pointcut expression="within(cn.tedu.service.UserServiceImpl)" id="pc01" />
   #+END_SRC
   1. 在within表达式中可以使用*号匹配符，匹配指定包下所有的类，注意，只匹配当前包，不包括 当前包的子孙包。

      #+BEGIN_SRC html
        <aop:config>
          <!-- 配置切入点 -->
          <aop:pointcut expression="within(cn.tedu.service.*)" id="pc01"/>
          <!-- 配置切面 -->
          <aop:aspect ref="firstAspect">
            <aop:before method="before" pointcut-ref="pc01"/>
          </aop:aspect>
        </aop:config>
      #+END_SRC
   2. 在within表达式中也可以用*号匹配符，匹配包

      #+BEGIN_SRC html
        <aop:config>
          <!-- 配置切入点 -->
          <aop:pointcut expression="within(cn.tedu.service.*.*)" id="pc01"/>
          <!-- 配置切面 -->
          <aop:aspect ref="firstAspect">
            <aop:before method="before" pointcut-ref="pc01"/>
          </aop:aspect>
        </aop:config>
      #+END_SRC
   3. 在within表达式中也可以用..*号匹配符，匹配指定包下及其子孙包下的所有的类

      #+BEGIN_SRC html
        <aop:config>
          <!-- 配置切入点 -->
          <aop:pointcut expression="within(cn.tedu.service..)" id="pc01"/>
          <!-- 配置切面 -->
          <aop:aspect ref="firstAspect">
            <aop:before method="before" pointcut-ref="pc01"/>
          </aop:aspect>
        </aop:config>
      #+END_SRC
2. execution()表达式
   细粒度的切入点表达式，可以以方法为单位定义切入点规则
   - 语法：
     execution(返回值类型 包名.类名.方法名(参数类型,参数类型...))
   1. 例子1

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(void cn.tedu.service.UserServiceImpl.addUser(java.lang.String)) id=pc1"/>
     #+END_SRC
   2. 例子2

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(* cn.tedu.service.*.query()) id=pc1"/>
     #+END_SRC
     该切入点规则表示，切出指定包下所有的类中的query方法，要求无参，但返回值类型不限。
   3. 例子3

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(* cn.tedu.service..*.query())" id="pc1"/>
     #+END_SRC
     该切入点规则表示，切出指定包及其子孙包下所有的类中的query方法，要求无参，但返回值类型不限。
   4. 例子4

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(* cn.tedu.service.. *.query(int,java.lang.String))" id="pc1"/>
     #+END_SRC
     该切入点规则表示，切出指定包及其子孙包下所有的类中的query方法，要求参数为int java.langString类型，但返回值类型不限。
   5. 例子5

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(* cn.tedu.service..*.query(..))" id="pc1"/>
     #+END_SRC
     该切入点规则表示，切出指定包及其子孙包下所有的类中的query方法，参数数量及类型不限，返回值类型不限。
   6. 例子6

     #+BEGIN_SRC html
       <aop:pointcut expression="execution(* cn.tedu.service..*.*(..))" id="pc1"/>
     #+END_SRC
     该切入点规则表示，切出指定包及其子孙包下所有的类中的任意方法，参数数量及类型不限，返回值类型不限。这种写法等价于within表达式的功能。
****** Spring的五大通知类型
1. 前置通知
   在目标方法执行之前执行执行的通知，前置通知方法，可以没有参数，也可以额外接收一个JoinPoint，Spring会自动将该对象传入，代表当前的连接点，通过该对象可以获取目标对象和目标方法相关的信息。注意，如果接收JoinPoint，必须保证其为方法的第一个参数，否则报错。
2. 环绕通知
   在目标方法执行之前和之后都可以执行额外代码的通知。在环绕通知中必须显式的调用目标方法，否则目标方法不会执行。这个显式调用是通过ProceedingJoinPoint来实现的，可以在环绕通知中接收一个此类型的形 参，spring容器会自动将该对象传入，这个参数必须处在环绕通知的第一个形参位置。
   - ProceedingJoinPoint时JoinPoint的子类，要注意，只有环绕通知可以接收 ProceedingJoinPoint，而其他通知只能接收JoinPoint。
   环绕通知需要返回返回值，否则真正调用者将拿不到返回值，只能得到一个null。
环绕通知有控制目标方法是否执行、目标方法执行之前或之后执行额外代码、控制是否返回返回值、改变返回值的能力
环绕通知虽然有这样的能力，但一定要慎用，要小心不要破坏了软件分层的“高内聚 低耦合” 的目标。
3. 后置通知
   在目标方法执行之后执行的通知。 在后置通知中也可以选择性的接收一个JoinPoint来获取连接点的额外信息，但是这个参数必须 处在参数列表的第一个。
4. 异常通知
   在目标方法抛出异常时执行的通知
5. 最终通知
**** MyBatis
