<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>函数</title>
	<!--
		js中函数有三种定义方式：
			普通定义方式：
				function mx(n1,n2){return n1+n2}
			动态函数定义：
				new Function("n1","n2","return n1+n2")
			匿名函数定义
				var mx = function(n1,n2){return n1+n2}
		js中的函数本质上是一个对象，函数名只是指向这个函数的一个引用，和其他对象唯一的不同是可以通过指向函数的引用传入参数调用
		我们可以使用其他应用也指向这个函数，从而使该引用调用函数，也可以将函数名指向其他内容（null），是函数名不再指向函数，失去调用的能力。
		可以像一个普通对象一样，被赋值给其他变量。
		可以像一个普通的对象一样当做一个函数的参数传递或当做另一个函数的返回值返回。
	-->
</head>
<body>
	<script type="text/javascript">
		//1.函数定义 -- 普通函数
		/*function sum1(num1,num2){
			return num1+num2;
		}
		console.log(sum1(2,3));
		console.log(sum1(2,3,1));
		console.log(sum1(2));
		function a(num1,num2){
			alert(arguments.length);
		}
		a(1,1,1,1,1,1,1);*/
		//2.函数定义 -- 动态函数定义
		/*function fun1(num1,num2){return num1+num2;}
		var fun1 = new Function("num1","num2","return num1+num2");
		console.log(fun1(2,3));
		var fun2 = fun1;
		console.log(fun2(2,3));
		//3.函数定义 - 函数直接量(匿名函数)定义
		var fun1 = function(num1,num2){return num1+num2;}*/
		//3.
		/*function eat(food){
			if("羊肉串"==food){
				food = "烤熟"+food;
			}else if("涮羊肉" == food){
				food = "煮熟"+food；
			}
			console.log("吃"+food);
		}
		eat("羊肉串");*/
		/*function eat(food,cookFunc){
			food = cookFunc(food)
			console.log("吃"+food);
		}
		function cookYRC(food){
			return "烤熟"+food
		}
		eat("羊肉串",cookYRC);
		eat("涮羊肉",new Function("food","return '煮熟的'+food"));
		eat("狗不理",function(food){return "蒸熟的"+food});*/
		//函数作为另一个函数的参数传递
		function lookUpCookBook(food){
			if("羊肉串" == food){
				function cookYRC(food){
					return "烤熟的"+food
				}
				return cookYRC;
			}else if("涮羊肉" == food){
				return new Function("food","return '煮熟的'+food")
			}else if("狗不理" == food){
				return new Function("food","return '蒸熟的'+food")
			}
		}
		var cfunc1 = lookUpCookBook("羊肉串");
		console.log(cfunc1("羊肉串"));
		var cfunc2 = lookUpCookBook("涮羊肉");
		console.log(cfunc2("涮羊肉"));
		var cfunc3 = lookUpCookBook("狗不理");
		console.log(cfunc3("狗不理"));
	</script>
</body>
</html>