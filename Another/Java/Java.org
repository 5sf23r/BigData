* 面向对象
** 面向对象简介
*** 面向对象与面向过程的比较
*** 类与对象的关系
*** 对象的内存处理
** 基本概念
*** 成员变量和局部变量
成员变量又叫属性

|--------------+------------------------------+------------------------------------|
| 区别         | 成员变量                     | 局部变量                           |
| 定义位置     | 定义在类中方法外             | 定义在方法或者语句中               |
| 作用范围     | 整个类中                     | 对应的方法或者语句中               |
| 内存位置     | 存储在堆内存中               | 存储在占内存中                     |
|              | 并且在堆内存中被赋予了默认值 | 而且没有默认值需要手动给定数据     |
| 生命周期     | 在对象创建的时候创建         | 在方法或者语句执行的时候创建       |
|              | 在对象被笑会的时候销毁       | 方法或者语句执行完成之后销毁       |
| ------------ | --------------------------   | ---------------------------------- |
*** 匿名对象
匿名对象就是指没有名字的对象
- 注意事项
  1. 因为匿名对象没有名字，所以只能在创建的时候使用一次
  2. 匿名对象可以作为参数进行传递
  3. 匿名对象如果没有作为参数传递，那么在栈内存中是没有引用的
#+BEGIN_SRC java
package cn.commandoptionesc;

public class StudentDemo{
    public static void main(String[] args){

        //创建乐意个Student对象
        //注意：像这种没有名字的对象称之为匿名对象
        new Student().play();

        //new几次，就会创建几个对象，几个对象的地址是不一样的
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());

        //匿名对象可以作为参数进行传递
        printName(new Student());
    }

    public static void printName(Student s){
        System.out.println(s.name);
    }
}


//定义一个类表示学生
class Student{
    //姓名、年两、性别、班级、学号
    //属性：成员变量
    String name;
    int age;
    byte gender;
    String grade;
    String no;

    //定义方法表示“学习”行为
    //定义在方法中的变量成为局部变量
    public void study(String subject){

        System.out.println(name + "在学习" + subject);
    }

    //定义方法表示"吃"行为
    public void eat(String food){

        System.out.println(name + "再吃" + food);
    }

    //定义方法表示"玩耍"行为
    public void play(){

        System.out.println(name + "在玩耍");
    }
}
#+END_SRC
*** 构造方法
1. 类中存在的方法名与类名一致而没有返回值类型的方法
2. 作用
   - 构造方法最主要的作用是用于创建对象

   - 可以在构造方法中对属性进行初始化，或者执行其他一些初始化的操作
3. 如果在类中没有手动给定狗仔方法，那么在编译的时候会自动添加一个默认的无参构造
4. 如果一个类中手动添加了构造方法，那么在编译的时候就不会再添加无参的构造方法
5. 构造方法虽然没有返回值类型，但是可以有return语句，其作用是避免一些不合常理的数据被赋值给属性
6. 构造方法可以进行重载
   #+BEGIN_SRC java
   public class DriverDemo{
       //创建Driver
       //构造方法、构造函数
       //这个类目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
       Driver d = new Driver("Amy",19.(byte)0);
       //当提供了无参构造，那么意味着可以利用无参构造创建对象
       Driver d2 = new Driver();
   }
   class Driver{
       String name;
       int age;
       byte gender;
       //驾照号
       String no;

       //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
       //与类同名，但是没有返回值类型
       //利用new关键字来调用构造方法，利用构造方法来创建对象
       public Driver(){
       }

       //定义一个含参构造
       //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
       public Driver(String n,int a,byte g){
           name = n;
           age = a;
           gender = g;
       }
   }
   #+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc;

public class DriverDemo{
    public static void main(String[] args){
    //创建Driver
    //构造方法、构造函数
    //这个类目目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
    Driver d = new Driver("Amy",15,(byte)0);
    //当提供了无参构造，那么意味着可以利用无参构造创建对象
    Driver d2 = new Driver();
    }
}

class Driver{
    String name;
    int age;
    //驾照号
    String no;

    //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
    //与类同名，但是没有返回值类型
    //利用new关键字来调用构造方法，利用构造方法来创建对象
    public Driver(){
    }

    //定义一个含参构造
    //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
    public (Driver(String n,int a,byte g)){
        if(a<18){
            System.out.println("年龄不合法，死机的最小年龄应该是18");
            //可以利用利用return来规避不合理的值，结构构造方法
            return;
        }
        name = n;
        age = a;
        gender = g;
    }
}
#+END_SRC
*** this关键字
1. 因为在java中所有的非静态的方法和属性都是通过对象来调用的，而在本类中如果想调用本类中的方法和属性，并没有本类的对象，所以要用到this来代表当前类的对象，来调用属性和方法
2. this代表本类在活动的对象的引用，可以认为是一个虚拟对象，用于在类内调用本类中的非静态方法和被静态属性
3. this()语句表示在本类的构造方法中调用本类其他形式的构造方法。需要注意的是，this语句必须放在构造方法的第一行
#+BEGIN_SRC java
package cn.commandoptionesc.thisx;

public class ThisDemo{

    //static修饰的属性或者方法就是静态的
    public static void main(Stringp[] args){


        //活跃的对象是s1，所以this代表s1
       Student s1 = new Student("Bob");
       System.out.println(s1.name);
       //此时，活跃的对象是s2，所以this代表s2
       Student s2 = new Student("Alex");
       //活跃的对象又变成s1，所以this代表s1
       s1.age = 15;
    }
}
class Student{
    //姓名
    String name;
    //年龄
    ing age;
    //性别
    byte gender;
    //学号
    String no;

    //在Java中，当出现变量名一致的时候，采取就近原则来使用
    //在Java中，所有的非静态属性哈非静态方法都是通过对象来调用的
    //在类中用this代替当前活跃的对象来调用属性或者方法
    public Student(String name){
        this,name = name;
    }
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    public Student(String name,int age,byte gender){
        //this.name = name;
        //this.age = age;
        //表示滴啊用Student(String,int)
        this(name,age);
        this.gender = gender;
    }
    public Student(String name,int age,byte gender,String no){
        //this.name = name;
        //this.age = age;
        //this.gender = gender;

        //this语句
        //会自动调用本类中符合形式的构造方法
        //this(String,int,byte)--自动找--->Student(name,age,byte);
        //this语句必须在构造方法的第一行
        this(name,age,gender);
        this.no = no;
    }
}
#+END_SRC
*** 构造代码块
**** 构造代码块
1. 所谓构造代码块是指定义在类内用{}包起来的代码，也称之为是初始化代码块
2. 无论调用哪个构造方法，构造代码块都会执行
3. 构造代码块是在创建对象的时候先与构造方法执行
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class ConstructorCodedemo{
    public static void main(String[] args){
        new Baby();
        new Baby("helen");
    }
}

//定义一个类表示婴儿
class Baby{
    String name;
    //在类中用{}括起来的代码称之为构造代码快或者叫初始化代码块
    //无论调用哪个构造方法，这个代码块都会执行
    //构造代码块是先于构造方法执行的
    {
        this.cry();
        this.eat();
    }

    public Baby(){
    }

    public Baby(String name){
        System.out.println("~~~~~~~");
        this.name = name;
    }

    public void cry(){
        System.out.println("这个婴儿在哭");
    }

    public void eat(){
        System.out.println("这婴儿再吃");
    }
}
#+END_SRC
**** 局部代码块
1. 所谓局部代码块，是指定义在方法中用{}包起来的代码
2. 作用是限制变量的生命周期从而提高栈内存的利用率
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class LocalCodeDemo{
    public static void main(String[] args){

        //在方法中用{}括起来的代码称之为局部代码块
        {
            //限制了变量的使用范围，缩短了变量的生命周期
            //提高了栈内存的利用率
            int j = 5;
            int i = 7;
            System.out.println(i+j);
        }
        System.out.println("running");
    }
}
#+END_SRC
*** 权限修饰符
1. 使用范围
   |-----------+--------+----------------+----------+----------|
   | 关键字    | 本类中 | 子类中         | 同包类中 | 其他类中 |
   |-----------+--------+----------------+----------+----------|
   | public    | 可以   | 可以           | 可意     | 可以     |
   | protected | 可以   | 可意           | 可以     | 不可以   |
   | 默认      | 可以   | 同包子类中可以 | 可意     | 不可以   |
   | private   | 可以   | 不可以         | 不可以   | 不可以   |
   |-----------+--------+----------------+----------+----------|
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   public class PrivateDemo {
       public static void main(String[] args) {
           Person p = new Person();
           p.setName("amy");
           p.setAge(17);
           System.out.println(p.getAge());
           System.out.println(p.getName());
       }
   }

   //定义一个代表人的类
   class Person{

       private String name;
       //私有
       private int age;

       //提供一个方法，将要赋值的属性作为参数
       public void setAge(int age){
           if(age < 0 || age >= 150)
               return;
           this.age = age;
       }

       public int getAge(){
           return this.age;
       }

       public void setName(String name){
           this.name = name;
       }

       public String getName(){
           return this.name;
       }
   }
   #+END_SRC
2. 注意事项
   - 限制修饰符的范围是public > protected > 默认 > private

   - 需要注意的是，默认的权限修饰符只能在本类中以及同包类中使用，同包子类本质上也是同包类

   - protected在子类中使用指的是在对应的子类中使用，跨子类是不能使用的
* 面向对象的特征
** 封装
1. 封装是面向对象方法的重要原则，就是把对象的属性和方法（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。封装是一种信息隐藏技术。
2. 形式
   a. 方法，其实是封装的一种常见的形式，通过将某段常用的逻辑进行提取从而形成一种新的形式。
   b. 属性的私有化，在类中定义了属性之后，如果允许在类外直接操作属性会导致用户直接给属性赋予一些不合常理的数据。将属性私有化，将属性用private修饰，然后提供对外的访问（getXXX）和设置（setXXX）的方法，在方法中进行限定，使属性值更加符合的场景要求。
   c. 内部类，内部类作为封装的一种形式，是为了让代码的结构更加的紧凑
3. 作用
   a. 提高了复用性（降低了代码的冗余度）、安全性、使代码结构更加紧密
   b. 使属性私有化 - 隐藏信息，实现细节
   c. 使属性值更符合要求 - 可以对成员进行更精准的控制
   d. 提高了代码的安全性 - 类内部的结构可以自由修改
   e. 良好的封装能够减少耦合
** 继承
1. 如果一些类中的属性和方法是相同的，那么可以把这些类中相同的属性和方法提取到一个新的类中，然后利用extends关键字让原来的类和行的类产生练习，这种练习称之为继承。而这个时候原来的类称之为是子类，新的类称之为父类
2. 注意事项
   - Java中支持的是类和类之间的'单继承'，即一个子类只能有一个父类，但是一个父类可以有多个子类。
   - 通过继承，子类可以继承父类全部的数据域，但是只有一部分数据域对子类可见，所以子类也只能使用这一部分可见的数据域
3. 单继承与多继承的比较
   - 多继承在代码的复用性上要优于单继承，但是存在方法调用的混乱
   - 单继承也可以提高代码的复用性，可以避免方法调用的混乱，提高了方法调用的安全性
4. 特征
   - 继承关系是传递的
   - 继承简化了人们对事物的认识和描述，能清晰的体现相关类间的层次结构关系
   - 继承提高了代码的复用性
   - 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性
5. 优点
   - 提高复用性
   - 提高安全性，避免方法调用产生混乱
   - 统一结构
6. 方法的重写
   - 子类里存在了方法签名（方法名+参数列表）完全一致的非静态方法，就构成了方法的重写（覆盖）
   - 子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要曹勇方法的重写，方法重写又称方法覆盖
   - 遵循原则：方法的重写需要遵循“两等两小一大”的原则：
     + 方法签名要求完全一致
     + 如果父类里的返回值是基本数据类型/void/最终类，那么子类里重写的返回值类型必须一致（如果父类的方法是private的话，子类是无法被继承的，即使子类重新定义这个方法，也不算重写）
     + 如果父类方法的返回值类型是一个引用类型，子类方法的返回值类型是父类方法的返回值类型的子类
        #+BEGIN_SRC java
        public class ex{
            public static void main(String[] args){
            }
        }
        class Pet{}
        class Dog extends Pet{}

        class A{
            public Pet m(){}
        }
        class B extends A{
            //public Pet m(){}
            public Dog m(){}
        }
        #+END_SRC
     + 子类方法的权限修饰符的范围要大于等于父类方法权限修饰符的范围，需要注意的是，对于8种基本数据类型之间没有继承关系的，它们是同级关系
        #+BEGIN_SRC java
        public ex2{
            public static void main(String[] args){}
        }
        class A{
            protected void m(){}
        }
        class B extends A{
            //protected void m(){}
            public void m(){}
        }
        #+END_SRC
7. super关键字
   - super表示在子类中对父类对象的引用，可以看做是一个虚拟对象
   - 在子类中可以通过super调用父类中的非讲台方法或者非静态属性
   - 在子类的构造方法中看，可以通过super关键字调用父类中的对应形式的构造方法，如果不指定，默认调用父类的无参构造
   - 如果父类中值提供了含参的构造方法，那么子类的构造方法中必须手动定义super语句来调用父类中的含参构造
   - super语句必须放在狗仔方法的第一行，所以super语句不能同时出现
** 多态
1. 多态是指允许不同类的对象对同意消息做出相应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态主要针对对象的行为及方法，而不是对象的属性。
2. 体现形式：
   - 编译时多态
     在编译时期就要进行动态绑定的行为，主要体现为方法的重载
   - 运行时多态
     + 在运行时期才能确定绑定的运行过程，主要体现形式是向上造型、方法的重写
     + 需要注意的是运行时多态的前提需要产生了继承关系或者实现关系
3. 向上造型
   指的是用父类声明对象而用子类创建对象的行为方式，利用向上造型创建的对象所能使用的属性或者方法需要看的是声明类，而具体怎么执行所调用的方法看的是实现类
4. 作用
   统一结构，实现解耦
