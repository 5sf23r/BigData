* 面向对象
** 面向对象简介
*** 面向对象与面向过程的比较
*** 类与对象的关系
*** 对象的内存处理
** 基本概念
*** 成员变量和局部变量
成员变量又叫属性

|--------------+------------------------------+------------------------------------|
| 区别         | 成员变量                     | 局部变量                           |
| 定义位置     | 定义在类中方法外             | 定义在方法或者语句中               |
| 作用范围     | 整个类中                     | 对应的方法或者语句中               |
| 内存位置     | 存储在堆内存中               | 存储在占内存中                     |
|              | 并且在堆内存中被赋予了默认值 | 而且没有默认值需要手动给定数据     |
| 生命周期     | 在对象创建的时候创建         | 在方法或者语句执行的时候创建       |
|              | 在对象被笑会的时候销毁       | 方法或者语句执行完成之后销毁       |
| ------------ | --------------------------   | ---------------------------------- |
*** 匿名对象
匿名对象就是指没有名字的对象
- 注意事项
  1. 因为匿名对象没有名字，所以只能在创建的时候使用一次
  2. 匿名对象可以作为参数进行传递
  3. 匿名对象如果没有作为参数传递，那么在栈内存中是没有引用的
#+BEGIN_SRC java
package cn.commandoptionesc;

public class StudentDemo{
    public static void main(String[] args){

        //创建乐意个Student对象
        //注意：像这种没有名字的对象称之为匿名对象
        new Student().play();

        //new几次，就会创建几个对象，几个对象的地址是不一样的
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());

        //匿名对象可以作为参数进行传递
        printName(new Student());
    }

    public static void printName(Student s){
        System.out.println(s.name);
    }
}


//定义一个类表示学生
class Student{
    //姓名、年两、性别、班级、学号
    //属性：成员变量
    String name;
    int age;
    byte gender;
    String grade;
    String no;

    //定义方法表示“学习”行为
    //定义在方法中的变量成为局部变量
    public void study(String subject){

        System.out.println(name + "在学习" + subject);
    }

    //定义方法表示"吃"行为
    public void eat(String food){

        System.out.println(name + "再吃" + food);
    }

    //定义方法表示"玩耍"行为
    public void play(){

        System.out.println(name + "在玩耍");
    }
}
#+END_SRC
*** 构造方法
1. 类中存在的方法名与类名一致而没有返回值类型的方法
2. 作用
   - 构造方法最主要的作用是用于创建对象

   - 可以在构造方法中对属性进行初始化，或者执行其他一些初始化的操作
3. 如果在类中没有手动给定狗仔方法，那么在编译的时候会自动添加一个默认的无参构造
4. 如果一个类中手动添加了构造方法，那么在编译的时候就不会再添加无参的构造方法
5. 构造方法虽然没有返回值类型，但是可以有return语句，其作用是避免一些不合常理的数据被赋值给属性
6. 构造方法可以进行重载
   #+BEGIN_SRC java
   public class DriverDemo{
       //创建Driver
       //构造方法、构造函数
       //这个类目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
       Driver d = new Driver("Amy",19.(byte)0);
       //当提供了无参构造，那么意味着可以利用无参构造创建对象
       Driver d2 = new Driver();
   }
   class Driver{
       String name;
       int age;
       byte gender;
       //驾照号
       String no;

       //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
       //与类同名，但是没有返回值类型
       //利用new关键字来调用构造方法，利用构造方法来创建对象
       public Driver(){
       }

       //定义一个含参构造
       //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
       public Driver(String n,int a,byte g){
           name = n;
           age = a;
           gender = g;
       }
   }
   #+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc;

public class DriverDemo{
    public static void main(String[] args){
    //创建Driver
    //构造方法、构造函数
    //这个类目目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
    Driver d = new Driver("Amy",15,(byte)0);
    //当提供了无参构造，那么意味着可以利用无参构造创建对象
    Driver d2 = new Driver();
    }
}

class Driver{
    String name;
    int age;
    //驾照号
    String no;

    //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
    //与类同名，但是没有返回值类型
    //利用new关键字来调用构造方法，利用构造方法来创建对象
    public Driver(){
    }

    //定义一个含参构造
    //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
    public (Driver(String n,int a,byte g)){
        if(a<18){
            System.out.println("年龄不合法，死机的最小年龄应该是18");
            //可以利用利用return来规避不合理的值，结构构造方法
            return;
        }
        name = n;
        age = a;
        gender = g;
    }
}
#+END_SRC
*** this关键字
1. 因为在java中所有的非静态的方法和属性都是通过对象来调用的，而在本类中如果想调用本类中的方法和属性，并没有本类的对象，所以要用到this来代表当前类的对象，来调用属性和方法
2. this代表本类在活动的对象的引用，可以认为是一个虚拟对象，用于在类内调用本类中的非静态方法和被静态属性
3. this()语句表示在本类的构造方法中调用本类其他形式的构造方法。需要注意的是，this语句必须放在构造方法的第一行
#+BEGIN_SRC java
package cn.commandoptionesc.thisx;

public class ThisDemo{

    //static修饰的属性或者方法就是静态的
    public static void main(Stringp[] args){


        //活跃的对象是s1，所以this代表s1
       Student s1 = new Student("Bob");
       System.out.println(s1.name);
       //此时，活跃的对象是s2，所以this代表s2
       Student s2 = new Student("Alex");
       //活跃的对象又变成s1，所以this代表s1
       s1.age = 15;
    }
}
class Student{
    //姓名
    String name;
    //年龄
    ing age;
    //性别
    byte gender;
    //学号
    String no;

    //在Java中，当出现变量名一致的时候，采取就近原则来使用
    //在Java中，所有的非静态属性哈非静态方法都是通过对象来调用的
    //在类中用this代替当前活跃的对象来调用属性或者方法
    public Student(String name){
        this,name = name;
    }
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    public Student(String name,int age,byte gender){
        //this.name = name;
        //this.age = age;
        //表示滴啊用Student(String,int)
        this(name,age);
        this.gender = gender;
    }
    public Student(String name,int age,byte gender,String no){
        //this.name = name;
        //this.age = age;
        //this.gender = gender;

        //this语句
        //会自动调用本类中符合形式的构造方法
        //this(String,int,byte)--自动找--->Student(name,age,byte);
        //this语句必须在构造方法的第一行
        this(name,age,gender);
        this.no = no;
    }
}
#+END_SRC
*** 构造代码块
**** 构造代码块
1. 所谓构造代码块是指定义在类内用{}包起来的代码，也称之为是初始化代码块
2. 无论调用哪个构造方法，构造代码块都会执行
3. 构造代码块是在创建对象的时候先与构造方法执行
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class ConstructorCodedemo{
    public static void main(String[] args){
        new Baby();
        new Baby("helen");
    }
}

//定义一个类表示婴儿
class Baby{
    String name;
    //在类中用{}括起来的代码称之为构造代码快或者叫初始化代码块
    //无论调用哪个构造方法，这个代码块都会执行
    //构造代码块是先于构造方法执行的
    {
        this.cry();
        this.eat();
    }

    public Baby(){
    }

    public Baby(String name){
        System.out.println("~~~~~~~");
        this.name = name;
    }

    public void cry(){
        System.out.println("这个婴儿在哭");
    }

    public void eat(){
        System.out.println("这婴儿再吃");
    }
}
#+END_SRC
**** 局部代码块
1. 所谓局部代码块，是指定义在方法中用{}包起来的代码
2. 作用是限制变量的生命周期从而提高栈内存的利用率
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class LocalCodeDemo{
    public static void main(String[] args){

        //在方法中用{}括起来的代码称之为局部代码块
        {
            //限制了变量的使用范围，缩短了变量的生命周期
            //提高了栈内存的利用率
            int j = 5;
            int i = 7;
            System.out.println(i+j);
        }
        System.out.println("running");
    }
}
#+END_SRC
*** 权限修饰符
1. 使用范围
   |-----------+--------+----------------+----------+----------|
   | 关键字    | 本类中 | 子类中         | 同包类中 | 其他类中 |
   |-----------+--------+----------------+----------+----------|
   | public    | 可以   | 可以           | 可意     | 可以     |
   | protected | 可以   | 可意           | 可以     | 不可以   |
   | 默认      | 可以   | 同包子类中可以 | 可意     | 不可以   |
   | private   | 可以   | 不可以         | 不可以   | 不可以   |
   |-----------+--------+----------------+----------+----------|
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   public class PrivateDemo {
       public static void main(String[] args) {
           Person p = new Person();
           p.setName("amy");
           p.setAge(17);
           System.out.println(p.getAge());
           System.out.println(p.getName());
       }
   }

   //定义一个代表人的类
   class Person{

       private String name;
       //私有
       private int age;

       //提供一个方法，将要赋值的属性作为参数
       public void setAge(int age){
           if(age < 0 || age >= 150)
               return;
           this.age = age;
       }

       public int getAge(){
           return this.age;
       }

       public void setName(String name){
           this.name = name;
       }

       public String getName(){
           return this.name;
       }
   }
   #+END_SRC
2. 注意事项
   - 限制修饰符的范围是public > protected > 默认 > private

   - 需要注意的是，默认的权限修饰符只能在本类中以及同包类中使用，同包子类本质上也是同包类

   - protected在子类中使用指的是在对应的子类中使用，跨子类是不能使用的
** 基本概念2
*** static
1. static本身是一个修饰符，可以修饰变量、方法、内部类、代码块
2. 静态是从类的层面来看的，已经超越了对象
**** 静态变量：
用static修饰变量那么这个变量我们就称之为静态变量，有称之为成员变量或者类变量
1.静态变量随着类的加载而加载到了方法区中的静态区，并且静态区中自动赋予一个默认值。静态变量优先于对象而存在，所以静态变量可以通过类名来调用，也可以通过对象来调用。该类产生的所有的对象实际上存的是该静态变量在静态区中的地址，静态变量是被所有对象所共享的
2. 实际过程中，如果某些特征是所有属性共有的特征，例如一个班级的学生，那么这个时候班级这个属性就是所有学生共有的，那么此时这个属性就可以设置为静态的
3. 静态内存流程
   [[./Img/1.png]]
   [[./Img/10.png]]
#+BEGIN_SRC java
package cn.commandoptionesc.staticx;

public class StaticDemo {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.name = "Bob";
        s1.age = 15;
        s1.grade = "四年级";

        Student s2 = new Student();
        s2.name = "Alex";
        s2.age = 16;
        s2.grade = "五年级";

        s1.toStr();
        s2.toStr();
    }
}

class Student{
    String name;
    int age;
    static String grade;

    public void toStr(){

        System.out.println(name + "\t" + age + "\t" + grade);
    }
}
#+END_SRC
**** 静态方法：
用static修饰的方法就叫做静态方法，也叫类方法
1. 在类加载的时候加载到了方法区中的静态区，只是存储在静态区，在方法被调用的时候到栈内存中执行。静态区中的元素不归属于某一个对象而是归属于类。静态方法优先于对象而存在的，所以静态方法可以通过类名来调用，也可以通过对象来调用,实际过程中静态方法一般是通过类名来调用。例如：Arrays.sort()，Arrays是一个类，sort是一个方法，通过类名来调用
2. 静态变量不可以定义到静态方法中。静态方法在方法区中只存储不执行，当被调用的时候才在栈中执行。而静态变量是根据类的加载而加载，上来就要进行初始化--- 所有的静态元素都是定义在类中
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo {
       public static void main(String[] args) {

       //静态变量要求在类加载的时候就得初始化，静态方法是在调用的时候才执行初始化
       //Modifier "static" not allowed here
       //static int i = 5;
       }
   }
   #+END_SRC
3. 静态方法中不可以直接调用本类中的非静态方法。在Java中所有非静态方法和非静态属性都是通过对象来调用的，静态方法是优先于对象存在的，也就意味着静态方法执行的时候可以没有对象。也因此在静态方法中不可以使用this和super。super与this都是和对象是想关联的，而静态优先于对象而存在。
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo {
       public static void main(String[] args) {

           Student s1 = new Student();
           s1.name = "Bob";

           //Non-static method 'printName(cn.commandoptionesc.staticx.Student)' cannot be referenced from a static context
           //printName(s1);
           //this.printName(s1);
       }
       public void printName(Student s){
           System.out.println(s.name);
       }
   }

   class Student{
       String name;
   }
   #+END_SRC
4. 静态方法可以重载。重载对修饰符没有要求的，对返回值也没有要求
5. 静态方法不可以重写（方法的覆盖）
   静态方法可以存在方法签名完全一致的静态方法，这不是重写，称之为隐藏。但是也适用于重写的那套规则。
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo2 {
       public static void main(String[] args) {
           /*
           a调用m方法应该打印"B running"
           但打印的是"A runnimg"
           所以不是重写
           StaticMethodA a = new StaticMethodB();
           a.m();
           */
       }
   }

   class StaticMethodA{
       public static void m(){
           System.out.println("A running");
       }
   }

   class StaticMethodB extends StaticMethodA{
       /*
       加上@Override报错：Method does not override method from its superclass
       @Override
       */

       //如果父子类中存在了方法签名完全一致的非静态方法，称之为隐藏(hide)
       //如果父子类中存在了方法签名完全一致的方法，要么都是静态的，要么都是非静态的
       public static void m(){
           System.out.println("B running");
       }
   }
   #+END_SRC
6. 注意：如果父子类中存在方法签名相同的方法要么都是普通的方法，要么都是静态方法
**** 静态代码块
1. 在类中用static修饰用{}括起来的代码块
2. 静态代码块针对的是类，所以也可以叫做类代码块
3. 实际上静态代码块是随着类的加载而加载到方法区，在类创建对象或者执行方法之前执行一次，终其一生只执行一
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo3 {
       public static void main(String[] args) {
           //静态代码块只在类加载的时候执行一次，因为累值加载一次，所以静态代码块也只执行一次
           new A();
           new A();
       }
   }

   class A {

       //静态代码块
       static{
           System.out.println("A");
       }
   }
   #+END_SRC
4. 执行顺序：
   在这个类第一次被真正使用（第一次创建对象/调用方法）的时候执行一次。如果一个类包含多个静态代码块，则按照书写顺序执行。由于类只在第一次使用的时候加载，所以静态代码块也只执行一次。
   #+BEGIN_SRC java
   /*
   A1 A2 A3 A2 A3
   */
   public class ex4{
       public static void main(String[] args){
           new A();
           new A();
       }
   }
   class A{
       //静态代码块
       static{
           System.out.println("A 1");
       }

       {
           System.out.println("A 2");
       }

       public A(){
           System.out.println("A 3");
       }
   }
   #+END_SRC
5. 代码块执行顺序：
   先父类后子类，先静态后动态。（先父子类的静态，后子类的动态）静态优先，父类优先;

   代码是从上到下，从左到右一次编译执行：
   创建子类对象的时候需要先：创建父类对象 ---> 加载父类 ---> 执行父类静态代码块 ---> 执行子静态代码块 ---> 父类构造函数 ---> 子类构造代码块 ---> 子类构造函数
   试图加载B类，但是准备加载B类的时候发现B有父类A，所以先加载A类，执行A中的静态代码块，A类加载完成之后在加载B类，执行B中的静态代码块。试图创建B对象的时候，会先利用super语句创建一个A类对象，然后在创建B类对象
   #+BEGIN_SRC java
   /*
   new B();
   A1 B1 A2 A3 B2 B3

   new B();
   new B();
   A1 B1 A2 A3 B2 B3 A2 A3 B2 B3
   */
   public class ex4{
       public static void main(String[] args){
           new B();
           new B();
       }
   }
   class A{
       //静态代码块
       static{
           System.out.println("A 1");
       }

       {
           System.out.println("A 2");
       }

       public A(){
           System.out.println("A 3");
       }
   }
   class B extends A{
       static{
           System.out.println("B 1");
       }

       {
           System.out.println("B 2");
       }
       public B(){
           System.out.println("B 3");
       }
   }
   #+END_SRC

*** final
1. 常量
   当final修饰数据（基本类型和引用类型）的时候，表示这个变量的值不可变，称之为常亮。终其一生只能赋值一次。在Java中所说的常量往往是指静态常量。因为实质上只有静态常量才是独有的一个。
   - 特点：
     + 常量在定义好之后不可改变，final固定的是栈内存中的数值
     + 常量可以作为参数传递，传递之后是否还是一个常量要看接收的方法中是否定义为一个常量
     + 对引用类型而言，final固定的是其在栈中的地址不可变。例如：数组在栈内存中存储的是地址，用final修饰，是不能改变数组的地址，但数组的值可以改变。对于对象而言，对象的引用不能改变，但是应用的属性值是可以进行改变的。
     + 成员常量只要是在对象创建完之前（构造方法/函数执行结束之前）赋初始值即可
     + 静态成员变量（static final）只要在类加载完成之前给值即可，而且只能在静态代码块中赋值
2. 最终方法
   - final修饰方法的时候，这个方法就是最终方法
   - 特点：
     + 最终方法不可以被重写也不能被隐藏，可以重载，可以被继承
     + 静态方法可以被final修饰
3. 最终类
   - final修饰的类称之为最终类
   - 特点：
     + 最终类不可以被继承，也不能有匿名内部类形式。
     + 由于最终类不能被继承，一次重写也是不可以的。
*** abstract
1. 抽象类
   - 将一些名称一致但是细节不同的行为提取到父类中定义为抽象方法，抽象方法所在的类就是抽象类，用abstract来修饰的类
   - 抽象类中，不一定含有抽象方法，但是抽象方法所在的类一定是抽象类
   - 抽象类不可以在Java中创建/实例化。即使没有抽象方法也无法创建对象，可以创建匿名内部类
   - 抽象类被子类继承之后，必须重写其中的抽象方法，除非子类也是抽象类
   - 抽象类中可以没有抽象方法
   - 抽象类中可以定义一切的属性和方法
   - 抽象类不能用final修饰。最终类不可以是抽象类
2. 抽象方法：
   - 如果所有的子类中存在了一些名称一致而细节不同的方法的时候，这个时候可以在父子类中声明该行为，此时声明行为的时候不需要添加方法体，所以此时该方法就形成了抽象方法，使用abstract修饰
   - 简单来讲：就是在父子类进行继承的时候，子类重写父类的方法但是父类的方法在后续并不打算使用，因此就会将父类的方法的方法体删除声明抽象方法，子类直接重写即可
   - 抽象方法可以和抽象方法重载，也可以和实体方法重载
   - 抽象方法没有方法体
   - 抽象方法不可以被static、final、private修饰，因为final和privat修饰符修饰的方法都不可以被重写；static修饰的方法，优先于对象存在，没有具体对象没有办法加载
   - 抽象方法可以使用默认权限修饰，要求子类必须和父类同包
   - 抽象方法可以被protected权限修饰，要求要么同包要么是子类
*** 接口interface
1. 接口用interface来声明，其中所有方法都为抽象方法，但是从JDK1.8开始，接口中允许存在实体方法
2. 通过implements关键字让接口和类产生联系，这个过程就叫实现
3. 利用接口的向上造型来创建对象，就是接口的多态
4. 接口中方法的abstract关键字可以忽略
5. 类实现接口的时候必须实现这个接口中的所有的方法
6. 由于接口中都是抽象方法，所以接口不能实例化
7. 可口中没有构造函数
8. 虽然接口在编译完成之后会产生class文件，但是接口不是类
9. 接口中可以定义属性，这个属性默认是一个静态常量即接口中的属性默认是用public static final来修饰
10. 接口中的抽象方法默认用public abstract修饰，而且只能是public修饰的，public可以省略不写。在接口的子类中实现接口的方法记得用public修饰
11. Java中类支持单继承，多实现。一个类只能继承一个类，但是一个类可以实现多个接口。一旦出现了多实现，那就必不可免的会导致方法调用混乱 - 类和类之间是单继承，类和接口之间是多实现，接口和接口之间是多继承
12. 注意：Java中接口之间是多继承，并且接口和类之间是多实现的关系，所以就形成了一张继承关系网，由于在网状结构中寻找一个根节点比较困难，为了提高效率，Java在编译的时候放弃检查接口和类之间是否有实现关系。当类进行强势转换的时候，JVM在编译的时候会对两个类进行检查，检查这两个类之间是否有几成关系。如果有几成关系，则编译的时候会通过，但是运行的时候不一定正确，如果没有继承关系，则在编译的时候直接报错。
13. 作用：统一结构。接口可以作为模板，配合多态实现解耦
*** 内部类
1. 定义类或者接口中的类就称之为内部类。内部类是封装的第三种形式
2. 内部类根据使用的位置和修饰符不同分为：方法内部类、成员内部类、静态内部类和匿名内部类
3. 特点：
   - 除了静态内部类，其余的内部类中都不允许定义静态属性和静态方法，但是可以定义静态变量
   - 除了静态内部类，其余的内部类都可以使用安全外部类的属性和方法，但是静态内部类只能使用外部类的静态成员
4. 方法内部类
   - 定义在方法里的类叫做方法内部类，也叫局部内部类
   - 特点：
     + 可以定义成员属性和成员方法
     + 不可以定义静态属性和静态的方法，但是可以定义静态常量
     + 可以继承其他类和实现接口。注意：在这个继承和实现知识只能继承和实现外部类的接口和类，内部类和内部接口是不能被继承和实现的。
     + 可以使用外部类的属性和方法
     + 不可以使用当前方法里的局部变量，但是可以使用当前方法中的局部常量
   - 作用：方法内部类是为了私有本类方法中的参数
5. 成员变量
   - 定义在类内方法外的类叫做成员内部类，也就是成员变量的位置，利用外部类对象来创建成员内部类对象
   - 特点
     + 成员内部类可以定义非静态变量和非静态方法
     + 不可以定义静态变量和静态方法
     + 可以定义静态常量
     + 可以使用外部类中的一切属性和一切方法
     + 内部类的权限可以定义为私有的
     + 可以继承类或者实现接口
6. 静态内部类
   - 用static修饰的成员内部类叫做静态内部类。可以直接利用外部类来创建静态内部类的对象
   - 特点
     + 可以定义成员属性成员方法
     + 可以定义静态属性和静态方法
     + 不允许使用外部类里面的非静态属性和静态方法
7. 匿名内部类
   - 没有名字的内部类叫做匿名内部类。包含成员匿名内部类，方法匿名内部类
   - 注意：
     抽象类可以创建匿名内部类，实体类只要不是最终类就可以创建匿名内部类。当利用接口创建匿名内部类的时候，实际上是实现了对应的接口。
   - 如果匿名内部类定义在了方法或者语句内的时候，使用规则和方法是一致的。当定义在类内时，使用方法和成员内部类相同。本质上是继承了对应的类或者实现了对应的接口
   - 可以使用匿名内部类的方式创建对象
   - 特点：
     + 匿名内部类本质上是集成了对应的类或者实现对应的接口
     + 只要一个类可以被继承，那么这个类就可以出现匿名内部类的形式，当利用一个类来创建一个匿名内部类的时候，实际上这个匿名内部类是继承了这个类
     + 匿名内部类有构造函数。但是不能进行手动的添加
     + 当利用匿名内部类定义到了方法中，此时匿名内部类的使用规则和方法内部类一致
     + 如果匿名内部类定义到了类中，此时匿名内部类的使用规则和成员内部类一致
*** 包
1. 声明包用的package，包的产生是为了解决同名文件的问题
2. 注意：
   一个Java文件中只允许存在一个package语句，而且这个package语句必须方法整个Java文件的首行
3. 导入包用的是import。在导包的时候，*表示通配符，用于导入指定包下的所有的类而不包括子包下的类。例如import java.util.*。表示导入util包下的所有的类而不包括util子包下的类
4. java.lang包下的类在程序运行的时候会自动导入，所以java.lang包下的类在使用的时候不需要写导包语句
5. 同一个包下的类在使用的时候也不需要导包
6. 注意：
   包名在命名的时候尽量不以java,javax等开头
*** 垃圾分代回收机制
1. 垃圾回收针对的是堆内存
2. 对象在堆内存中存储，对象在使用完成之后会在不定的某个时刻被垃圾回收期(GC - Garbage Collector)解析掉。现阶段回收过程无法手动控制。当调用构造方法的时候，创建好一个对象，因为java中对每种数据类型都明确给定了大小，在创建对象的时候，会自动计算大小分配内存，所以在内存的回收和释放的时候也是由Java自己管理
3. 堆内存分为了新生代（年轻代）和老生代。新生代划分为伊甸园区和幸存区。一个对象新创建是放到了伊甸园区，如果这个对象在栈内存中没有引用，那么会在扫描的时候被解析，释放内存；在伊甸园区经过了一次扫描如果依然存活则标记到幸存区。幸存区的扫描频率要略低于伊甸园区。如果在幸存区中经过了多次扫描这个对象依然没有被解析则标记到老生代。如果老生代的对象发生了回收，导致程序的卡顿甚至崩溃
4. 发生在新生代的回收称之为minor gc，即初生代回收；发生在老生代的回收称之为full gc，即完全回收

* 面向对象的特征
** 封装
1. 封装是面向对象方法的重要原则，就是把对象的属性和方法（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。封装是一种信息隐藏技术。
2. 形式
   a. 方法，其实是封装的一种常见的形式，通过将某段常用的逻辑进行提取从而形成一种新的形式。
   b. 属性的私有化，在类中定义了属性之后，如果允许在类外直接操作属性会导致用户直接给属性赋予一些不合常理的数据。将属性私有化，将属性用private修饰，然后提供对外的访问（getXXX）和设置（setXXX）的方法，在方法中进行限定，使属性值更加符合的场景要求。
   c. 内部类，内部类作为封装的一种形式，是为了让代码的结构更加的紧凑
3. 作用
   a. 提高了复用性（降低了代码的冗余度）、安全性、使代码结构更加紧密
   b. 使属性私有化 - 隐藏信息，实现细节
   c. 使属性值更符合要求 - 可以对成员进行更精准的控制
   d. 提高了代码的安全性 - 类内部的结构可以自由修改
   e. 良好的封装能够减少耦合
#+BEGIN_SRC java
package cn.commandoptionesc.object;

public class PrivateDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("amy");
        p.setAge(17);
        System.out.println(p.getAge());
        System.out.println(p.getName());
    }
}

//定义一个代表人的类
class Person{

    private String name;
    //私有
    private int age;

    //提供一个方法，将要赋值的属性作为参数
    public void setAge(int age){
        if(age < 0 || age >= 150)
            return;
        this.age = age;
    }

    public int getAge(){
        return this.age;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }
}
#+END_SRC
** 继承
1. 如果一些类中的属性和方法是相同的，那么可以把这些类中相同的属性和方法提取到一个新的类中，然后利用extends关键字让原来的类和行的类产生练习，这种练习称之为继承。而这个时候原来的类称之为是子类，新的类称之为父类
2. 注意事项
   - Java中支持的是类和类之间的'单继承'，即一个子类只能有一个父类，但是一个父类可以有多个子类。
   - 通过继承，子类可以继承父类全部的数据域，但是只有一部分数据域对子类可见，所以子类也只能使用这一部分可见的数据域
3. 单继承与多继承的比较
   - 多继承在代码的复用性上要优于单继承，但是存在方法调用的混乱
     #+BEGIN_SRC java
     public class ex3{
         public static void main(String[] args){
         }
     }
     class A{
         public void m(){
             System.out.println("A");
         }
     }
     class B{
         public void m(){
             System.out.println("B");
         }
     }
     class C extends A,B{

     }
     C c = new C();
     c.m();
     #+END_SRC
   - 单继承也可以提高代码的复用性，可以避免方法调用的混乱，提高了方法调用的安全性
4. 特征
   - 继承关系是传递的
   - 继承简化了人们对事物的认识和描述，能清晰的体现相关类间的层次结构关系
   - 继承提高了代码的复用性
   - 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性
5. 优点
   - 提高复用性
   - 提高安全性，避免方法调用产生混乱
   - 统一结构
6. 方法的重写
   - 子类里存在了方法签名（方法名+参数列表）完全一致的非静态方法，就构成了方法的重写（覆盖）
   - 子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要曹勇方法的重写，方法重写又称方法覆盖
   - 遵循原则：方法的重写需要遵循“两等两小一大”的原则：方法签名、返回值类型、权限修饰符
     + 方法签名要求完全一致
     + 如果父类里的返回值是基本数据类型/void/最终类，那么子类里重写的返回值类型必须一致（如果父类的方法是private的话，子类是无法被继承的，即使子类重新定义这个方法，也不算重写）
       #+BEGIN_SRC java
       public class ex5{
           public static void main(String[] args){
           }
       }
       class A{
           public void m(){
           }
       }
       class B extends A{
           public void m(){
           }
       }
       #+END_SRC
     + 如果父类方法的返回值类型是一个引用类型，子类方法的返回值类型是父类方法的返回值类型的子类
       #+BEGIN_SRC java
       public class ex{
           public static void main(String[] args){
           }
       }
       class Pet{}
       class Dog extends Pet{}

       class A{
           public Pet m(){}
       }
       class B extends A{
           //public Pet m(){}
           public Dog m(){}
       }
       #+END_SRC
     + 子类方法的权限修饰符的范围要大于等于父类方法权限修饰符的范围，需要注意的是，对于8种基本数据类型之间没有继承关系的，它们是同级关系
        #+BEGIN_SRC java
        public ex2{
            public static void main(String[] args){}
        }
        class A{
            protected void m(){}
        }
        class B extends A{
            //父类用的protected，子类要么用相同的protected要么用比父类大的public
            //protected void m(){}
            public void m(){}
        }
        #+END_SRC
7. super关键字
   - super表示在子类中对父类对象的引用，可以看做是一个虚拟对象
   - 在子类中可以通过super调用父类中的非讲台方法或者非静态属性
   - 在子类的构造方法中看，可以通过super关键字调用父类中的对应形式的构造方法，如果不指定，默认调用父类的无参构造
   - 如果父类中值提供了含参的构造方法，那么子类的构造方法中必须手动定义super语句来调用父类中的含参构造
   - super语句必须放在狗仔方法的第一行，所以super语句不能同时出现
   #+BEGIN_SRC java
   package cn.commandoptionesc.extendsx;

   public class ExtendsDemo4 {
       public static void main(String[] args) {
           B b = new B();
           b.m();
       }
   }

   //
   class A {
       public A(int i){

       }
       public void m(){
           System.out.println("A ");
       }
   }

   //
   class B extends A{
       //如果在子类中没有手动指定，那么在子类的构造方法中
       //默认添加一个无参super()调用父类中对应形式的构造方法
       public B(){
           super(5);
       }

       public B(int i){
           //先创建一个父类对象，然后才能在子类中调用父类对象中的属性或者方法
           super(i);
           System.out.println(i);
       }

       @Override
       public void m() {
           super.m();
           System.out.println("B");
       }
   }

   #+END_SRC
** 多态
1. 多态是指允许不同类的对象对同一消息做出相应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态主要针对对象的行为及方法，而不是对象的属性。
2. 体现形式：
   - 编译时多态
     在编译时期就要进行动态绑定的行为，主要体现为方法的重载
   - 运行时多态
     + 在运行时期才能确定绑定的运行过程，主要体现形式是向上造型、方法的重写
     + 需要注意的是运行时多态的前提需要产生了继承关系或者实现关系
3. 向上造型
   指的是用父类声明对象而用子类创建对象的行为方式，利用向上造型创建的对象所能使用的属性或者方法需要看的是声明类，而具体怎么执行所调用的方法看的是实现类
4. 作用：统一结构，实现解耦
#+BEGIN_SRC java
package cn.commandoptionesc.method;

public class ObjectDemo {
    public static void main(String[] args) {

        //用父类Pet生命对象，用子类创建对象 ---> 向上造型
        //向上造型创建对象，在编译的时候，并不会去检查具体子类
        //在编译的时候，首先发现Pet p所以确定这个对象是一个Pet对象
        //继续往后编译会检查后边要使用的类和前面生命的类是否有继承关系
        //Cat和Pet有继承关系，那么久编译通过，而此时并没有去检查具体是哪一个子类
        //编译的时候没有确定子类，也就不知道子类中具体有哪些方法
        //所以在使用的时候，就不允许调用子类中独有的方法
        //此时只允许调用父类中声明的方法
        Pet p = new Cat();
        //向上造型创建的喜爱那个在调用方法的时候调用的是子类中的方法
        p.eat();

        //向上造型创建的对象不能调用子类中独有的的方法
        //p.catchMouse();
    }
}

//定义一个类表示宠物
class Pet{
    public void eat(){
        System.out.println("在吃东西");
    }

}

//定义一个类表示猫
class Cat extends Pet{
    @Override
    public void eat() {
        System.out.println("这只猫在吃鱼");
    }

    public void catchMouse(){
        System.out.println("这只猫抓到了一直老鼠");
    }
}

//定义一个类表示狗
class Dog extends Pet{
    @Override
    public void eat() {
        System.out.println("这只狗再吃骨头");
    }

    public void bark(){
        System.out.println("这是狗在汪汪叫");
    }
}

#+END_SRC
* API(一)
** Object
1. Object是Java中任何一个类都默认继承了Object
2. 在Java中任何一个类都是Object的子类
3. 重要方法

|----------+-------------------------------------------------------------------------------------------------------------------------------|
| 方法     | 解释                                                                                                                          |
| clone    | 1. 表示创建一个和当前对象                                                                                                     |
|          | 2.这个方法在使用的时候，要求对象对应的类必须实现接口Cloneable。这个接口中没有任何的方法和属性，仅仅标记这个类的对象可以被克隆 |
| finalize | 通知GC进行垃圾回收。仅仅是起通知作用，而GC不一定启动                                                                          |
| getClass | 获取对象的实际类型                                                                                                            |
| hashCode | 1. 获取对象的哈希码。根据哈希散列算法产生对象的哈希码                                                                         |
|          | 2. 同一个对象的哈希码是一样的，不同的对象的哈希码是不同的                                                                     |
| toString | 当直接打印一个对象的时候，底层实际上在调用这个对象的toString方法                                                              |
| equals   | 1. 判断两个对象是否是同一个对象                                                                                               |
|          | 2. equals默认是比较两个对象的地址是否一致。实际过程中往往需要重写equals方法                                                   |
|          | 3. 重写equals要拆分成4步：                                                                                                    |
|          | a. 比较地址是否一致                                                                                                           |
|          | b. 判断参数是否为空                                                                                                           |
|          | c. 比较类型是否一致                                                                                                           |
|          | d. 判断属性值是否一样                                                                                                         |
|----------+-------------------------------------------------------------------------------------------------------------------------------|

** String
1. String类是一个最终类
2. 字符串在Java底层是依靠字符数组来存储，字符数组是一个常量不可变
3. 字符串的内存：
   [[./Img/2.png]]
4. String str = "a";这句话只产生了一个对象
5. String str = new String("a");这句话产生了2个对象
6. String str = "a";String str2 = new String("a");这两句话产生了2个对象
7. 因为+在底层是调用StringBuilder中append，所以如果需要进行大量的字符串拼接的时候，建议直接使用StringBuilder
8. String类中提供了大量的操作字符串，但是不改变原字符串的方法
** 正则表达式
1. 针对字符串进行操作，利用指定的规则对字符串进行匹配、筛选、替换等操作
2. 符号：
   |--------+-------------------------------|
   | 正则   | 解释                          |
   | [xyz]  | x、y、z中的任何要给都可以     |
   | [^abc] | 表示出了a/b/c以外的元素       |
   | .      | 表示任意字符                  |
   | \\\\   | 匹配\                         |
   | \\.    | 匹配.                         |
   | \\w    | 单词字符，等价于[a-z A-Z 0-9] |
   | \\W    | 非单词字符                    |
   | \\d    | 数字，等价于[0-9]             |
   | \\D    | 非数字                        |
   | \\s    | 空白字符                      |
   | \\S    | 非空白字符                    |
   | +      | 至少一次                      |
   | ?      | 至多一次                      |
   | *      | 零次或者多次                  |
   | {n}    | 恰好出现n次                   |
   | {n,}   | 至少出现n次                   |
   | {n,m}  | 至少出现n次，但是不超过m次    |
3. 当()将一些字符放在一组的时候，构成了正则表达式中的捕获组
4. 捕获组的编号是从1开始递增，可以通过\\n的形式来引用对应编号的捕获组
5. 捕获组的编号计算是从（出现的顺序来依次递增）

** 包装类
1. 在Java中，基本类型的变量身上没有任何的方法和属性提供使用，如果需要操着这个基本类型，那么需要自动以过程来使用。因此Java针对每种基本类型都提供了对应的类形式来便捷的操作数据。提供的类形式就称之为包装类
2. 包装类：

   |----------+------+-------+---------+------+-------+--------+-----------+--------|
   | 基本类型 | byte | short | int     | long | float | double | char      | booble |
   | 包装类   | Byte | Short | Integer | Long | Float | Double | Character | Booble |
   |----------+------+-------+---------+------+-------+--------+-----------+--------|
3. 将基本类型的变量直接赋值给引用类型的对象，这个过程称之为自动封箱。自动封箱在底层会调用对应类身上的valueOf方法
4. 将引用类型的对象直接赋值给基本类型的变量，这个过程称之为自动拆箱。自动拆箱在底层会调用对应对象身上的***Value方法
** 数字运算
1. BigDecimal是一个能够对小数进行精确运算的类。在静思园的时候要求参数以字符串形式传入
2. BigInteger：能存储和计算超大证书
3. Math：针对基本类型提供了初等数学运算 - 指数、对数、、幂、三角函数等
** 日期
1. Date类：这个类是属于java.util包下
   - 如果不指定，默认获取的是当前系统的时间
   - SimpleDateFormat负责在字符串和日期之间来进行转化的，在转化的时候需要制定格式
2. Calender类：这个类是属于java.util包下的，是JDK1.2推出来用于取代Date类，但是实际开发中依然会使用Date
   [[./Img/3.png]]
* API(二)
** 异常
1. 异常是Java中提供的一套用于问题的反馈和处理的机制
   #+BEGIN_SRC java
   package cn.commandoptionesc.ex;

   import java.io.File;
   import java.io.FileNotFoundException;

   public class ExDemo {
       public static void main(String[] args) throws FileNotFoundException {
           try {
               String msg = readTxt("~/Documents/ex.txt");
           }catch (FileNotFoundException e){
               //处理问题
           }
       }
       public static String readTxt(String path)throws FileNotFoundException{
           //路径不存在
           if(判断路径是否存在)
               //将问题包装成一个异常对象来抛出
               throw new FileNotFoundException();
           return "读取到的内容";
       }
   }
   #+END_SRC
2. Java中异常的提携结构：
   - 异常的顶级父类是Throwable，包含2个子类：Error和Exception
   - Error：错误 - 表示一个合理的应用程序中出现的不应该补货的严重问题 - Error出现无法处理 - StackOverflowError
   - Exception：异常。出现之后可以处理，处理方式分为两种：throws抛出或者try-catch捕获
     + 编译时异常（已检查异常）：在编译阶段就已经出现，要求必须立即处理
     + 运行时异常（未检查异常）：在编译时不报错而是在运行阶段出现，可以处理可以不处理，在Java中，所有的运行时异常都需要继承RuntimeException
3. 如果需要的异常在Java中没有提供，那么久需要自定义异常。如果需要自定义异常，那么需要写一个类继承Exception或者是其子类
4. 如果程序中排除了异常，那么异常之后的代码就不再执行。但是异常被捕获之后，catch之后的程序可以继续执行
5. 异常的处理方法：
   - 如果每一个异常的处理方式都不一样，那么可以分别catch分别处理
   - 如果所有异常的处理方式都一样，那么可以捕获一个异常的父类，进行统一处理
   - 如果异常需要分组处理，那么同一组的异常之间可以用 | 隔开 - 这种方式是JDK1.7提供的方式
6. 异常不影响方法的重载，但是在重写的时候，子类异常不能超过父类的异常
7. try-catch-final中的finally的特点是：无论出现异常与否，这个finally中的代码块都会执行一次
** 集合
1. 集合是Java中提供的一套容器机制，这个容器的特点是大小不固定
2. Collection是集合的顶级接口，包含了很多的字接口以及实现类：List、Set、Queue等
3. <E>表示泛型，用于规定集合中元素的类型，因为泛型的限制，所以集合中存储的类型必须是引用类型:Collection<Integer>,Collection<Double>等；int[] arr,---arr的数据类型是数组，元素类型是int；Collection<String> c;---c的数据类型是Collection，元素类型是String
4. List:列表
   - 元素有序（指的是保证元素的添加顺序），允许添加重复元素
   - 提供了下标来获取元素
   - 实现类：ArrayList底层是基于数组的，默认初始容量为10.每次扩容默认是在上一次容量的基础上增加一半的容量，也就意味着初始容量是10，那么扩容之后的容量就是15，再次扩容之后的容量就是22 - 用数组来模拟一个ArrayList - 线程不安全的列表 - ArrayList是便于查询而不便于增删
   - 实现类：LinkedList底层是基于节点的，没有初始容量，也就不需要考虑扩容 - 线程不安全的列表 - LinkedList是便于增删而不便于查询
     [[./Img/4.png]]
   - Vector:向量。类似于ArrayList，底层也是基于数组来存储，但是每次扩容的时候，默认是增加一倍 - Vector是一个线程安全的集合
   - Stack:栈。继承了Vector，本身是一个后进先出/先进后厨的结构。
     |-----------+--------------------|
     | 入栈/压栈 | 将元素放入栈中     |
     | 出站/弹栈 | 将元素从栈中取出   |
     | 栈底元素  | 最先放入栈中的元素 |
     | 栈顶元素  | 最后放入占中的元素 |
     |-----------+--------------------|
5. Set:散列集合
   - 特点：不保证元素的顺序，而且要求元素元素不重复
   - HashSet：在地城会对元素进行排序，默认是升序排序。要求存储在TreeSet中的元素对应的类必须实现Comparable接口
6. Queue：队列，遵循先进先出的原则
** 和集合相关的类
1. Iterator：迭代器。实际上是利用迭代的方式去遍历一个集合。迭代器在迭代过程中不允许直接增删原集合，而是需要通过迭代器提供的remove方法移除。增强for循环本质上是一个简化版的迭代器，增强for循环底层也是利用迭代器来迭代遍历的。要求能够被迭代的元素对应的类必须实现Iterable接口。
2. Collections：集合的工具类，提供了大量的操作集合的方法
** 泛型
1. 泛型的学名是参数化类型 - ParameterizedType
2. 在JDK1.5之前，没有泛型的概念，从JDK1.5开始，出现了泛型
3. 泛型的擦除：用具体类型来替换泛型的过程，反省的擦除发生在编译期间
4. 如果需要定义一个泛型类，那么只需要在类名之后添加<泛型名>就可以声明一个泛型
5. 通常情况下，只使用一个大写字母来给泛型命名，最常用的大写字母：T-type，E-Element,K-key,V-value,R-Result
6. 在Java中，也允许给方法来单独定义一个泛型，此时这个方法称之为泛型方法
7. ？extends类/接口，表示传入这个类/接口及其子类/子接口对象，此时称之为泛型的上限
8. ？super类/接口，表示传入这个类/接口及其父类/父接口对象，此时称之为泛型的下限
9. 上限和下限不能同时存在，即？extends XXX super XXX这种格式是不允许的
** Map<K,V>
1. Map - 映射：需要由2组元素构成，一组元素称之为键，另一组元素称之为值
2. 在Map中，每一个键必须对应一个值，把这种结构称之为键值对，即一个Map由多个键值对组成，键是唯一的
3. 遍历映射：
   - 方式一：可以先获取映射中所有的键，然后遍历键，根据键获取值
   - 方式二：在Map中，将键值对封装成Entry对象，即每一个键值对实际上就是一个Entry，可以考虑直接获取所有的Entry
4. Map不是集合，但是Map是Java集合框架的成员 - Java Collections Framework（Java集合框架），包含了数组、集合、映射以及相关的工具类，例如：Collection及其子类，Map及其子类，Arrays，Collections，Iterator，Comparable，Comparator等
5. HashMap - 哈西映射：
   - 底层是基于数组 + 链表结构来存储数据。数组默认初始容量是16，数组的每一个位置都称之为是一个桶（bucket），每一个桶中维系一个链表
   - 默认加载因子是0.75，当已用桶数/总的桶数>0.75，会发生扩容。扩容默认是增加一倍的同属
   - HashMap本身是一个异步线程不安全的映射
     [[./Img/5.png]]
6. Hashtable:
   - Hashtable是Java中最早的映射之一
   - 底层是基于数组+链表结构来存储，默认初始容量是11，默认加载因子是0.75
   - Hashtable是一个同步线程安全的映射
* API(三)
** File
1. File是Java中提供的一套用于表示文件/目录(文件夹)的类
2. 删除目录及其子目录和子文件 -> 获取这个目录下所有的子文件和子目录(listFiles)，如果是子文件可以直接删除，如果是子目录，那么得获取这个子目录中的子文件和子目录，后续功能和当前的功能是一致的 - 递归
3. File提供了大量的操作文件/目录的方法
** IO
1. IO -> IO流 - Input/Output Stream - 输入输出流
   - 输入流：数据从外部流向程序。例如读取文件 - 将数据从文件读取到程序中
   - 输出流：数据从程序流向外部。例如向文件中写数据 - 将数据从程序写到文件中
2. IO是Java中提供的一套用于进行数据传输的机制
3. 流的分类
   - 按照传输方向：输入流和输出流
   - 按照传输形式：字节流和字符流

   |--------+-------------+--------------|
   |        | 输入流      | 输出流       |
   | 字符流 | Reader      | Writer       |
   | 字节流 | InputStream | OutputStream |
   |--------+-------------+--------------|
4. 数据的来源/目的地：自盘、内存、网络、输入设备
5. 向TXT文件中写入字符串 - 输出流、字符流、与文件相关的流 - FileWriter
6. 流中的异常处理
   - 流对象需要放在try之外定义并且赋予null值，然后放到try之内进行初始化
   - 无论流写入数据成功与否，都需要灌流，所以close操作需要放到finally里面
   - 关流之前需要判断，判断流是否初始化成功，实际上就是判断流对象是否为空
   - 因为关流也存在失败的可能，所以需要最后将writer设置为null，那么无论如何这个writer都会被回收掉
7. JDK1.7中，提供了try-with-resource方法来处理流中的异常，但是要求try()中的对象对应的类必须实现Closable接口或者是Closable的子接口AutoClosable;如果在方法中接收到了一个流对象处理，那么需要在定义一个变量单独接收这个流
8. FileReader：读取字符文件，结合FileWriter实现文件赋值的效果
9. 缓冲流：
   - BufferedReader：提供了缓冲区，允许在读取数据的时候实现按行读取的效果 - 在实际过程中，一行实际上就是一个自然段
   - BufferedWriter：本身比其他的字符输出流提供了更大的缓冲区
10. 文件的字节流
    - FileOutputStream：文件字节输出流，以字节的形式将数据写出到文件中 - 字节流没有缓冲区
    - FileInputStream：文件字节输入流，以字节的形式将数据从文件中读取出来
11. 凡是字符流可以完成的操作，字节流都可以完成，只是传输的时候，字符流传输字符文件会比字节流要快一些
12. 字符串流 - 用于读写字符串
    - StringReader：从内存中将字符串读取出来
    - StringWriter：将字符串写到内存中
13. 字节数组流 - 用于读写字节数组
    - ByteArrayOutputStream：产生字节数组，将这个字节数组放到内存中
    - ByteArrayInputStream：将字节数组从内存中读取出来
14. 转换流：字节流和字符流之间进行转换的桥梁，在这个过程中注意编码的转换问题
    - ByteputStreamWriter：将字符转化为字节，在底层将数据以字节形式来写出
    - InputStreamReader：将字节转化为字符，在底层将数据已字节形式来读出来
15. 系统流：
    - 本质是System类中提供的静态常量，作用是从控制台来获取数据或者将数据打印到控制台上
    - 分类
      |------------+------------|
      | 分类       | 说明       |
      | System.in  | 标准输入流 |
      | System.out | 标准输出流 |
      | System.err | 标准错误流 |
      |------------+------------|
    - 系统流全部都是字节流
    - 系统流用完之后不需要关闭
16. 打印流 - PrintStream/PrintWriter：
    - 是Java提供的一套能够进行辩解打印的机制，并且提供了辩解的换行方式
    - 标准输出流/标准错误流本质上都是打印流
    - 打印流只有输出流
17. 合并流 - SequenceInputStream：
    - 只有输入流没有输出
    - 合并多个字节流，将这多个字节流中的数据合并到一块，实际过程中作用往往是将多个文件合并成一个文件。在创建合并流的时候，需要获取一个Enumeration对象，所以往往是利用Vector先来存储多个字节流，然后在利用这个Vector生成一个Enumeration对象，最后再构建合并流
18. 序列化/反序列化流：
    - 序列化：将数据按照指定格式进行转化
    - 反序列化：将数据按照指定格式转化回来
    - 注意问题：
      + 如果一个对象想要被序列化，那么这个对象对应的类必须实现Serializable。这个借口中没有任何的方法和属性，仅仅是用于标记当前类的对象可以被序列化
      + 被static、transien修饰的属性不会被序列化出去
      + 当一个类实现Serializable借口之后，这个类中如果没有指定SerialVersionUID（版本号），那么在运行的时候会根据类中的属性和方法自动计算一个版本号。如果类中的属性或者方法改变，那么就会自动重新计算一个新的版本号。在序列化的时候，版本号会随着对象一起呗序列化出去。在反序列化的时候，会先校验版本号是否一致，如果一致才能反序列化
      + 实际过程中，序列化和反序列化会被大量的应用，只要涉及到数据的传输和存储的问题，都会考虑序列化
19. 其他：
** 线程
1. 进程和线程
   - 进程是计算机在执行的任务
   - 线程是轻量化的进程。线程可以认为是进程的子任务。如果进程中只有一个任务，那么这个进程就可以看做是线程了。一个进程中至少包含一个线程，可以包含多个线程 - 线程实际上也是计算机在执行的任务
2. 多线程：计算机执行多个任务
3. 定义线程
   - 继承Thread类，然后覆盖run方法，将线程要执行的逻辑写到方法中，然后调用start方法来启动线程
   - 实现Runnable接口，然后覆盖run方法，在启动之前需要将Runnable对象传递到Thread中，然后利用Thread调用start方法来启动执行 - 现阶段要求掌握
   - 实现Callable接口，覆盖call方法，需要利用执行器服务来启动 - 先阶段仅做了接，后续课程中会讲解
4. 多线程的并发安全问题：多个线程同时执行的时候，这多个线程之间是相互抢占执行，并且抢占会发生在线程执行的每一个步骤中。由于线程之间的抢占导致出现不合理的数据的现象称之为多线程的并发安全
   [[./Img/6.png]]
5. 并发：多个线程同时执行，这种方式称之为并发
6. synchronized：利用一个锁将一段代码锁起来，一个线程使用期间不允许其他线程使用 - 需要确定一个锁对象，锁对象要求能被所有的线程都认识：共享资源、方法区中的资源（类的字节码、字符串等）、this
7. 被synchronized括起来的这段代码称之为同步代码块
8. 同步和异步
   - 同步：如果一段代码在一个时间段内只能被一个线程使用
   - 异步：如果一段代码在一个时间段内能够被多个线程抢占使用
9. 线程安全和线程不安全
   - 线程安全：多个线程同时执行的时候，结果是正常的
   - 线程不安全：多个线程同时执行的说会后，结果不符合常理
10. 死锁：锁之间相互嵌套导致代码无法继续向下执行。死锁形成条件：锁形成嵌套，现成之间还需要相互的锁。死锁不是逻辑错误或者代码错误，所以思索一旦出现无法处理。实际过程中，一般会尽量避免死锁，那么这个时候就会根据业务要求检测死锁，如果产生死锁，会考虑打破一个锁来释放其他的锁。
11. 虽然锁可以有效的避免多线程并发产生的安全问题，但是实际过程中尽量减少使用锁机制。锁机制如果滥用会导致死锁的产生，会导致程序执行效率的降低。如果实在需要使用锁，那么只有将有危险的片段锁起来就可以，不需要将整个类或者整个方法锁起来
12. 等待唤醒机制：wait/notify/notifyAll通过现成等待让线程不再执行而是让其他线程执行，通过这种方法调节了线程之间的执行顺序。注意，在notify的时候，是随机唤醒一个线程。
13. wait和sleep区别
    - sleep：在使用的时候需要指定睡眠时间，到了指定时间之后会自动醒过来；如果没有锁，那么线程在沉睡期间释放执行权；如果有锁，那么线程在沉睡期间不会释放执行权。sleep是被设计在Thread类上，本身还是一个静态方法。
    - wait：在使用的时候可以指定等待时间也可以不指定，如果不指定等待时间那么需要唤醒。wait必须结合锁来使用，线程在wait期间会释放执行权。wait是设计在了Object类上。
14. 线程的状态
      [[./Img/7.png]]
    - 线程在运行之前一定是先就绪
    - 运行状态有可能转化为阻塞或者就绪状态
    - wait、sleep等方法是将线程转化为阻塞状态
15. 线程创建的场景：
    - 用户主动创建 - 打开微信，实际上就是主动申请创建微信运行的这个线程
    - 系统自动启动 - 例如开机的时候，操作系统中会自己来运行一些系统的线程
    - 关联启动
16. 线程销毁的场景：
    - 线程自然结束 - “寿终正寝”
    - 被其他线程给强制关闭 - “他杀”
    - 线程在执行过程中出现意外而结束 - “意外死亡”
17. 线程的优先性
    - 在线程中，有优先级的区分，优先级用数字1 - 10表示
    - 数字越大优先级越高，理论上能抢占到资源的概率就会越大，但是注意在实际生产过程中，优先级的差别并不明显。至少要差到5个优先级以上，区别才能稍微明显一点点
    - 如果没有设置优先级，那么线程的优先级默认为5
18. 守护线程
    - 守护线程用于守护其他线程的，当被守护的线程结束，那么守护线程无论执行完成与否，都会随之结束
    - 一个线程要么是守护线程要么是非守护线程
    - 如果存在多个线程，那么只要这个线程不是守护线程，那么这个线程就是被守护。例如一共有10个线程，其中有7个守护线程，其他3个就是被守护的线程。如果存在多个被守护线程，那么守护线程要以最后一个被守护的线程的结束作为结束信号。
** 网络编程
1. 网络编程实际上是一套基于网络进行数据传输的流
2. 网络模型：物理层、数据链条层、网络层、传输层、会话层、表示层、应用层
3. 在这七层中，提供了不同的传输协议，例如：http、FTP、POP3等这些协议都属于后三层的协议，UDP、TCP等协议都是传输层的协议，而Java中的网络编程也是要考虑传输层的协议
4. IP地址：在网络中用于标记主机的，在传输数据的时候需要制定IP。IP协议存在IPv4和IPv6.目前国内最常使用的是IPv4，现在国内也开始推行IPv6.IPv4是用了4组数字表示一个IP地址，例如10.35.62.189。这四组数字中的每一组数字的范围U能超过255，也就意味着IPv4的地址范围是0.0.0.0~255.255.255.255，但是这个范围的一部分IP是有特殊含义的
5. 端口：是主机和外界进行信息交互的媒介 - 如果一台电脑需要和外界进行信息的交互，那么必须通过端口来进行交互。一台主机包含了好多的端口，对端口进行编号，编号的范围是0~65535.在信息交互的时候，需要制定端口的。但是注意，实际开发中，0~1024这个范围的大部分端口被计算机内部占用，往往是从1025号端口开始使用
6. 域名：为了方便人们记忆网站地址，设计了这么一串字符串。这串字符串在网络底层要映射为IP。例如：www.baidu.com - 在实际使用过程中，域名是分级的。一级域名往往是标记域名的类型，例如com表示商业类型，org表示的机构或者组织，edu表示的教育类型；二级域名往往是公司的商标或者品牌，例如baidu.com表示百度，164.com表示网易等；三级域名往往是应用类型，例如news.baidu.com表示百度新闻，163.com表示的网易邮箱。在实际使用过程中，域名一般不超过三级。
7. DNS解析服务器：就是将域名和IP进行映射。在万维网上存在一个最大的DNS服务器。当在浏览器地址栏指定域名之后，在底层，DNS服务器就会将这个域名解析为IP，然后才会去访问对应的IP地址。如果当前DNS服务器无法解析这个域名，向高一层的DNS服务器来请求解析域名
8. localhost或者127.0.0.1表示本机，255.255.255.255表示的是一个广播地址（只要在这个局域网范围内的主机都会接收到这个数据）
9. InetSocketAddress：是Java提供一个用于表示IP和端口和类
10. UDP：
    - 特点：
      + 基于网络进行数据传输的流
      + 无连接的流，不可靠（无论有没有接收，都会发送出去，所以可能会产生数据丢失）但是传输速度快
      + 适用于对传输速度依赖性较高但是对可靠性依赖相对低一些的场景，例如直播、视频聊天、语音电话等
    - 发送端：
      + 创建UDP发送端对象
      + 将数据封包，并且还需要制定接收地址和端口号
      + 发送数据包
      + 关流
    - 接收端：
      + 创建UDP接收端对象，绑定监听的端口号
      + 准备数据包
      + 接收数据
      + 解析数据
    - 案例：担任聊天室
11. TCP：
    - 特点：
      + 基于网络进行数据传输的流
      + 有链接，经理三次握手（三次确认），可靠（一定是在建立连接之后才会发送数据，三次确认过程中只要任何一次失败都不会发送数据，所以不会产生数据的丢失），传输速比较慢
        [[./Img/8.png]]
      + 适用于对可靠性依赖比较高但是对传输速度依赖相对低一些的场景，例如文件上传下载
    - 在现在的开发中，往往是TCP和UDP混用：在网络条件好的情况下，尽量选用TCP；如果网络条件产生变化，切换为UDP
    - 客户端：
      + 创建客户端套接字对象 - Socket
      + 发送链接，绑定链接地址和端口号
      + 获取输出流，写出数据
      + 通知服务器端数据已经写完
      + 关流
    - 服务器端
      + 创建服务器端套接字对象 - ServerSocket
      + 绑定监听的端口号
      + 接收连接
      + 获取输入流，读取数据
      + 通知客户端数据已经读完
      + 关流
    - 案例：文件上传
12. 反射
    1. 反射是去剖析一个类，获取这个类的字节码对象以及实例对象
    2. 如果将字节码看做对象，对这一类对象进行总结，总结出代表字节码的类 - Class
    3. 基本类：
       - Class - 代表字节码的类 - 代表类的类
       - Field - 代表方法的类
       - Method - 代表方法的类
       - Constructor - 代表构造方法的类
       - Package - 代表包的类
       - Annotation - 代表注解的类
    4. 反射在实际开发中，可以结合多态来实现解耦。如果两个或者多个模块之间产生了死死的绑定，称之为耦合。
       [[./Img/9.png]]
    5. 获取Class对象：
       - 通过类名.class方式来获取指定类的字节码对象
       - 通过对象.getClass()方式来获取对象对应的实际类型的字节码对象
       - 通过Class.forName("全路径名")方式来获取指定类型的字节码
    6. 修饰符
       |--------------+--------+------------|
       | 修饰符       | 十进制 |   十六进制 |
       | public       |      1 | 0x00000001 |
       | private      |      2 | 0x00000002 |
       | protected    |      4 | 0x00000004 |
       | static       |      8 | 0x00000008 |
       | final        |     16 | 0x00000010 |
       | synchronized |     32 | 0x00000020 |
       | volatile     |     64 | 0x00000040 |
       | transient    |    128 | 0x00000080 |
       | native       |    256 | 0x00000100 |
       | interface    |    512 | 0x00000200 |
       | abstract     |   1024 | 0x00000400 |
       | strictfp     |   2048 | 0x00000800 |
       |--------------+--------+------------|
    7. 案例：模拟一个clone方法 - 可以在不知道对象的类型的情况下就创建这个对象并且可以对属性进行赋值
    8. 在后续学习过程中，会大量的应用反射，例如数据库的JDBC操作等 - 也正是因为有反射的存在，所以才能够更好的实现解耦过程，并且能够更好的分工工作
    9. 在试驾开发过程中，强调"高内聚低耦合" - 高内聚就是尽量提高自己的东西的利用率，低耦合就是尽量减少使用别人的东西
** JDK1.5的特性
1. JDK1.5提供或者增强的主要特性：自动封箱拆箱、增强for循环、反省、静态导入、可变参数、枚举、反射（进行了增强）、动态代理、内省、注解等
2. 静态导入：
   - 在使用一个类中的静态方法的时候，可以在导入语句中单独导入这一个方法而不是导入整个类，这样可以一定程度上提高加载效率
   - 实际过程中这种方式很少使用，这种方式容易和已有的方法产生冲突，同事降低了可读性
3. 可变参数：
   - 在调用方法的时候可以传入任意多个参数（可以传入0个参数，可以传入一个参数，也可以传入多个参数），也可以传入一个数组
   - 可变参数本质上就是一个数组，所以可以通过操作数组的方式来操作可变参数
   - 可变在使用的时候只能定义一个，并且必须放在参数列表的末尾
4. 枚举：
   - 用于表示选项固定并且能够一一列举的场景，例如季节、等级、星期、月份等
   - 枚举中，构造函数默认是私有的而且不许是私有的
   - 枚举常量必须定义在枚举类的首行
   - 在枚举类中可以顶一个任何的属性和方法
   - 在Java中，枚举的顶级父类是java.lang.Enum
5. 注解：
   - 注解乐意理解为给机器看的解释说明性的文字
   - 在Java中，注解的顶级父类是Annotation
   - 通过@interface来定义注解
   - 在注解中，通过定义方法的形式来定义属性，属性的类型只能是基本类型、String、枚举、Class、其他注解类型以及它们的一堆数组形式
   - 如果属性是数组，那么且调用的时候数组中只有一个值，那么在调用的时候可以省略{}
   - 通过default来给属性定义默认值
   - 如果一个注解中只有一个属性，并且这唯一的一个属性的名字是value，那么在调用这个属性的时候可以省略属性名不写
   - 元注解：在之前接触过的绝大部分注解都是作用在类、方法、或者属性上，但是元注解是作用在注解上的 - 元注解是对注解进行注解
     + @Target：用于限制注解的使用范围
     + @Retention：用于限制注解的生命周期的
     + @Document：表示生成在文档中
     + @Inherited：表示当前注解要作用在子类上
** 其他
1. Debug模式/断点调试：允许通过断点来一行行调试代码
2. 单元测试/Junit测试：
   - 要求测试方法必须在公共类
   - 需要选中要测试的方法的方法名，如果不选中方法名，则测试的时候会将所有的方法都进行测试
   - 要求被测试的方法必须没有参数，没有返回值以及是一个非静态方法
