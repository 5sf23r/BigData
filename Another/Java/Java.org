* 目录                                                                          :TOC_5:QUOTE:
#+BEGIN_QUOTE
- [[#java的简介][Java的简介]]
  - [[#语言特点][语言特点]]
    - [[#跨平台操作系统][跨平台（操作系统）]]
  - [[#三大技术架构][三大技术架构]]
    - [[#j2se][J2se]]
    - [[#j2ee][J2ee]]
    - [[#j2me][J2me]]
  - [[#搭建java语言环境][搭建Java语言环境]]
  - [[#人机交互的方式][人机交互的方式]]
  - [[#命令提示符][命令提示符]]
  - [[#磁盘操作系统dos的命令][磁盘操作系统（Dos）的命令]]
  - [[#环境变量][环境变量]]
    - [[#自定义环境变量][自定义环境变量]]
  - [[#包][包]]
    - [[#带包编译和运行][带包编译和运行]]
      - [[#编译][编译]]
      - [[#运行][运行]]
  - [[#案例输出helloworld][案例：输出HelloWorld]]
    - [[#定义一个类][定义一个类]]
    - [[#定义main方法][定义main方法]]
      - [[#main主函数的主要作用][main主函数的主要作用：]]
    - [[#总结][总结：]]
    - [[#注意][注意：]]
  - [[#注释][注释]]
    - [[#书写格式][书写格式]]
      - [[#单行注释][单行注释]]
      - [[#多行注释][多行注释]]
      - [[#文档注释][文档注释]]
  - [[#关键字][关键字]]
  - [[#标识符][标识符]]
    - [[#组成元素][组成元素]]
    - [[#标识符规则][标识符规则]]
    - [[#命名的规范][命名的规范]]
      - [[#驼峰命名法][驼峰命名法：]]
  - [[#数据][数据]]
    - [[#程序概述][程序概述]]
    - [[#数据类型][数据类型]]
    - [[#常量][常量]]
      - [[#整数类型][整数类型]]
      - [[#浮点类型][浮点类型]]
      - [[#布尔类型][布尔类型]]
      - [[#字符类型][字符类型]]
      - [[#字符串类型][字符串类型]]
      - [[#空常量][空常量]]
    - [[#整数的四种不同的表现形式进制][整数的四种不同的表现形式(进制)]]
      - [[#二进制][二进制：]]
      - [[#八进制][八进制：]]
      - [[#十进制][十进制：]]
      - [[#十六进制][十六进制：]]
      - [[#举例][举例]]
      - [[#进制转换][进制转换]]
        - [[#其他进制转换为十进制][其他进制转换为十进制]]
        - [[#十进制转换为其他进制][十进制转换为其他进制]]
        - [[#任意进制直接的转换][任意进制直接的转换]]
      - [[#小数十进制转为二进制][小数十进制转为二进制]]
      - [[#有符号的数原码反码补码][有符号的数（原码、反码、补码）]]
        - [[#表示有符号的数去表示5和-5][表示有符号的数去表示5和-5]]
        - [[#计算机的底层运算是以二进制的补码进行运算的][计算机的底层运算是以二进制的补码进行运算的]]
- [[#java基本语法组成][Java基本语法组成]]
  - [[#变量][变量]]
    - [[#计算机存储单元][计算机存储单元]]
    - [[#基本类型之4类8种][基本类型之4类8种]]
      - [[#表示范围是怎么来的][表示范围是怎么来的]]
        - [[#整数类型-1][整数类型]]
        - [[#浮点型][浮点型]]
      - [[#文字转成数字-----编码][文字转成数字----->编码]]
      - [[#转义字符][转义字符]]
    - [[#常量与类型][常量与类型]]
    - [[#定义变量创建变量][定义变量(创建变量)]]
      - [[#数据类型-1][数据类型]]
      - [[#变量名][变量名]]
      - [[#初始化][初始化]]
      - [[#定义格式][定义格式]]
      - [[#变量声明][变量声明]]
      - [[#变量赋值][变量赋值]]
    - [[#定义字符串变量][定义字符串变量]]
    - [[#变量定义使用注意事项][变量定义使用注意事项]]
    - [[#数据类型转换][数据类型转换]]
  - [[#运算符][运算符]]
    - [[#算术运算符][算术运算符]]
      - [[#除法运算][除法运算]]
      - [[#取余][取余%]]
      - [[#---][++ --]]
    - [[#赋值运算符][赋值运算符]]
      - [[#ba11-bab底层会默认加上强制类型转换][b+=a;//11 b=a+b;底层会默认加上强制类型转换]]
      - [[#连等定义][连等定义？]]
      - [[#连等赋值][连等赋值?]]
    - [[#关系运算符][关系运算符]]
    - [[#逻辑运算符][逻辑运算符]]
      - [[#表达式][表达式：]]
      - [[#总结-1][总结：]]
    - [[#位运算符][位运算符]]
      - [[#按位与-按位或-按位异或][&（按位与） |（按位或） ^（按位异或）]]
      - [[#左移-右移-无符号右移-取反][<<左移 >>右移 >>>无符号右移 ~取反]]
        - [[#][>>]]
        - [[#-1][<<]]
        - [[#-2][>>>]]
        - [[#示例][示例]]
      - [[#按位异或的扩展][按位异或的扩展]]
      - [[#交换值的方式][交换值的方式：]]
    - [[#运算符的优先级][运算符的优先级]]
    - [[#三元运算符][三元运算符]]
      - [[#格式和执行流程][格式和执行流程]]
      - [[#示例-1][示例]]
        - [[#求两个整数的最大值][求两个整数的最大值]]
        - [[#求三个整数的最大值][求三个整数的最大值]]
        - [[#判断一个数是奇数还是偶数][判断一个数是奇数还是偶数]]
        - [[#分数评级][分数评级]]
        - [[#平年还是闰年][平年还是闰年]]
  - [[#引用数据类型][引用数据类型]]
    - [[#scanner类][Scanner类]]
      - [[#引用数据类型的使用][引用数据类型的使用]]
      - [[#scanner类-1][Scanner类]]
        - [[#scanner使用步骤][Scanner使用步骤]]
    - [[#随机数类random][随机数类Random]]
  - [[#流程控制语句][流程控制语句]]
    - [[#选择结构][选择结构]]
      - [[#if][if]]
        - [[#if语句][if语句：]]
        - [[#ifelse语句][if...else语句]]
        - [[#ifelse-ifelse语句][if...else if...else语句]]
        - [[#选择结构if语句与三元运算转换][选择结构if语句与三元运算转换]]
      - [[#switch][switch]]
        - [[#选择结构switch][选择结构switch]]
        - [[#case穿透][case穿透]]
    - [[#循环结构][循环结构]]
      - [[#for][for]]
        - [[#for循环][for循环]]
        - [[#增强for循环][增强for循环]]
      - [[#while][while]]
        - [[#循环语句while][循环语句while]]
        - [[#dowhile循环][do...while循环]]
      - [[#嵌套循环][嵌套循环]]
        - [[#举例-1][举例]]
      - [[#三种循环的区别于联系][三种循环的区别于联系]]
    - [[#嵌套循环嵌套循环双层循环][嵌套循环(嵌套循环/双层循环)]]
      - [[#举例-2][举例]]
    - [[#跳转语句breakcontinue][跳转语句break、continue]]
      - [[#break][break]]
      - [[#continue][continue]]
    - [[#练习][练习]]
  - [[#java的内存存储][Java的内存存储]]
    - [[#栈内存存储的变量目前阶段][栈内存：存储的变量(目前阶段)。]]
    - [[#堆内存存储的是对象][堆内存：存储的是对象。]]
    - [[#int-arr1new-int235][int[] arr1=new int[]{2,3,5};]]
  - [[#数组][数组]]
    - [[#数组格式][数组格式：]]
    - [[#数组的内存地址][数组的内存地址]]
    - [[#数组常用操作][数组常用操作]]
      - [[#获取数组中的元素][获取数组中的元素]]
      - [[#数组的元素赋值][数组的元素赋值]]
        - [[#数组越界异常][数组越界异常]]
      - [[#修改数组中的元素][修改数组中的元素]]
      - [[#获取数组长度][获取数组长度]]
      - [[#数组的遍历][数组的遍历]]
      - [[#获取数组中最值最大值最小值][获取数组中最值（最大值/最小值）]]
      - [[#数组逆序][数组逆序]]
      - [[#数组的查找][数组的查找]]
        - [[#查找元素出现的位置无序数组][查找元素出现的位置(无序数组)]]
        - [[#查找元素出现的位置有序数组折半查找二分查找][查找元素出现的位置(有序数组)(折半查找/二分查找)]]
      - [[#数组排序][数组排序]]
        - [[#冒泡排序][冒泡排序]]
        - [[#选择排序][选择排序]]
        - [[#升序排序][升序排序]]
      - [[#数组的扩容][数组的扩容]]
        - [[#arrayscopyof原数组改变之后的长度][Arrays.copyOf(原数组,改变之后的长度);]]
      - [[#时间复杂度][时间复杂度]]
      - [[#空间复杂度][空间复杂度]]
  - [[#二维数组][二维数组]]
    - [[#定义格式-1][定义格式]]
      - [[#数据类型-数组名--new-数据类型一维数组的个数每个一维数组元素的个数][数据类型[][] 数组名 = new 数据类型[一维数组的个数][每个一维数组元素的个数];]]
      - [[#数据类型-数组名--new-数据类型一维数组个数][数据类型[][] 数组名 = new 数据类型[一维数组个数][];]]
        - [[#nullpointerexception---空指针异常][NullPointerException---空指针异常]]
      - [[#数据类型-数组名--new-数据类型数组1数组2][数据类型[][] 数组名 = new 数据类型[][]{{数组1},{数组2}};]]
      - [[#数据类型-数组名--数组1数组2数组3][数据类型[][] 数组名 = {数组1，数组2，数组3，...};]]
    - [[#注意-1][注意：]]
    - [[#二维数组内存图][二维数组内存图]]
    - [[#二维数组的遍历][二维数组的遍历]]
      - [[#普通遍历][普通遍历]]
      - [[#增强for循环-1][增强for循环]]
    - [[#数组的常见的异常][数组的常见的异常]]
    - [[#数组获取最值得原理思想][数组获取最值得原理思想]]
    - [[#二维数组的定义和访问][二维数组的定义和访问]]
    - [[#二维数组的遍历-1][二维数组的遍历]]
    - [[#二维数组的求和练习][二维数组的求和练习]]
    - [[#随机点名案例][随机点名案例]]
  - [[#eclipse][eclipse]]
  - [[#方法][方法]]
    - [[#书写格式-1][书写格式]]
    - [[#方法的调用][方法的调用]]
      - [[#方法的注意事项][方法的注意事项]]
      - [[#单独调用][单独调用]]
      - [[#输出调用][输出调用]]
      - [[#赋值调用][赋值调用]]
    - [[#方法练习][方法练习]]
    - [[#方法的重载overload][方法的重载(overload)]]
    - [[#方法的传值][方法的传值]]
    - [[#方法的递归][方法的递归]]
  - [[#引用数据类型--类][引用数据类型--类]]
    - [[#自定义类][自定义类]]
    - [[#自定义类练习][自定义类练习]]
  - [[#arraylist集合][ArrayList集合]]
    - [[#arraylist创建变量的步骤][ArrayList创建变量的步骤]]
    - [[#arraylist的常见方法][ArrayList的常见方法]]
    - [[#arraylist集合的遍历][ArrayList集合的遍历]]
    - [[#arraylist集合补充方法][ArrayList集合补充方法]]
  - [[#随机点名器案例][随机点名器案例]]
  - [[#库存管理案例][库存管理案例]]
  - [[#数组方法练习][数组方法练习]]
    - [[#实现数组的遍历][实现数组的遍历]]
    - [[#数组逆原理][数组逆原理]]
    - [[#数组元素排序][数组元素排序]]
      - [[#选择排序selectsort][选择排序(selectSort)：]]
      - [[#冒泡排序bubblesort][冒泡排序(bubbleSort)：]]
      - [[#折半查找][折半查找]]
  - [[#超市管理系统][超市管理系统]]
- [[#面向对象][面向对象]]
  - [[#面向对象简介][面向对象简介]]
    - [[#面向对象与面向过程的比较][面向对象与面向过程的比较]]
    - [[#类与对象的关系][类与对象的关系]]
    - [[#对象的内存处理][对象的内存处理]]
  - [[#基本概念][基本概念]]
    - [[#成员变量和局部变量][成员变量和局部变量]]
    - [[#匿名对象][匿名对象]]
    - [[#构造方法][构造方法]]
    - [[#this关键字][this关键字]]
    - [[#构造代码块][构造代码块]]
      - [[#构造代码块-1][构造代码块]]
      - [[#局部代码块][局部代码块]]
    - [[#权限修饰符][权限修饰符]]
  - [[#基本概念2][基本概念2]]
    - [[#static][static]]
      - [[#静态变量][静态变量：]]
      - [[#静态方法][静态方法：]]
      - [[#静态代码块][静态代码块]]
    - [[#final][final]]
    - [[#abstract][abstract]]
    - [[#接口interface][接口interface]]
    - [[#内部类][内部类]]
    - [[#包-1][包]]
    - [[#垃圾分代回收机制][垃圾分代回收机制]]
- [[#面向对象的特征][面向对象的特征]]
  - [[#封装][封装]]
  - [[#继承][继承]]
    - [[#1-介绍][1. 介绍]]
    - [[#2-注意事项][2. 注意事项]]
    - [[#3-单继承与多继承的比较][3. 单继承与多继承的比较]]
    - [[#4-特征][4. 特征]]
    - [[#5-优点][5. 优点]]
    - [[#6-方法的重写][6. 方法的重写]]
    - [[#7-super关键字][7. super关键字]]
  - [[#多态][多态]]
- [[#api一][API(一)]]
  - [[#object][Object]]
  - [[#string][String]]
    - [[#-拼接与stringbuilder类的append方法][+ 拼接与StringBuilder类的append方法]]
    - [[#-拼接与stringbuilder类的appen方法的验证][+ 拼接与StringBuilder类的appen方法的验证]]
    - [[#charattochararray][charAt、toCharArray]]
    - [[#comparetocomparetoignorecaseconcatcaontains][compareTo、compareToIgnoreCase、concat、caontains]]
    - [[#endswithstartswithequalsinstanceofequalsignorecase][endsWith、startsWith、equals、instanceof、equalsIgnoreCase]]
    - [[#getbytesstring][getBytes、String]]
    - [[#hashcodeindexofinternisempty][hashCode、indexOf、intern、isEmpty]]
    - [[#lastindexofreplacesubstringtouppercasetolowercasetrim][lastIndexOf、replace、substring、toUpperCase、toLowerCase、trim]]
    - [[#tostring与stringvalueof的区别][toString与String.valueOf的区别]]
  - [[#正则表达式][正则表达式]]
    - [[#正则表达式举例][正则表达式举例]]
    - [[#空括号][空括号]]
    - [[#-][. \]]
    - [[#--][+ ？ *]]
    - [[#n-n-nm][{n} {n,} {n,m}]]
    - [[#捕获编号][捕获编号]]
    - [[#n][$n]]
    - [[#切分split][切分split]]
  - [[#包装类][包装类]]
  - [[#数字运算][数字运算]]
  - [[#日期][日期]]
- [[#api二][API(二)]]
  - [[#异常][异常]]
  - [[#集合][集合]]
  - [[#和集合相关的类][和集合相关的类]]
  - [[#泛型][泛型]]
  - [[#mapkv][Map<K,V>]]
- [[#api三][API(三)]]
  - [[#file][File]]
  - [[#io][IO]]
  - [[#线程][线程]]
  - [[#网络编程][网络编程]]
  - [[#jdk15的特性][JDK1.5的特性]]
  - [[#其他][其他]]
#+END_QUOTE

* Java的简介
  1995年由SUN公司推出的一款高级编程语言（Oak橡树），面向互联网编程，安全可靠、面向独享、跨平台等特点
** 语言特点
*** 跨平台（操作系统）
JVM（java虚拟机），想在不同平台运行java应用程序，需要在相应平台安装与之对应的运行环境（JVM）,把java应用程序放到JVM中运行，使得相同的应用程序得到的结果一样，进而屏蔽了底层操作系统的差异性
[[./Img/15.jpg]]
** 三大技术架构
J2se、J2ee、J2me；Jdk1.5位里程碑的版本，其中J2se更名为JavaSe，J2ee更名为JavaEE，J2ME更名为JavaME
*** J2se
Standard Edition 基础版--提供小型程序或者桌面服务解决方案
*** J2ee
Enterprise Edition 企业版--提供了企业中遇到的集中化或者模块化开发的解决方案
*** J2me
Micro Edition 小型版--终端的嵌入式开发提供了可能
** 搭建Java语言环境
- JRE（java Runtime Environment）java应用程序所需要的运行环境
- JRE = JVM + 核心类库（java程序启动的时候所必需的信息）
- JDK（java Development Kit）java的开发环境以及运行环境
- JDK = JRE + 开发工具包

- 从大到小排列
  + JVM-->JRE-->JDK
  安装JDK不可以出现空格和中文
** 人机交互的方式
1. 图形界面
2. 命令行模式
** 命令提示符
1. win+r
2. 地址栏输入cmd
** 磁盘操作系统（Dos）的命令
1. dir展示当前目录下的所有信息
2. cd翻转目录（cd.. :返回上一级）
   cd/：返回根目录（当前盘符）
** 环境变量
操作系统指定当前操作环境的参数
+ PATH = JDK bin文件夹所在地址
*** 自定义环境变量
1. JAVA_HOME = JDK的安装目录
2. PATH = %JAVA_HOME%\bin
** 包
package cm.tedu.exer
#+BEGIN_SRC java
package cm.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
*** 带包编译和运行
#+BEGIN_SRC java
package cn.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
#+BEGIN_SRC java
package cm.tedu.exer;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("OK");
    }
}
#+END_SRC
**** 编译
1.  -d：新建目录;表示在编译的时候需要将包生成对应的文件夹
2.  .：当前目录
3.  E:\\ 编译之后产生的文件夹的存放位置
4.  javac -d . PackageDemo.java
5.  javac -d E:\\ PackageDemo1.java
**** 运行
1. Java 包名.类名
2. java cn.tedu.exer.PackageDemo
3. java cm.tedu.exer.PackageDemo1
** 案例：输出HelloWorld
*** 定义一个类
class HelloWorld{}
*** 定义main方法
#+BEGIN_SRC java
public static void main(String[] args){}
#+END_SRC
#+BEGIN_SRC java
class HelloWorld{
    public static void main(String[] args){}
}
#+END_SRC
**** main主函数的主要作用：
1. 可以让类单独运行
2. 是程序的入口
3. 被JVM调用
4. 输出语句
   System.out.println("helloworld");
*** 总结：
+ .java文件（源文件）经过编译成为.class文件（二进制文件/字节码文件）
+ 编译时期（检测代码的语法问题）
+ 运行时期（执行代码的逻辑）
*** 注意：
1. .class文件名称和类名一致
2. 公共类的类名要和.java文件的文件名称保持一致
3. .java文件中只能最多有一个公共类
4. .java文件中可以存储多个类，有几个类就会生成几个.class文件，如果出现大小写的问题就看最后一个
** 注释
*** 书写格式
编译时，编译器会忽略注释的存在。
**** 单行注释
//注释内容
**** 多行注释
/*
  注释内容
*/
- 可以嵌套单行注释，不可以嵌套多行注释
**** 文档注释
/**
  注释内容
*/
- 通过javadoc命令对注释的内容进行抽取，抽取到文档中（程序员说明书）
** 关键字
1. 在java中被赋予了特殊含义的单词，53个关键字，两个保留字（const,goto也是关键字）
2. 在java中所有的关键字都是小写的

[[./Img/17.png]]
** 标识符
在java中可以自定义的名称,就是名称的意思，所有的名称统称为标识符。
*** 组成元素
- 英文字符：a~z A~Z
- 数字：0~9
- 符号： _ $(一般不推荐使用$)
*** 标识符规则
- 数字不能开头
- 不可以使用关键字
- 严格区分大小写，不限制起名长度，尽量达到见名知意
*** 命名的规范
一个标识符可以由一个单词或者多个单词拼接而成
**** 驼峰命名法：
- 类名字/接口名字
  首字母大写，第二个单词首字母大写
  + AaaBbbCcc
  + HelloWorld Demo
  + UserService
  + ProdService
- 方法的名字/变量名字
  首字母小写，每个单词首字母大写
  + xxxYyyZzz
  + helloWorld demo
  + String userName = "zs";
  + int userId=3;
- 如果用作常量名称，则所有单词全部大写，单词之间用下划线连接
  final PI_NUM=3.14;
- 转悠名词通常全部大写
  String NBA="nba";
- 包名
  + 单级：xxx
  + 多级：xxx.yyy.zzz(cn.tedu.day01)(这个整体不是标识符，cn是标识符,tedu是标识符,day01是标识符)
- 常用名
  XXX_YYY_ZZZ
** 数据
*** 程序概述
程序 = 数据+逻辑
*** 数据类型
- 基本数据类型
  整数、浮点、字符、 布尔
- 引用数据类型
  数组、类、接口
*** 常量
在代码的执行过程中值不发生改变的量
**** 整数类型
**** 浮点类型
如1.0、-3.15、3.168等
**** 布尔类型
true false
**** 字符类型
+ 如'a' 'A' '0' '家'
+ 字符必须使用''包裹，并且其中智能且仅能包含一个字符
**** 字符串类型
+ 字符串String类型是一种引用类型
+ 如"我爱你"  "01234" "null"
+ 字符串必须使用""包裹，其中可以包含0~N个字
**** 空常量
null
*** 整数的四种不同的表现形式(进制)
进制：进位的一种方式（逢X进1）
+ 计算机底层用的是二进制
**** 二进制：
1. 0~1，满2进1，1+1=10，11+1=100，在JDK1.7之前，程序中不允许定义二进制数字；
2. 从JDK1.7开始，允许在程序中定义二进制数字,但必须以0b/0B作为开头;0b000111 0B101101
**** 八进制：
0~7，满8进1，7+1=10，17+1=20，77+1=100，要求以0作为开头  05
**** 十进制：
0~9，满10进1，数字如果没有特殊表示，就默认是十进制
**** 十六进制：
0~9，a~f，满16进1，8+1=9，9+1=A，A+1=B，F+1=10，39+1=3A,99+1=9a，9f+1=A0，ff+1=100，要求以0X/0x作为开头 0x5 0xAF
**** 举例
#+BEGIN_SRC java
class JavaDemo2{
    public static void main(String[] args){
        //输出二进制数
        System.out.println(0b100);
        //输出八进制
        System.out.println(0100);
        //输出十进制
        System.out.println(100);
        //输出十六进制
        System.out.println(0x100);
    }
}
#+END_SRC
**** 进制转换
***** 其他进制转换为十进制
****** 二进制转换为十进制
#+BEGIN_VERSE
从低位次（数字最右边是低位次）开始，按位次乘以2的位次次幂，然后求和
#+END_VERSE
[[./Img/16.png]]
#+BEGIN_VERSE
100 ---> 4
=1*2^2 + 0*2^1 + 0*2^0
=4
1101 ---> 13
= 1*2^0 + 0*2^1 + 1*2^2 + 1*2^3
=13
#+END_VERSE
****** 十六进制转换为十进制
[[./Img/18.png]]
#+BEGIN_VERSE
522 ---> 1314
=5*16^2 + 2*16^1 + 2*16^0
=1314
基数：X进制 X
位：每位上的数
权：从右往左由0开始编号
规律：位乘以基数的权次幂之和
#+END_VERSE
***** 十进制转换为其他进制
****** 十进制转换为二进制
+ [[./Img/19.png]]
+ 十进制 14 ---> 二进制 1110
+ 规律：除基取余，直至商为0，余数翻转
***** 任意进制直接的转换
****** 二进制向八进制转换
[[./Img/20.png]]
#+BEGIN_VERSE
三变一----从低位次开始，每三位二进制划分为一组，产生一个八进制数字，最高位可能不足三位，补0，补齐三位，然后也产生一个八进制数字
1100110 = 0146
001 100 110
001 = 1
100 = 4
110 = 6
#+END_VERSE
****** 八进制向二进制转换
[[./Img/21.png]]
#+BEGIN_VERSE
一变三----每一位八进制都会产生三位二进制数字
0527 = 101 010 111
   5 = 101
   2 = 010
   7 = 111
#+END_VERSE
****** 二进制转十六进制
[[./Img/22.png]]
#+BEGIN_VERSE
四变一----每四位产生一位十六进制
1110101101 = 0x3ad
      1101 = d(13)
      1010 = a(10)
      0011 = 3
#+END_VERSE
****** 十六进制转二进制
[[./Img/23.png]]
#+BEGIN_VERSE
一变四
0xe3c = 1110 0011 1100
e(14) = 1110
    3 = 0011
c(12) = 1100
#+END_VERSE
****** 以十进制为中转进行转换
#+BEGIN_VERSE
X进制先转为十进制，这个十进制转换为Y进制
二进制 101 ---> 八进制 5
= 1*2^2 + 1*2^0
= 5
#+END_VERSE
****** 15*4=120是几进制？
将对应的进制设为n，将等号两边的都转换为10进制进行计算

(5*n^0 + 1*n^1)*(4*n^0) = 0*n^0 + 2*n^1 + 1*n^2

****** 拆分组合
+ 三个二进制的数范围为0~7（000~111），0~7可以看做是8进制
******* 二进制--->八进制（三变一）
#+BEGIN_VERSE
从低位次开始，每三位二进制划分为一组转换为十进制数，最高位可能不足三位，用0补齐三位
1100110 ---> 001100110 ---> 001 100 110 ---> 1 4 6
1100110 ---> 0146(八进制以0开头)
#+END_VERSE
******* 八进制--->二进制（一变三）
0527 ---> 101010111
******* 二进制转换为十六进制（四变一）
1110101101 ---> 0011 1010 1101 ---> 3 10 13 ---> 3 a d ---> 0x3ad
******* 十六进制--->二进制（一变四）
0xe3c ---> e 3 c ---> 14 3 12 ---> 1110 0011 1100 ---> 111000111100
**** 小数十进制转为二进制
+ 3.28 = 11.0 1 0 0 0 1 1 1...
+ 0.28*2 = 0.56*2 = 1.12->0.12*2 = 0.24*2 = 0.48*2 = 0.96*2 = 1.92->0.92
- 整数部分除以2转换为二进制，小数部分乘以2取结果的整数部分，然后继续乘以2取结果整数部分，无限循环...
- 绝大部分小数底层二进制是一个无限位数，表示的不精准，导致计算机在存储小数的时候是不精准的
**** 有符号的数（原码、反码、补码）
计算机的底层运算是以二进制的补码进行运算的,所有的数据在底层都是二进制数据补码形式表示的原码、反码、补码
***** 表示有符号的数去表示5和-5
|------+--------+---------|
| 原码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 0000101 |
|------+--------+---------|
正数的符号位是0，负数是1
|------+--------+---------|
| 反码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 1111010 |
|------+--------+---------|
正数的反码和原码一致，负数的反码是在原码的基础上符号位不变，其他为取反
|------+--------+---------|
| 补码 |        |         |
|      | 符号位 |  数值位 |
|    5 |      0 | 0000101 |
|   -5 |      1 | 1111011 |
|------+--------+---------|
正数的原、反、补一致，负数的补码是在反码的基础上符号位不变，其他在反码的基础上+1
***** 计算机的底层运算是以二进制的补码进行运算的
-4+1 = -3
|----------+----------+----------+----------+------+----|
| 10000000 | 00000000 | 00000000 | 00000100 | 原码 |    |
| 11111111 | 11111111 | 11111111 | 11111011 | 补码 | -4 |
| 11111111 | 11111111 | 11111111 | 11111100 | 反码 |    |
|----------+----------+----------+----------+------+----|
|          |          |          |          |      | +1 |
|----------+----------+----------+----------+------+----|
| 11111111 | 11111111 | 11111111 | 11111101 | 补码 |    |
| 11111111 | 11111111 | 11111111 | 11111100 | 反码 | -3 |
| 10000000 | 00000000 | 00000000 | 00000011 | 原码 |    |
|----------+----------+----------+----------+------+----|
* Java基本语法组成
** 变量
- 变量概述
  + 在代码执行过程中值发生改变的量
  + 变量是内存中装载数据的容器
*** 计算机存储单元
- 在计算机中，是以二进制形式来存储数据，每一位二进制在内存中称之为一“位”(bit,简写为b)
- 变量是内存中最小的容器，用来存储数据
- 计算机存储的最小单位叫 "位（bit）"，又称之为"比特位"，通常以小写的"b"表示
- 计算机存储空间的计量单位为"字节（byte）为最小的存储单元，通常用大写"B"表示，字节由连续的8个位组成
  #+BEGIN_EXAMPLE
  8bit = 1byte
  1024B = 1KB
  1024KB = 1MB
  1024MB = 1GB
  1024GB = 1TB
      ...
  100Mb = 12.5MB
  #+END_EXAMPLE
*** 基本类型之4类8种
- 数据类型分为基本数据类型和引用数据类型（数组、类、接口）
- 变量必须要有明确的类型，什么类型的变量装载什么类型的数据
  + 基本数据类型（4类8种)
    | 整数             | 占用内存（字节） | 表示范围                                         |
    |------------------+------------------+--------------------------------------------------|
    | byte（字节）     |                1 | -128（-2^7） ~ 127(2^7-1)                        |
    | short（短整型）  |                2 | -23767-(2^15) ~ 32767(2^15-1)                    |
    |                  |                  |                                                  |
    | int（整型）      |                4 | -2147483648(-2^31) ~ 2147483648(2^31-1)          |
    | long（长整型）   |                8 | -2^63  ~ 2^63-1                                  |
    | float（单精度）  |                4 | -3.403E38(-10^38) ~ 3.403E38(10^38)              |
    | double（双精度） |                8 | -1.798E308(-10^308) ~ 1.798E308(10^              |
    | boolean          |                1 | 只有两个值true与false                            |
    | char             |                2 | 0 ~ 65535   表示一个字符，如（'a' 'A' '0' '家'） |
    |------------------+------------------+--------------------------------------------------|
    - 文字转成数字---编码     转换规则--编码表
  + 4e4 = 4*10^4 表示十进制的科学计数法
  + 0x5p3 = 5*2^3 表示的是十六进制的科学计数法
  + 整数默认为int，小数默认为double
  + long类型需要在结尾添加l/L作为标识：long l = 10L;
  + float类型需要在结尾添加f/F作为标识：float f = 3.5f;
  + 一个字符直接量只能代表一个字符，不可以在一个字符直接量中写入多个字符，不允许有空的字符直接量
    [[./Img/24.png]]
  + 引用数据类型（复杂数据类型）
**** 表示范围是怎么来的
***** 整数类型
#+BEGIN_VERSE
byte ---> 1byte = 8bit ---> 1bit表示两个二进制数：0或者1;2bit表示四个二进制
数：00、11、01、10;3bit表示8个二进制数：000、001、011、010、111、101、
110、100,以此类推,1byte表示2^8（256）个二进制数，正数最大的是01111111也可以理解为10000000-1（2^7-1）
所以范围为：-128~127
short ---> 2byte = 16bit ---> -2^15 ~ 2^15 - 1
int ---> 4byte = 32bit ---> -2^31 ~ 2^31 - 1
long ---> 8byte = 64bit ---> -2^63 ~ 2^63 - 1
#+END_VERSE
***** 浮点型
float --->4byte

**** 文字转成数字----->编码
字符在存储过程中需要按照某周规则转化为数字，这种转化规则称之为编码，记录编码形成的表格形式称之为编码表---码表
|-----------------+---------+---------------------------------------------|
| 转换规则        | ------> | 编码表                                      |
| ASCII           |         | （阿斯科码表  128位 占一个字节）            |
| ISO8859-1       |         | （西欧码表    256位 占一个字节）            |
| GB2312          |         | （简体中文          占两个字节）            |
| Big5            |         | （繁体              占两个字节）            |
| GBK             |         | （国标码            占两个字节）            |
| Unicode编码体系 |         | （utf-8占三个字节 utf-16占两个字节 utf-32） |
|-----------------+---------+---------------------------------------------|
#+BEGIN_VERSE
char c = 'a' '中'; 用的是GBK，内存占几个字节？
'a'占一个字节
'中'占两个字节
所有的完整码表默认兼容西欧码表
#+END_VERSE
**** 转义字符
[[./Img/25.png]]
*** 常量与类型
- java中默认的整数类型是int类型
- java中默认的浮点型是double类型
  1. 3.14没有后缀，所以为double类型
  2. 5.28D为double类型
  3. 1.26F为float类型
*** 定义变量(创建变量)
**** 数据类型
限制数据的变化范围
**** 变量名
区分其他变量
**** 初始化
保证变量操作之前有数据
**** 定义格式
数据类型 变量名 = 数据值;
int    a    =  100;
**** 变量声明
int j;
**** 变量赋值
j = 6;
#+BEGIN_SRC java
/*
  定义Java中的变量
  定义出所有数据类型的变量
  四类八种
,*/
class VariableDemo{
    public static void main(String[] args){
    //定义整数类型，字节类型byte类型
    //内存中1个字节，-128 ~ 127
    byte b = 100;
    System.out.println(b);

    //定义整数类型，短整型，short类型
    //内存中2个字节，-32768 ~ 32767
    short s = 200;
    System.out.println(s);

    //定义整数类型，整型，int类型
    //内存中4个字节，-2147483648 ~ 2147483647
    int i = 500006;
    System.out.println(i);

    //定义整数类型，长整型，long类型
    //内存中8个字节
    long l = 21474836470L;
    System.out.println(l);

    //定义浮点数据类型，单精度，float类型
    //内存中4个字节
    float f = 1.0F;
    System.out.println(f);

    //定义浮点数据类型，双精度double类型
    //内存中8个字节
    double d = 2.2;
    System.out.println(d);

    //定义字符类型，char
    //内存中2个字节，必须单引号包裹，只能写1个字符
    char c = '我';
    System.out.println(c);

    //定义布尔类型，boolean
    //内存中1个字节，数据值，true false
    boolean bool = true;
    System.out.println(bool);
    }
}
#+END_SRC
*** 定义字符串变量
#+BEGIN_SRC java
/*
  常量：字符串，双引号，包裹，“0 ~ n”
,*/
class Variable_1{
    public static void main(String[] args){
        //定义变量，字符串类型，数据类型String表示字符串的数据类型
        String s = "我爱Java";
        //String属于引用类型，定义方式和基本类型一样
        System.out.println(s);

    }
}
#+END_SRC
*** 变量定义使用注意事项
- 变量定义后可以不赋值，使用时在赋值，不赋值不能使用
  #+BEGIN_SRC java
  class Variable_2{
      public static void main(String[] args){
          int x;
          x = 20;
          System.out.println(x);
      }
  }
  #+END_SRC
- 变量使用是有自己的作用范围，变量的有效范围是只在定义的一对大括号内
  #+BEGIN_SRC java
  class Variable_3{
      public static void main(String[] args){
          int i = 5;
          System.out.println(i);
          {
              int j = 10;
          }
          System.out.println(j);
          }
      }
  #+END_SRC
- 变量不可以重复定义
*** 数据类型转换
范围小的数据类型值（如byte），可以直接转换为范围大的数据类型值（如int）

byte、char、short只要做操作都会类型提升为int类型(byte、char、short在底层是按照int类型进行存储的)

范围大的数据类型值（如int），不可以直接转换为范围小的数据类型值（如byte）
#+BEGIN_SRC java
class DataTypeDemo{
    public static void main(String[] args){
        //相同数据类型
        int a=1;
        int b=2;
        System.out.println(a+b);
        //不同数据类型
        byte b1=3;
        int i=5;
        int c=b1+i;
        System.out.println(c);

        //byte --- short 可以
        /*byte b1 = 10;
        short c2=b;*/

        //java会进行类型检查，如果是字符就会安装对应的编码就会转换成对应的数值在赋值给变量s
        //如果这个数值不在变量的表示范围之内就会报错
        short s='中';
        char c3=97;
        System.out.prtinln(c);
        //除了char类型其他的基本类型都会有负值
        //可能会导致出现负值char找不到对应的字符
        /*double s=-10;
        char c=s;*/
        char c4=19;
        int i4=c4;
        System.out.println(c4);
    }
}
#+END_SRC
[[./Img/26.png]]

[[./Img/27.png]]

如果=右边只有常量进行运算就会进行编译时期的优化，就会直接算出结果值在进行赋值

[[./Img/28.png]]

- 自动类型转换（范围小转大）
  范围大的数据类型 变量 = 范围小的数据类型值;
  double d = 1000;
- 强制类型转换（范围大转小）
  大类型可以强转为小类型，但是在转化的时候因为字节的损失所以可能导致数据不准确
  强制类型转换，没有要求的时候，不做
  范围小的数据类型 变量 = （范围小的数据类型）范围大的数据类型值;
  int i = (int)6.718; //i的值为6

  double d = 3.14;
  int i2 = (int)d;    //i2的值为3
  #+BEGIN_SRC java
  /*
    128 二进制
    00000000 00000000 00000000 10000000 int
    128int转为byte为：10000000 补码
                     11111111  反码
                     10000000  原码
    值为 -0   表示当前数据类型的最小值，为-128
  */
  class DataTypeDemo1{
      public static void mian(String[] args){
          //b11=-128
          byte b11 = (byte)128;
          System.out.println(b11);
      }
  }
  #+END_SRC
** 运算符
*** 算术运算符
**** 除法运算
- 如果都是整型数据进行操作，结果一定是整型
  i*1.0/j 结果就是浮点数
  #+BEGIN_SRC java
  class SuanShu{
      public static void main(String[] args){
          int i=900;
          int j=9;
          System.out.println(i/j);
          System.out.println(i*1.0/j);
      }
  }
  #+END_SRC
- 算术异常
  ArithmeticException:/by zero ---算术异常
  #+BEGIN_SRC java
  System.out.println(a/0);
  #+END_SRC
- Infinity -Infinity   正无穷大 负无穷大   java允许小数除0
  #+BEGIN_SRC java
  System.out.println(a*1.0/0);
  System.out.println(-a*1.0/0);
  #+END_SRC
- NaN -- not a Number
  #+BEGIN_SRC java
  System.out.println(-0.0/0.0);
  #+END_SRC
**** 取余%
取余结果的正负和%左边的正负一致
#+BEGIN_SRC java
System.out.println(-a%3);
#+END_SRC
**** ++ --
- 单独使用
  #+BEGIN_SRC java
  int a =4;
  int a1 = 4;
  //4
  System.out.println(a++);
  //5
  System.out.println(a);
  //4
  System.out.println(a1--);
  //3
  System.out.println(a1);

  //3
  System.out.println(--a);
  //3
  System.out.println(a);
  #+END_SRC
- 如果++或者--用在操作数的后面，先进行赋值，在进行自加或者更自减
- 如果++或者--用在操作数的前面，先自加1或者自减1，在进行赋值
- 参与运算
- =右边前面的值发生改变之后会影响后面的值
  #+BEGIN_SRC java
  b =++a+a--+a++;
  //14
  System.out.println(b);
  //5
  System.out.println(a);
  #+END_SRC
  [[./17.png]]
- byte、char、short使用++时底层都有强制类型转换
  #+BEGIN_SRC java
  //-128
  byte b = 127;
  b++;
  System.out.println(b);
  #+END_SRC
  #+BEGIN_SRC java
  //b
  char c='a';
  c++;
  System.out.println(c);
  #+END_SRC
  #+BEGIN_SRC java
  //-32768
  short s=32767;
  s++;
  System.out.println(s);
  #+END_SRC
  #+BEGIN_SRC java
  /*
    算术运算符
    + 加法，连接
    - 减法
    ,* 乘法
    /除法
    % 取模，获取余数
    ++ 自加1
    -- 自减1

    byte/short/char在 运算的时候会自动提升为int
    int在计算完成之后结果一定是int
    小类型和大类型运算的时候结果一定是大类型
    整数/0---算数异常
    非零小数/0 非零数字/0.0---infinity
    0/0.0 0.0/0 0.0/0.0---NaN
    %的结果的符号看的是%左边数字的符号
    ++/-- 自增/自减 ---在变量之前先自增后运算；在变量之后先运算后自增---在底层做了一次强制转换
    任何数据在计算机中存储的补码

    ,*/
  class Operator{
      public static void main(String[] args){
          // + 连接作用，将一个字符串和其他数据连接起来
          // + 遇到字符串，变成连接符号
          // + 任何类型只要和字符串+，所有的数据都变成了字符串
          System.out.println("5+5="10);

          //byte/short/char在参与运算的时候会自动提升为int
          byte i = 3, j = 4;
          //byte k = i + j;
          //k的类型必须是int
          byte k = (byte)(i + j);
          int k = i + j;

          //除法运算
          //如果都是整型数据进行操作，结果一定是整型
          int i = 100;
          int j = 9;
          System.out.println(i/j);
          //以下操作得到的不是整型
          System.out.println(i*1.0/j);

          //取模运算，两个数相除，获取的是余数
          int k = 6;
          int m = 2;
          System.out.println(k%m);

          //自增运算 ++
          int a = 3;
          int b = 4;

          a++;
          System.out.println(a);

          ++b;
          System.out.println(b);
      }
  }
  #+END_SRC

  #+BEGIN_SRC java
  /*
    ++ 写在变量前面，和写在变量后面的区别
    a = 1;
    a++;
    ++a;
    变量独立计算的时候，++在前在后没有区别
    j = i++; ---> ++ 后算，先将i的值，赋值j，i自己在++

    n = ++m; ---> ++ 先算，后将++过的值赋给n

  ,*/
  class Opeartor_1{
      public static void main(String[] args){
          int j = 5;
          int j = i++;
          System.out.println(i);//6
          System.out.println(j);//5

          int m = 5;
          int n = ++m;
          System.out.println(m);//6
          Syetem.out.println(n);//6
      }
  }
  #+END_SRC
  #+BEGIN_SRC java
  class SuanShu1{
      public static void main(String[] args){
          int a = 4;
          int b = 5;

          //整型和浮点型数据遇到字符会和字符对应的编码值进行相加
          System.out.println(a + b + 'a');
          //字符串可以和任意数据类型的数据进行拼接
          System.out.println(a + b + "c" + 'a');
          // + 可以是相加，也可以是字符串连接符
          System.out.println(a + b);
          System.out.println("A:" + a + ",B:" + b);

      }
  }
  #+END_SRC
*** 赋值运算符
[[./Img/29.png]]
#+BEGIN_SRC java
/*
  赋值运算符
  =
  += -= *= /= %= &= |= ^= <<= >>= >>>=
  ,*/
class Operator_4{
    public static void main(String[] args){
        //= 赋值运算，将后面的值，赋值给左边的变量
        int i = 3;
        i = i + 3;
        System.out.println(i);

        //+= 赋值运算符 i+=3 --->  i=i+3
        int j = 5;
        j+=6;//j=j+6;
        System.out.println(j);

        //byte char short 使用++ --时底层都是强制类型转换
        byte b = 1;
        // b = b + 1;//无法进行相加，需要进行强制转换
        b = (byte)(b+1);
        System.out.println(b);

        byte b1 = 1;
        b1 += 1;//等同于(byte)(b + 1);
        System.out.println(b1);

    }
}
#+END_SRC
**** b+=a;//11 b=a+b;底层会默认加上强制类型转换
      #+BEGIN_SRC java
          byte a=10;
          byte b=1;
          b+=a;//11 b=a+b;
          System.out.println(b);
      #+END_SRC
**** 连等定义？
      #+BEGIN_SRC java
          int x=y=z;//不支持
          int x=1,y=3,z=2;//支持
      #+END_SRC
**** 连等赋值?
      [[./Img/30.png]]
      #+BEGIN_SRC java
          byte a=4;
          byte b=1;
          b=a+=a-=a+=a*=5;
          System.out.println(b);//-16
          System.out.println(a);//-16
      #+END_SRC
      等号后面的值如果改变不会影响前面得值
      #+BEGIN_SRC java
          byte a=4;
          byte b=1;
          b=a+=a-=a+=a*=++a;
          System.out.println(b);//-16
      #+END_SRC
*** 关系运算符
==、>、<、> =、< =、! =
比较（关系）运算符--结果一定是布尔值
*** 逻辑运算符
用于连接布尔值或者布尔表达式的符号
**** 表达式：
用于连接变量或者数据，而且符合java语法的式子
a+b(算术表达式)
a<b(布尔表达式)
&(逻辑与)  |逻辑或   ^逻辑异或  ！逻辑非  ||双或
**** 总结：
逻辑运算符，对两个BOOLEAN类型数据之间进行计算
结果也是BOOLEAN类型

&（按位与）       :只要有一个FALSE，结果就FALSE
(或)|           :只要有一个TRUE，结果就是TRUE
^（按位异或）     :两边相同为FALSE，不同为TRUE
!(非)           :取反 !TRUE = FALSE  !FALSE = TRUE
&&(短路与.逻辑与) :一边是FALSE，另一边不运行;左边是false，则右边默认不执行--短路
(短路或逻辑或)||  :一边true，另一边不运行;如果左边是true，则右边就默认不执行--短路

如果双或在双与的前面，双或发生短路，就会把双与一起短路掉
&&和||优先级一样
开发中常用双与和双或
#+BEGIN_SRC java
class Operator_5{
    public static void main(String[] args){
        System.out.println(false & true);
        System.out.println(false | true);
        System.out.println(false ^ false);//F
        System.out.println(true ^ true);//T
        System.out.println(true ^ false);//F

        System.out.println(!true);
        System.out.println("--------------------------------");
        int i = 3;
        int j = 4;
        System.out.println(3>4 && ++j>2);
        System.out.println(i);
        System.out.println(j);

        System.out.println(3==3 || ++j>2);
        System.out.println(i);
        System.out.println(j);

        //&&在||前面时，不能短路||
        int i1=3,j1=5;
        boolean b1 = false && i1++ > 1 || j1++>3;
        System.out.println(i1);
        System.out.println(j1);
        System.out.println(b1);

        //||在&&前面时，短路&&
        int i2=3,j2=5;
        boolean b2 = true || i2++ > 6 && j2++ > 10;
        System.out.println(i2);
        System.out.println(j2);
        System.out.println(b2);

    }
}
#+END_SRC
#+BEGIN_SRC java
class Luoji{
    public static void main(String[] args){
        int a=3;
        int b=4;
        int c=5;
        int a1=3;
        int b1=4;
        int c1=5;
        int a2=3;
        int b2=4;
        int c2=5;
        int a3=3;
        int b3=4;
        int c3=5;
        int a4=3;
        int b4=4;
        int c4=5;
        System.out.println((a++==b)&&(c++>b));
        //4,4,5
        System.out.println(a+","+b+","+c);

        System.out.println((c1++>b1)&&(a1++==b1));
        //4,4,6
        System.out.println(a1+","+b1+","+c1);

        System.out.prtinln(true&&(a2++!=b)||(c2++>b2));
        //4,4,5
        System.out.println(a2+","+b2+","+c2);

        System.out.prtinln(false&&(a3++!=b)||(c3++>b3));
        //3,4,6
        System.out.println(a3+","+b3+","+c3);

        //如果双或在双与的前面，双或发生了短路就会把双与一起短路掉
        // System.out.println(true||(a4++!=b4)&&(c4++>b4));
        //3,4,5
        // System.out.println(a4+","+b4+","+c4);
        System.out.println(true&&c4++>b4);
        System.out.println(c4);
    }
}
#+END_SRC
*** 位运算符
要把数据转成二进制的补码形式才能进行位运算
移位的位数要对32进行取余，取余的结果才是真正移动的位数--规定
**** &（按位与） |（按位或） ^（按位异或）
任意一个数&1==1就是奇数
任意一个正数&任意一个数=正数
任意一个负数|任意一个数=负数
任意一个数|0=原来的值

      4 & 5=4 遇0则0
        4 00000000 00000000 00000000 00000100
      & 5 00000000 00000000 00000000 00000101
      --------------
        4 00000000 00000000 00000000 00000100

      4 | 5=5 遇1则1
        4 00000000 00000000 00000000 00000100
      | 5 00000000 00000000 00000000 00000101
      --------------
        5 00000000 00000000 00000000 00000101

      4 ^ 5 =1 相同则0 不同则1
        4 00000000 00000000 00000000 00000100
      ^ 5 00000000 00000000 00000000 00000101
      --------------
        1 00000000 00000000 00000000 00000001
      ~ 4=
        4 00000000 00000000 00000000 00000100 补
          11111111 11111111 11111111 11111010 反
       -5 10000000 00000000 00000000 00000101 原
      [[./Wei.java]]
**** <<左移 >>右移 >>>无符号右移 ~取反
***** >>
如果是正数右移几位就在最左边补几个0;如果是负数右移几位就在最左边补几个1;如果是正数右移几位，操作数/2^移动位数
***** <<
无论正负数左移几位最右边就补几个0,左移几位，操作数*2^移动位数

***** >>>
一定是正数,无论正负数右移几位，就在最左边补几个0
***** 示例
#+BEGIN_SRC
      4 >> 2
      4 [00]00000000 00000000 00000000 000001(00)
      1     00000000 00000000 00000000 00000001

      4 << 2
      4  (00)00000000 00000000 00000000 00000100[00]
      16     00000000 00000000 00000000 00010000

      4 >>> 2
      4 [00]00000000 00000000 00000000 000001(00)
      1     00000000 00000000 00000000 00000001
#+END_SRC
      #+BEGIN_SRC java
      class WeiDemo4{
          public static void main(String[] args){
              // >>
              System.out.println(4>>2);//4/2^2
              // <<
              System.out.println(4<<2);//4*2^2
              //>>>
              System.out.println(4>>>2);
          }
      }
      #+END_SRC
**** 按位异或的扩展
如果一个数按位异或上另一个数两次，结果就是本身
**** 交换值的方式：
- 方式一：异或法
  int x = 5
  int y = 7

  x = x ^ y;
  y = x ^ y; ---> y = x ^ y ^ y; ---> y = x; ---> y = 5;
  x = x ^ y; ---> x = x ^ y ^ x; ---> x = y; ---> x = 7;
  #+BEGIN_SRC java
  class WeiDemo2{
      public static void main(String[] args){
          int a=4;
          int b=5;
          //按位异或
          a=a^b;
          b=a^b;
          a=a^b;
          System.out.println("a:"+a+",b:"+b);

      }
  }
  #+END_SRC
- 方式二：加减法
  int x = 3;
  int y = 7;

  x = x + y;
  y = x - y; ---> y = x + y - y; ---> y = x; ---> y = 3;
  x = x - y; ---> x = x + y - x; ---> x = y; ---> x = 7;
  #+BEGIN_SRC java
  class WeiDemo3{
      public static void main(String[] args){
          int a=4;
          int b=5;
          a=a+b;
          b=a-b;
          a=a-b;
          System.out.println("a:"+a+",b:"+b);
      }
  }

  #+END_SRC
- 方式三：第三方变量
  int x = 3;
  int y = 7;
  int z = x;
  x = y;
  y = z;
  #+BEGIN_SRC java
  class WeiDemo1{
      public static void main(String[] args){
          int a=4;
          int b=5;
          //中间变量
          int temp=a;
          a=b;
          b=temp;
          System.out.println("a:"+a+",b:"+b);
      }
  }
  #+END_SRC
- 扩展：考虑三种方式的优劣性
  异或法的效率最高，但使用频率最低            ---只能适用于整数值的交换
  加减法的效率低于异或法，但是高于第三方变量法  ---理论上适用于数值型（小数运算不准确）
  第三方变量法的效率最低，但是使用频率是最高的  ---适用于所有的类型
*** 运算符的优先级
() ~ ++ -- ! * / % + - << >> >>> 关系 逻辑 & | ^ 三元 赋值
#+BEGIN_SRC java
class OperatorDemo121{
    public static void main(String[] args){
        /*
          如果算术比关系的优先级高，就先算2+5 =7，然后比较3>7，所以结果是false
          如果关系比算术高，就先算3>2 = true,然后计算true + 5，因为类型不能转换，所以会报错
          System.out.println(3>2+5);
        ,*/

        /*
          如果先算的是关系，那么就先计算2>3=false,然后计算true&&false = false
          如果先计算逻辑，那么先算true&&2不能计算，会报错
          System.out.println(true&&2>3);
        ,*/

        /*
          如果位比算术优先级高，先算5&1=1，然后计算3+1=4
          如果算术比位的高，先算3+5=8，然后计算8+1=0
          System.out.println(3 + 5 & 1);
        ,*/

        /*
          位>关系   ----true
          位<关系   ----报错
          System.out.println(3 > 5 & 1);
        ,*/

        /*
          算术>位 ---20
          位>算术 ---11
          System.out.println(3 + 2 << 2);
        ,*/

        /*
          位>关系 ---false
          关系>位 ---报错
          System.out.println(3 > 2 << 2);
        ,*/

        /*
          ~>算术 ---2
          算术>~ --- -8
          System.out.println(~2 + 5);
        ,*/
    }
}
#+END_SRC
*** 三元运算符
**** 格式和执行流程
格式：
表达式（布尔值） ? 表达式值1:表达式值2;
执行流程：
先去计算表达式的值，如果这个值是true，就把表达式值1返回，
如果这个值是false，就把表达式值2进行返回
**** 示例
***** 求两个整数的最大值
#+BEGIN_SRC java
class Operator_6{
    public static void main(String[] args){
        //求两个整数的最大值
        int a=5;
        int b=9;
        //有另一个变量来接收值得时候，要保证这个变量的类型和两个表达式值的类型一致
        System.out.println(max);
        //连个表达式值的类型可以不一样但是有个前提，没有另一个变量来接收返回值
        System.out.println(a>b?'a':true);
    }
}
#+END_SRC
***** 求三个整数的最大值
#+BEGIN_SRC java
class Operator122{
    public static void main(String[] args){
        int i = 3,j = 8,k = 5;
        //三元表达式的嵌套
        int max = i > j ? (i > k ? i : k) : (j > k ? j : k);
        System.out.println(max);

        /*int max = i > j ? i : j;
        max = max > k ? max : k;
        System.out.println(max);
        ,*/
    }
}
      #+END_SRC
***** 判断一个数是奇数还是偶数
#+BEGIN_SRC java
class Operator133{
    public static void main(String[] args){
        //定义一个整数变量，判断这个整数是一个寄数还是一个偶数
        int num = 15;
        String str = (num % 2) == 1 ? "奇数" : "偶数";
        //String str = (num & 1) == 1 ? "奇数" : "偶数";
        System.out.println(str);
    }
}
#+END_SRC
***** 分数评级
#+BEGIN_SRC java
class Operator134{
    public static void main(String[] args){
        /*
          定义一个变量表示分数:
          分数 >= 90 ----- A
          分数 >= 80 ----- B
          分数 >= 70 ----- C
          分数 >= 60 ----- D
          分数 <  60 ----- E
        ,*/
        double score = 79.5;
        char level = score >= 90 ? 'A' :
        (score >= 80 ? 'B' :
        (score >= 70 ? 'C' :
        (score >= 60 ? 'D' : 'E')));
        System.out.println(level);
    }
}
#+END_SRC
***** 平年还是闰年
#+BEGIN_SRC java
class Operator135{
    public static void main(String[] args){
        /*
          定义一个变量表示年份，判断这一年是平年还是闰年：
          逢百年整除400,不是百年整除4
          2000 --- 闰年
          2100 --- 平年
          2012 --- 闰年
        ,*/
        int year = 2900;
        String str = year % 100 == 0 ?
        (year % 400 == 0 ? "闰年" : "平年") :
        (year % 4 == 0 ? "闰年" : "平年");
        System.out.println(str);
    }
}
#+END_SRC
** 引用数据类型
*** Scanner类
步骤：
    1.导包
    2.找到Scanner
    3.获取数据
#+BEGIN_SRC java
import java.util.Scanner;
class JavaDemo{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int num =sc.netxInt();
        //System.out.println(num);
        String s=sc.next();
        System.out.println(s);
    }
}
#+END_SRC
**** 引用数据类型的使用
数据类型 变量名 = new 数据类型（）;
调用该类型实例的功能：
变量名.方法名();
**** Scanner类
完成用户键盘录入，获取到录入的数据
***** Scanner使用步骤
导包：import java.util.Scanner;
创建对象实例：Scanner sc = new Scanner(System.in);
调用方法：
        int i = sc.nextInt();用来接收控制台录入的数字
        String s = sc.next();用来接收控制台录入的字符串
#+BEGIN_SRC java
/*
  引用数据类型，介绍一个类Scanner
  java中已经存在，是sun公司为用户做好的类
  用他定义引用数据类型变量，和基本类型变量区别
  int a=1;
  格式：
      类型 变量名 = new 类型（）；
      举例：创建出Scanner类的变量
      Scanner sc = new Scanner（）;
      int a = 1;
      每个引用类型，都有自己的功能，如何使用功能
      公式：
          变量.功能名字();
          Scanner类，作用，让我在命令行中，接受键盘的输入
,*/
import java.util.Scanner;
public class ScannerDemo{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        System.out.println(num);

        String s = sc.next();
        System.out.println(s+1);
    }
}
#+END_SRC
*** 随机数类Random
用于产生随机数的类
#+BEGIN_SRC java
/*
  java中已经有的引用类型  Random类,作用，产生随机数
  步骤：
      1. 导入包，Random，也在java.util文件夹
      2. 公式：创建出Random类型的变量
         数据类型  变量名 = new 数据类型();
      3. 变量. 调用Random类中的功能，产生随机数
         Ramdom类，提供功能，名字 nextInt()产生一个随机数，结果是int类型
         出现随机数的范围，在功能nextInt(写一个整数)，整数：随机出来的范围
         随机数的范围在0~指定的整数之间的随机数 nextInt(100) ---> 0~99

         产生浮点数的随机数：功能名字 nextDouble() 随机数的范围 0.0~1.0

         随机数：伪随机数，虚拟机根据人写好的一个算法，生成出来的
,*/
import java.util.Random;
public class RandomDemo{
    public static void main(String[] args){
        Random ran = new Random();
        int i =ran.nextInt(50);
        System.out.println(i);

        //问题？产生随机数，范围1~100之间
        //nextInt（100）---> 0~99+1

        double d = ran.nextDouble();
        System.out.println(d);
    }
}
#+END_SRC
** 流程控制语句
- 顺序结构
  java中绝大部分的代码都是从上往下，由左往右依次执行执行
- 选择结构
  if语句
  switch语句
- 循环结构
  for
  while
  do...while
*** 选择结构
**** if
***** if语句：
编写格式：if（判断条件）{语句体;}
执行流程：先去计算判断条件的值，如果是true就去执行语句体，
如果是false就跳过不执行，执行其他语句
#+BEGIN_SRC java
import java.util.Scanner;
class IfDemo{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int money=sc.nextInt();
        if(money > 999){
            System.out.println("OKOKOK~~~");
        }
        System.out.println("Over");
    }
}
#+END_SRC
****** 输入三个整数，打印这三个整数中的最大值
#+BEGIN_SRC java
import java.util.Scanner;
public class IfElseExer{
    public static void main(String[] args){
        //输入三个整数，打印这三个整数中的最大值

        Scanner s = new Scanner(System.in);
        int i = s.nextInt();
        int j = s.nextInt();
        int k = s.nextInt();

        /*
          if(i > j){
              if(i > k){
                  System.out.println(i);
              }else{
                  System.out.println(k);
              }
          }else{
              if(j > k){
                  System.out.println(j);
              }else{
                  System.out.println(k);
              }
          }
        */

        //定义变量记录最大值
        int max = i;
        if(max < j){
            max = j;
        }
        if(max < k){
            max = k;
        }
        System.out.println(max);
    }
}
#+END_SRC
***** if...else语句
编写格式：if(判断条件){语句体1;}else{语句体2;}
执行流程：先去计算判断条件，如果是true就执行语句体1，如果false就执行语句体2
如果if语句格式2返回的是一个值就和三目等效
****** 举例
1. 求两个整数的最大值
   #+BEGIN_SRC java
   int a=10;
   int b=1;
   if(a>b){
       System.out.println(a);
   }else{
       System.out.println(b);
   }
   #+END_SRC
   [[./IfDeo2.java]]
2. 求三个整数的最大值
   #+BEGIN_SRC java
   int a=10;
   int b=1;
   int c=8;
   if(a>b){
       if(a>c){
           System.out.println(a);
       }else{
           System.out.println(c);
       }
   }else{
       if(b>c){
           System.out.println(b);
       }else{
           System.out.println(c);
       }
   }
   #+END_SRC
   [[./IfDemo3.java]]
***** if...else if...else语句
适合在程序中，实现多条件的判断
编写格式：
       if(判断条件1){
           语句体1;
       }else if(判断条件2){
           语句体2;
       }else if(判断条件3){
           语句体3;
       }
            ...
       else{
           语句体n+1;
       }
执行流程：
       先计算判断条件1，如果是true，就执行语句体1，
       如果是false就去计算判断条件2，如果是true就执行语句体2
       如果是false就去计算判断条件3，如果是true就执行语句体3，
       如果全部false就执行语句体n+1
#+BEGIN_SRC java
//根据输入的星星数展示用户的段位
Scanner sc=new Scanner(System.in);
int xing=sc.nextInt();
if(xing>=0&&xing<10){
    System.out.println("C");
}else if(xing>=10&&xing<20){
    System.out.println("B");
}else if(xing>=20&&xing<30){
    System.out.println("A");
}else if(xing>=30&&xing<90){
    System.out.println("S");
}else if(xing>=90&&xing<100){
    System.out.println("S+");
}else{
    System.out.println("XXXX");
}
#+END_SRC
***** 选择结构if语句与三元运算转换
要求：已经知道两个数，计算最大值
     两个整数，比较大小

     使用if还是三元
     判断条件多，使用if语句
     三元，必须有结果，if可以没有结果
#+BEGIN_SRC java
public class IfElseDemo{
    public static void main(String[] args){
        int i = 15;
        int j = 6;
        //使用if语句，判断出最大值
        if(i>j){
            System.out.println(i+"是最大值");
        }else{
            System.out.println(j+"是最大值")
        }

        //使用三元运算实现
        int k=i>j?i:j;
        System.out.println(k+"是最大值");
    }
}
#+END_SRC
**** switch
***** 选择结构switch
格式：
    switch(表达式){
        case 值1:
        语句体1;
        case 值2:
        语句体1;
        case 值3:
        语句体 3;
          ...
        default:
        语句体n+1;
        break;
    }
执行流程：计算表达式的值，拿到这个值和每个case后面的值依次进行比较，
         如果有case的值满足比较条件，就执行对应的语句体。如果都不满足就默认执行语句体n+1，语句结束。
switch语句中的表达式的数据类型，是有要求的
jdk1.0 ~ 1.4 数据类型接受 byte short int char
jdk1.5       数据类型接受byte short int char enum（枚举）
jdk1.7       数据类型接受byte short int char enum（枚举），string
#+BEGIN_SRC java
import java.util.Scanner;
    class SwitchDemo{
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int week = sc.nextInt();
            //switch语句
            switch(week){
                case 1:
                    System.out.println("星期一");
                    break;
                case 2:
                    System.out.println("星期二");
                    break;
                case 3:
                    System.out.println("星期三");
                    break;
                case 4:
                    System.out.println("星期四");
                    break;
                case 5:
                    System.out.println("星期五");
                    break;
                case 6:
                    System.out.println("星期六");
                    break;
                case 7:
                    System.out.println("星期日");
                    break;
                default:
                    System.out.println("星期不存在");
                    break;
            }
        }
    }
#+END_SRC
#+BEGIN_SRC java
import java.util.Scanner;
public class SwitchDemo1{
    public static void main(String[] args){
        //输入一个符号(+ - * /)，然后输入两个数字，根据给定的符号来计算两个数字的结果
        Scanner sc = new Scanner(System.in);
        String sym = sc.nextLine();
        double a = sc.nextDouble();
        double b = sc.nextDouble();
        switch(sym){
            case "+":
                System.out.println("a + b =",a + b);
                break;
            case "-":
                System.out.println("a - b =",a - b);
                break;
            case "*":
                System.out.println("a * b =",a * b);
                break;
            case "/":
                System.out.println("a / b =",a / b);
                break;
            default :
                System.out.println("Illegal symbol");
            }
        }
    }
#+END_SRC
***** case穿透
#+BEGIN_SRC java
/*
  switch特性：case穿透性
  案例：星期1 ~ 5输出，工作日，星期6 ~ 7  输出休息日
  case 1 case2...case5 输出结果相同

  case后面的常量和switch中数据相同，没有break，一直向下穿透
  case后面没有break，程序就会一直向下穿透
,*/
public class SwitchDemo_1{
    public static void main(String[] args){
        int week=1;
        switch(week){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("工作日");
                break;
            case 6:
            case 7:
                System.out.println("休息日");
                break;
            }
        }
    }
#+END_SRC
#+BEGIN_SRC java
import java.util.Scanner;
public class SwitchDemo2{
    public static void main(String[] args){
        /*输入三个数字分别表示年月日，计算这一天是这一年的第几天*/

        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        int month = sc.nextInt();
        int day = sc.nextInt();

        //定义变量记录总的天数
        int sum = 0;

        switch(month){
            //经历了一个完整的11月
            case 12:
                sum += 30;
                //经历了一个完整的10月
            case 11:
                sum += 31;
            case 10:
                sum += 30;
            case 9:
                sum += 31;
            case 8:
                sum += 31;
            case 7:
                sum += 30;
            case 6:
                sum += 31;
            case 5:
                sum += 30;
            case 4:
                sum += 31;
            case 3:
                if(year % 400 == 0 || year % 100 != 0 && year % 4 == 0){
                    sum += 29;
                }else{
                    sum += 28;
                }
            case 2:
                sum += 31;
            case 1:
                sum += 0;
            }
            sum += day;
            System.out.println(sum);
        }
    }
#+END_SRC
*** 循环结构
**** for
***** for循环
格式：
    for(初始值;判断值;控制条件){
        循环体;
    }

执行流程:
       1.先计算初始值
       2.初始值与判断条件进行判断
       3.如果是true，就执行循环体，执行完循环体之后执行控制条件
       4.执行完的值与判断条件进行判断
         如果是true就执行3，4操作；知道false出现就结束循环
#+BEGIN_SRC java
class ForDemo{
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            System.out.println("helloworld");
        }
    }
}
#+END_SRC
****** 举例
1. 输出0~10
   #+BEGIN_SRC java
   class ForDemo1{
       public static void main(String[] args){
           //print 0~10
           for(int i = 0;i<11;i++){
               System.out.println(i);
           }
       }
   }
   #+END_SRC
2. 输出1+4的结果
   #+BEGIN_SRC java
   /*
     利用for循环，计算1+4的结果
     1+2+3+4=10

     1+2的和+3
     1+2+3的和+4
   ,*/
   class ForDemo_1{
       public static void main(String[] args){
           //定义变量，记录求和后的数据
           int sum = 0;
           //利用循环，将变量从1变化到4
           for(int i=1;i<=4;i++){
               //对变量进行求和
               sum = sum + i;
           }
               System.out.println(sum);
           }
       }
   #+END_SRC
3. 计算1~n中的所有奇数和
   #+BEGIN_SRC java
   import java.util.Scanner;
   class ForDemoa{
       public static void main(String[] args){
           Scanner sc=new Scanner(System.in);
           int n=sc.nextInt();
           /*
             for(int i=1;i<=n;i+=2){
                 sum=sum+i;
             }
             System.out.println(sum);
           */
           for(int i=1;i<=n;i++){
               if((i&1)!=0){
                   sum+=i;
               }
           }
           System.out.println(sum);
       }
   }
   #+END_SRC

4. 计算1~n中的所有偶数和
   #+BEGIN_SRC java
   import java.util.Scanner;
   class ForDemo4{
       public static void main(String[] args){
           Scanner sc=new Scanner(System.in);
           int sum=0;
           int n=sc.nextInt();
           /*
             for(int i=0;i<=n;i+=2){
                 sum+=i;
             }
             System.out.println(sum);
           */
           for(int i=1;i<=n;i++){
               if((i&1)==0){
                   sum+=i;
               }
           }
           System.out.println(sum);
       }
   }
   #+END_SRC

5. 求5的阶乘
   #+BEGIN_SRC java
   class ForDemo5{
       public static void main(String[] args){
           int sum=1;
           for(int i=1;i<=5;i++){
               sum=sum*i;
           }
           System.out.println(sum);
       }
   }
   #+END_SRC

6. 在控制台输出所有水仙花数
   三位数 abc=a^3+b^3+c^3
   123 %10=3
   123 /10%10=2
   123 /100=1
   #+BEGIN_SRC java
   class ForDemo6{
       public static void main(String[] args){
           for(int i=100;i<1000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100;
               if(i==ge*ge*ge+shi*shi*shi+bai*bai*bai){
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC

7. 统计水仙花数有多少个
   #+BEGIN_SRC java
   class ForDemo7{
       public static void main(String[] args){
           int count=0;
           for(int i=100;i<1000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100;
               if(i==ge*ge*ge+shi*shi*shi+bai*bai*bai){
                   count++;
               }
           }
           System.out.println(count);
       }
   }
   #+END_SRC

8. 请在控制台输出满足如下条件的五位数
   个位数等于万位
   十位数等于千位
   个位数+十位数+千位数+万位数=百位数
   #+BEGIN_SRC java
   class ForDemo8{
       public static void main(String[] args){
           for(int i=10000;i<100000;i++){
               int ge=i%10;
               int shi=i/10%10;
               int bai=i/100%10;
               int qian=i/1000%10;
               int wan=i/10000;
               if((ge==wan)&&(shi==qian)&&(ge+shi+qian+wan==bai)){
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC

9. 请统计1~1000之间同时满足如下条件的数据有多少个
   对3整除余2
   对5整数余3
   对7整除余2
   #+BEGIN_SRC java
   class ForDemo9{
       public static void main(String[] args){
           int count=0;
           for(int i=1;i<1000;i++){
               if((i%3==2)&&(i%5==3)&&(i%7==2)){
                   count++;
               }
           }
           System.out.println(count);
       }
   }
   #+END_SRC

***** 增强for循环
底层的实质是迭代
- 格式：
      for(数据类型变量名 : 被遍历的集合或者数组){执行语句}
- 区别：
      必须有被遍历的目标（如集合或数组）
      不能获取下标
      把所有的数组元素拷贝一份拿过来新型输出
**** while
***** 循环语句while
循环次数不确定的时候，首选while
- 循环语句：可以让一部分代码，反复执行
- 编写格式：
          while(判断条件){
              循环体;
              控制条件;
          }
- 条件：
      当条件是true，就执行循环体，当执行完循环体后，程序再次执行while中的条件，
      如果条件是true，继续执行循环体，直到条件是false的时候，循环就结束
      需要定义变量来控制循环的次数
#+BEGIN_SRC java
class WhileDemo{
    public static void main(String[] args){
        int i=1;
        while(i<=10){
            System.out.println(i);
            i++;
        }
    }
}
#+END_SRC

****** 举例
1. 输入五个数字，获取最大值
   #+BEGIN_SRC java
   import java.util.Scanner;
   public class WhileDemo{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int max = sc.nextInt();
           int count = 1;
           while(count < 5){
               int num = s.nextInt();
               if(max < num){
                   max = num;
               }
               count ++;
           }
           System.out.println(max);
       }
   }
   #+END_SRC
2. /输入一个整数n,求1~n中的所有的奇数的和/
   #+BEGIN_SRC java
   import java.util.Scanner;
   class LooTest{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 1;
           int sum = 0;
           while(count <= n){
               sum += count;
               count += 2;
           }
           System.out.println(sum);
       }
   }
   #+END_SRC
3. 输入一个整数n，打印1~n中所有能被3整除而不被5整除的数字
   #+BEGIN_SRC java
   import java.util.Scanner;
   class WhileDemo3{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 3;
           while(count <= n){
               if(count % 5 != 0){
                   System.out.println(count);
               }
               count += 3;
           }
       }
   }
   #+END_SRC
4. 输入一个整数n，输出这个n是一个几位数
   #+BEGIN_SRC java
   import java.util.Scanner;
   class SwitchDemo4{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           //定义一个变量来记录位数
           int count = 0;
           while(n != 0){
               count ++;
               //减少一位
               n /= 10;
           }
           System.out.println(count);
       }
   }
   #+END_SRC
5. 输入一个整数n，打印这个整数n的所有的因数
   （这个数能够整除n，这个数就是n的因数）
   思路：
       先获取1~n中的所有的数
       再判断这个是数能否整除n
   #+BEGIN_SRC java
   import java.util.Scanner;
   class WhileDemo4{
       public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int count = 1;
           while(n >= count){
               if(n % count == 0){
                   System.out.println(n);
               }
               count ++;
           }
       }
   }
   #+END_SRC
***** do...while循环
- 格式：
      do{循环体;}while(判断条件);
- 一般格式：
      初始值;
      do{循环体;控制条件;}while(判断条件);

  1.先计算初始值
  2.直接执行循环体以及控制条件
  3.执行完控制条件后的值和判断条件进行判断，
    true的话重复操作2、3，知道false就结束循环
#+BEGIN_SRC java
public class DoWhileDemo{
    public static void main(String[] args){
        int i = 1;
        do{
            System.out.println(i);
            i++;
        }while(i<=10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    );
    }
}
#+END_SRC
****** 举例
实现一个猜数字的小游戏
#+BEGIN_SRC java
/*
  实现猜数字的小游戏
  随机数一个数字，让用户猜
  结果三种情况：
  中了，大了，小了
  随机数：Random
  键盘输入：Scanner
  猜的数字，和随机数进行比较：if判断
  直到猜中为止，反复去猜，循环while
,*/
import java.util.Random;
import java.util.Scanner;
public class GuestNum{
    public static void main(String[] args){
        System.out.println("游戏开始");
        System.out.println("输入1~100的数字");
        Random ran = new Random();
        int ranNum = ran.nextInt(100)+1;

        Scanner sc = new Scanner(System.in);

        while(true){
            int num = sc.nextInt();
            if(num > ranNum){
                System.out.println("猜大了");
            }else if(num<ranNum){
                System.out.println("猜小了");
            }else
                System.out.println("中了");
                break;
            }
        }
    }
#+END_SRC

**** 嵌套循环
#+BEGIN_SRC java
/*
  循环的嵌套：循环里面还有循环，for形式多
  for(){
      for(){
      }
  }
  总的循环次数 = 内循环次数 * 外循环的次数
  内循环，是外循环的循环体

  外循环，控制的是行数
  内循环，控制的是没行的个数
,*/
public class ForForDemo{
    public static void main(String[] args){
        for(int i = 0;i<9;i++){
            for(int j = 0;j<i+1;j++){
                System.out.print("*");
            }
        }
        System.out.println();
    }
}
#+END_SRC
***** 举例
要求:计算出水仙花数
     三位数 100~999 个位数的立方 + 十位数的立方 + 百位数的立方 = 自己本身
     153 = 1*1*1 + 5*5*5 + 3*3*3
     已知三位数  123 获取出每个数位 利用除法，取模运算
实现步骤：
       1.定义变量，存储三个数位上的整数
       2.利用循环，循环中的变量，从100变化到999
       3.循环中得到三位数，利用算术，拆解陈三个单独数位
       4.将三个数位立方的求和计算，计算后的求和和他自己进行比较判断
         若相同位水仙花
#+BEGIN_SRC java
public class LoopTest_1{
    public static void main(String[] args){
        //定义三个变量
        int bai = 0;
        int shi = 0;
        int ge = 0;

        for(int i = 100;i<=999;i++){
            bai = i/100;
            shi = i/10%10;
            ge = i%10;

            if(bai*bai*bai+shi*shi*shi+ge*ge*ge == i){
                System.out.println(i+"为水仙花");
            }
        }
    }
}
#+END_SRC
**** 三种循环的区别于联系
- 联系：
      1.三种循环可以等效转换
      2.优先选择for循环，其次是while最后才是do...while
      3.都会出现死循环
- 区别：
      1.do...while最少会执行一次
      2.for循环的初始值循环结束之后拿不到这个值
*** 嵌套循环(嵌套循环/双层循环)
外层循环控制行数
内层循环控制的是列数
**** 举例
1. 打印星星
   #+BEGIN_SRC java
   class  Java1{
       public static void main(String[] args){
           for(int i=1;i<=5;i++){
               for(int j=0;i<=5;j++){
                   System.out.print("*");
               }
               System.out.println();
           }
       }
   }
   #+END_SRC
2. 打印99乘法表
   #+BEGIN_SRC
   1*1=1
   1*2=2 2*2=4
   1*3=3 2*3=6 3*3=9

   1
   11
   111
   1111
   11111
   #+END_SRC
   #+BEGIN_SRC java
       class Java2{
           public static void main(String[] args){
               for(int i=1;i<=9;i++){
                   for(int j=0;j<9;j++){
                       System.out.print("1");
                   }
                   System.out.println();
               }
           }
       }
   #+END_SRC
   #+BEGIN_SRC java
   class Java3{
       public static void main(String[] args){
           for(int i=1;i<=9;i++){
               for(int j=1;j<=i;j++){
                   // int m=i*j;
                   // System.out.print(j+"*"+i+"="+m);
                   System.out.print(j+"*"+i+"="+(i*j)+'\t');
               }
               System.out.println();
           }
       }
   }
   #+END_SRC
*** 跳转语句break、continue
**** break
1. 用于switch语句
2. 用在循环中，结束当前循环
   #+BEGIN_SRC java
   class BreakDemo{
       public static void main(String[] args){
           int i=i;
           while(true){
               if(i == 3){
                   break;
               }else{
                   System.out.println(i);
               }
           }
       }
   }
   #+END_SRC
3. break tag
   在多层循环时，通过break tag方式，指定在break时要跳出的是哪一层循环
   #+BEGIN_SRC java
   class BreakDemo_1{
       public static void main(String[] args){
           a:for(int i = 0;i<2;i++){
               for(int j = 0;j<5;j++){
                   System.out.println("j="+j);
                   break a;
               }
                   System.out.println("i="+i);
               }
           }
       }
   #+END_SRC
**** continue
跳过本次循环
#+BEGIN_SRC java
class ContinueDemo{
    public static void main(String[] args){
        for(int i=0;i<10;i++){
            if(i%2==0){
                continue;
            }
            System.out.println(i);
        }
    }
}
#+END_SRC

*** 练习
1. 对于下列代码输出的结果是什么——hehe
   当if语句省略大括号的时候，语句体只有一句
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i=3;
           if(i<3)
               System.out.println("haha");
               System.out.println("hehe");
       }
   }
   #+END_SRC
2. 对于下列代码输出的结果是什么——死循环，没有输出
   while(判断条件);{循环体；控制条件；}
   当while()后面出现分号表示执行完判断条件后直接结束，不仅如此{}执行循环体和控制条件
   所以i一直等于0---死循环
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i=0;
           while(i<10);
           {
               System.out.println(i);
               i++;
           }
       }
   }
   #+END_SRC
3. 对于下列代码输出的结果是什么——编译时报错
   要保证每块区域的变量事先都有定义
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           int i= 5;
           switch(i){
               default:
               int y=5;
               case 4:
                   y+=4;
               case 3:
                   y+=3;
                   break;
               case 2:
                   y+=2;
               case 1:
                   y+=1;
           }
           System.out.println(y);
       }
   }
   #+END_SRC
4. 对于下列代码输出的结果是什么——1,1 2,1
   #+BEGIN_SRC java
   public class Test{
       public static void main(String[] args){
           Outer:for(int i=1;i<3;i++){
               Inner:for(int j=1;j<3;j++){
                   if(j==2)
                       continue Outer;
                   System.out.println(i+","+j);
               }
           }
       }
   }
   #+END_SRC
5. 百钱买百鸡是我国古代的著名数学题。题目这样描述：3文钱可以买1只公鸡，2文钱可以买1只母鸡，1文钱可以买3只小鸡，用100文钱可以买100只鸡，那么公鸡、母鸡、小鸡各多少只？
   #+BEGIN_SRC java
   //公鸡
   int x=0;
   //母鸡
   int y=0;
   //小鸡
   int z=0;
   //把每组的排列组合都列出来
   //公鸡范围
   for(x=0;x<=33;x++){
       //母鸡的范围
       for(y=0;y<=50;y++){
           //小鸡的范围
           z=100-x-y;
           //小鸡也是整数
           if(z%3==0){
               //判断条件
               if(3*x+2*y+(z/3)==100){
                   System.out.println(x+" "+y+" "+z);
               }
           }
       }
   }
   #+END_SRC
6. 读入一个整数n,输出如下图形：
   当输入n=3时，输出：
         *              空格 2     1   n=3      星星1      1   2*行-1
        *****                  1     2               3      2
       *******                 0     3               5      3
   当输入n=4时，输出：
         *
        *****
       *******
      *********
   #+BEGIN_SRC java
   int n=5;
   for(int x=1;x<=n,i++){
       //空格
       for(int y=0;y<n-x;y++){
           System.out.print(" ");
       }
       //星星
       for(int z=1;z<=2*x-1;z++){
           System.out.print("*");
       }
       System.out.println();
   }
   #+END_SRC
** Java的内存存储
java将占用的内存分为了5块：栈内存、堆内存、方法区(面向对象讲)、本地方法栈、PC计数器（计数器）
*** 栈内存：存储的变量(目前阶段)。
#+BEGIN_SRC
变量在声明的时候存储到栈内存中，不会自动给值，除非在程序中手动给值。
变量在栈内存中使用完成之后要立即释放。
int[] arr=new int[2];
arr通过堆内存中对象的地址找到值
#+END_SRC
*** 堆内存：存储的是对象。
#+BEGIN_SRC
对象在存储到堆内存中之后，会被堆内存赋予一个默认值；
byte/short/int - 0
long - 0L
float - 0.0f
double - 0.0
char - \u0000
boolean - false
引用数据类型 - null
对象使用完成不一定会从堆内存中立即移出，而是在不确定的某个时刻被回收
#+END_SRC
int[] arr=new int[2];  new就是在堆内存中开辟一个新空间
*** int[] arr1=new int[]{2,3,5};
系统默认初始值优先于程序初始值
** 数组
存储多个相同数据类型元素的容器
*** 数组格式：
- 第一种
  #+BEGIN_SRC
  数据类型[] 数组名 = new 数据类型[元素的个数或者数组的长度];
  int[]  arr = new int[3];
  表示整型数组arr的元素个数为3个
  支持声明和赋值两个过程
  #+END_SRC
  #+BEGIN_SRC java
  int[] arr=new int[2];
  int[] arr1;
  arr1=new int[3];
  #+END_SRC
- 第二种
  #+BEGIN_SRC
  数组类型[] 数组名 = new 数据类型[]{元素值1,元素值2,元素值3,...,元素值n};
  int[]  arr  = new int[]{1,2,3,4,3};
  具体的值确定了，长度也就确定了
  支持声明和赋值两个过程
  #+END_SRC
  #+BEGIN_SRC java
  int[] arr=new int[]{1,2,1,3};
  int[] arr1;
  arr1 = new int[]{1,2,1,3};
  #+END_SRC
- 第三种
  #+BEGIN_SRC
  数据类型[] 数组名 = {元素值1,元素值2,元素值3,...,元素值n};
  int[]  arr  ={1,2,3};
  给定具体的值，长度就确定了
  #+END_SRC
  #+BEGIN_SRC java
  int arr1;
  arr1={1,2,3};//错误的写法
  #+END_SRC
  new:创建对象，开辟新的内存空间;没有开辟空间就无法存储数据
*** 数组的内存地址
#+BEGIN_SRC java
int[] arr=new int[2];
int[] arr1;
arr1=new int[3];
System.out.println(arr);//[I@7852e922
#+END_SRC
#+BEGIN_SRC
[I@7852e922:数组的内存地址
            [ 表示这块区域的对象类型为数组类型
            I 表示这块区域的对象元素的数据类型为整型
            @ 代表后面的是内存的地址值
            7842e922 表示对象的哈希吗值的十六进制的表现形式
#+END_SRC
*** 数组常用操作
**** 获取数组中的元素
#+BEGIN_SRC
数组名[数组的索引];
arr[2];
数组的索引(下标)就是元素在数组中的位置，索引由0开始，最大的索引是"数组的长度-1"
#+END_SRC
#+BEGIN_SRC java
int[] nums={1,3,4,1,5};
System.out.println(nums[0]);
System.out.println(nums[1]);
System.out.println(nums[2]);
#+END_SRC
**** 数组的元素赋值
#+BEGIN_SRC java
int[] arr = new int[5];
arr[1]=3;
#+END_SRC
***** 数组越界异常
ArrayIndexOutOfBoundsException
**** 修改数组中的元素
#+BEGIN_SRC java
int[] arr={1,2,3,4};
arr[2] =100;
#+END_SRC
**** 获取数组长度
#+BEGIN_SRC java
int[] arr = {2,8,9,12};
int len = arr.length;
#+END_SRC
**** 数组的遍历
一次输出数组元素的值
1. 遍历数组下标,先获取下标，然后利用下标获取元素
   #+BEGIN_SRC java
   int[] arr  = {2,1,3,5,7,0,4};
   for(int i = 0;i<arr.length;i++){
       System.out.println(arr[i]);
   }
   #+END_SRC
2. 直接获取数组中的元素(只能遍历数组，不能改变数组中的元素)
   把所有的数组元素拷贝一份拿过来进行输出
   #+BEGIN_SRC java
   int[] arr = {2,2,3,4,5};
   for(int i : arr){
       System.out.println(i);
   }
   #+END_SRC
4. 将数组中的元素转成字符串返回
   #+BEGIN_SRC java
   import java.util.Arrays;
   class ArrayDemo_8{
       public static void main(String[] args){
           int[] arr=new int[]{1,23,4};
           String str = Arrays.toString(arr);
           System.out.println(str);
       }
   }
   #+END_SRC
**** 获取数组中最值（最大值/最小值）
1. 定义一个变量记录最大值
   如果第0位小于第1位，那么将第1位的值赋值给max，以此类推
   #+BEGIN_SRC java
   int[] arr = {2,8,9,2,2,5,6};
   int max = arr[0];
   for(int i = 1; i<arr.length;i++){
       if(max <arr[i])
           max = arr[i];
   }
   System.out.println(max);
   #+END_SRC
2. 定义一个变量记录最大值的下标
   #+BEGIN_SRC java
   int[] arr = {2,3,6,5,3,2,,7};
   int max = 0;
   for(int i = 1;i<arr.length;i++){
       if(arr[max] <arr[i])
           max = i;
   }
   System.out.println(arr[max]);
   #+END_SRC
**** 数组逆序
1. 创建新数组，从原数组正着拿，往新数组倒着放，在将新数组的地址给arr
   [1,2,3] [3,2,1]
   i=0   arr.length-1-0
   i=1   arr.length-1-1
   i=2   arr.length-1-2
   #+BEGIN_SRC java
   import java.util.Arrays;
   class ArrayReserver{
       public static void main(String[] args){
           int[] arr={1,2,7,4,5};
           int[] arr1=new int[arr.length];
           for(int i=0;i<arr.length;i++){
               arr1[arr.length-1-i]=arr[i];
           }
           arr=arr1;
           System.out.println(Arrays.toString(arr));
       }
   }
   #+END_SRC
2. 数值的位置变换
   #+BEGIN_SRC
   [1,2,5,7,8]
   0 arr.length-1
   1 arr.length-1-1
   2 arr.length-1-2
   变换次数：arr.length/2
   #+END_SRC
   #+BEGIN_SRC java
   import java.util.Arrays;
   public class ArraysApplicationDemo1{
       public static void main(String[] args){
           int[] arr = {2,6,1,8,4,3,0};
           for(int i=0;i<arr.length/2;i++){
               int temp = arr[i];
               arr[i]=arr[arr.length-i-1];
               arr[arr.length-i-1]=temp;
           }
           System.out.println(Arrays.toString(arr));
       }
   }
   #+END_SRC
**** 数组的查找
根据查找数，返回这个查找数在数组出现的下标
***** 查找元素出现的位置(无序数组)
#+BEGIN_SRC java
int[] arr={1,2,5,8,3};
int find=3;
for(int i=0;i<arr.length;i++){
    if(find == arr[i]){
        System.out.println(i);
    }
}
#+END_SRC
#+BEGIN_SRC java
int[] arr={1,5,2,8,3,4};
int num=8;
int count=0;
for(int i:arr){
    if(i==num){
        System.out.println(count);
        break;
    }
    count++;
}
#+END_SRC
#+BEGIN_SRC java
int[] arr = {2,3,4,8,5};
int num = 9;
for(int i = 0;i<arr.length;i++){
    if(arr[i] == num){
        System.out.println(i);
        break;
    }
}
#+END_SRC
***** 查找元素出现的位置(有序数组)(折半查找/二分查找)
#+BEGIN_SRC java
int[] arr={1,2,3,5,6,8,9};
int num=8;
int min=0;
int max=arr.length-1;
int mid=(min+max)/2;
//标志位
boolean flag=true;
//操作循环拿中间下标对应的元素值和查找数进行比较
while(arr[mid]!=num){
    //中间下标对应的数组元素值小于查找数
    if(arr[mid]<num){
        min=mid+1;
    }
    //中间下标对应的数组元素值大于查找数
    if(arr[mid]>num){
        max=mid-1;
    }
    //判断不在范围内的数
    if(min>max){
        System.out.println("没有这个数");
        flag=false;
        break;
    }
    //新的中间下标值
    mid=(min+max)/2;
}
if(flag){
    System.out.println(mid);
}
#+END_SRC
**** 数组排序
排列数组元素顺序
***** 冒泡排序
相邻两个元素进行两两比较，然后交换位置

[[./Img/31.png]]
#+BEGIN_SRC java
int[] arr={2,1,3,6,5};
//嵌套循环
//控制轮数
for(int i=1;i<arr.length;i++){
    //控制参与操作元素的个数
    for(int j=1;j<=arr.length-i;j++){
        //两两比较
        if(arr[j-1]>arr[j]){
            int temp=arr[j-1];
            arr[j-1]=arr[j];
            arr[j]=temp;
        }
    }
}
System.out.println(Arrays.toString(arr));
#+END_SRC
***** 选择排序
选定一位然后依次和其他位进行比较
[[./Img/32.png]]
#+BEGIN_SRC java
int[] arr={2,1,3,6,5};
//操作嵌套循环
//控制轮数
for(int i=1;i<arr.length;i++){
    //参与运算元素的范围
    for(int j=i-1;j<arr.length;j++){
        //
        if(arr[i-1]>arr[j]){
            int temp=arr[j];
            arr[j]=arr[i-1];
            arr[i-1]=temp;
        }
    }
}
System.out.println(Arrays.toString(arr));
#+END_SRC
***** 升序排序
#+BEGIN_SRC java
Arrays.sort(arr);
#+END_SRC
**** 数组的扩容
数组定义完成之后长度无法改变,实际上数组的扩容本质上就是数组的复制

System.arraycopy(要复制的数组,要复制的起始下标,要存放的数组,要存放的起始下标,要复制的元素个数);
#+BEGIN_SRC java
int[] arr1 = {2,1,5,6,8,0,9};
int[] arr2 = new int[5];
System.arraycopy(arr1,3,arr2,1,3);
for(int i : arr2){
    System.out.println(i);
}
#+END_SRC
***** Arrays.copyOf(原数组,改变之后的长度);
#+BEGIN_SRC java
import java.util.Arrays;
class ArrayDemo2{
    public static void main(String[] args){
        int[] arr1 = {2,3,5,6,8,3};
        int[] arr2 = new int[5];

        arr1 = Arrays.copyOf(arr1,15);
        System.out.println(Arrays.toString(arr1));
    }
}
#+END_SRC
**** 时间复杂度
#+BEGIN_SRC
核心代码执行的时间
二分查找：n(数组长度)/2^x=1 x=log2n(log以2为底的) O(log2n)
冒泡、选择：n(n-1)--->n^2-n--->O(n^2)
Arrays.sort():O(nlogn)
#+END_SRC
**** 空间复杂度
在代码运行过程中产生的要占用的内存
二分查找、冒泡、选择：O(1)
** 二维数组
数组元素是一维数组的数组
*** 定义格式
**** 数据类型[][] 数组名 = new 数据类型[一维数组的个数][每个一维数组元素的个数];
#+BEGIN_SRC
int[][] arr = new int[3][5];
arr[0]---第一个一维数组
arr[0][0]---第一个一维数组的第一个元素
#+END_SRC
#+BEGIN_SRC java
int[][] arr=new int[2][3];
//[[I@7852e922---二维数组地址值
System.out.println(arr);
//[I@4e25154f
System.out.println(arr[0]);
//0
System.out.println(arr[0][1]);
#+END_SRC
**** 数据类型[][] 数组名 = new 数据类型[一维数组个数][];
#+BEGIN_SRC
int[][] arr = new int[5][];
表示定义了能存储5个元素类型为int的一维数组
#+END_SRC
#+BEGIN_SRC java
//声明两个一维数组
int[][] arr=new int[5][];
arr[0] = new int[5];
arr[1] = new int[2];
arr[2] = new int[4];
arr[0] = new int[]{1,2,3};
arr[0] = {1,4,5};//不可以
#+END_SRC
***** NullPointerException---空指针异常
#+BEGIN_SRC java
int[][] arr=new int[5][];
//null
System.out.println(arr[0]);
//NullPointerException
System.out.println(arr[0][0]);
#+END_SRC
**** 数据类型[][] 数组名 = new 数据类型[][]{{数组1},{数组2}};
**** 数据类型[][] 数组名 = {数组1，数组2，数组3，...};
#+BEGIN_SRC
int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
既定义包含的一维数组的个数，也定义了每一个一维数组中的元素
#+END_SRC
#+BEGIN_SRC java
int[][] arr={{2,6},{2,5,7,7},{5},{2,76,5}};
#+END_SRC
*** 注意：
#+BEGIN_SRC
int[] x;int x[];//等效
如果[]在数据类型的后面，就会随着数据类型修饰的内容一起去修饰，
如果[]在变量的后面，那么这个[]只修饰变量

对int[] x,y[]进行了初始化，下列正确的是？BD
A.x[0][0]=y[0];
B.x[0]=y[0][0];
C.x=y;
D.x=y[0];
E.x[0]=y;
#+END_SRC
*** 二维数组内存图
[[./Img/33.png]]
*** 二维数组的遍历
**** 普通遍历
 #+BEGIN_SRC java
 int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
 //控制的是一维数组的个数
 for(int i = 0;i<arr.length;i++){
     //控制的是每个一维数组的元素
     for(int j = 0;j<arr[i].length;j++){
         System.out.print(arr[i][j]+"\t");
     }
     System.out.println();
 }
 #+END_SRC
**** 增强for循环
#+BEGIN_SRC java
class ArrayDemo5{
    public static void main(String[] args){
        int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
        //定义一个一维数组依次表示二维数组中的每一个元素
        for(int[] as : arr){
            for(int i = 0;i<as.length;i++){
                System.out.println(as[i]);
            }
        }
    }
}
#+END_SRC
#+BEGIN_SRC java
class ArrayDemo6{
    public static void main(String[] args){
        int[][] arr = {{2,6},{2,5,6,7,8},{5},{2,6,3}};
        for(int[] as : arr){
            for(int i : as){
                System.out.println(i);
            }
        }
    }
}
#+END_SRC

*** 数组的常见的异常
#+BEGIN_SRC java
/*
  数组操作中，常见的两个异常
  - 数组的索引越界异常
    + 负数索引（人为的）
    + 超出范围
  - 空指针异常
,*/
public class ArrayDemo_4{
    public static void main(String[] args){
        //数组的索引越界异常
        int[] arr = {5,2,1};
        //数组中3个元素，索引0，1，2
        System.out.println(arr[3]);

        //空指针异常
        int[] arr2 = {1,5,8};
        //执行正常
        System.out.println(arr2[2]);

        //arr2不在保存数组的地址了
        arr2 = null;
        //不能正常执行
        System.out.println(arr2[2]);
    }
}
#+END_SRC
*** 数组获取最值得原理思想
#+BEGIN_SRC java
/*
  计算数组中的最大值
  数组 {4,1,7,5}; 作比较
,*/
public class ArrayDemo_5{
    //定义数组，int类型
    int[] arr ={5,1,2,4,6,8,0,3};
    //定义变量，记录数组中0索引上的元素
    int max = arr[0];

    //遍历数组，获取所有的元素，和变量max比较
    for(int i = 1;i<arr.length-1;i++){
        //变量max，和数组中的每个元素进行比较
        //如果max，小于了数组中的一个元素
        if(max <arr[i]){
            //较大的数组的元素，赋值给max
            max = arr[i];
        }
        //遍历完成，变量max，就是数组最大值
        System.out.println(max);
    }
}
#+END_SRC
*** 二维数组的定义和访问
#+BEGIN_SRC java
/*
  二维数组
  数组中的数组，数组里面存储的还是数组
  定义方式和一维数组很相似
  int[][] arr = new int[3][4];
  [3] --->表示：二维数组中，有三个一维数组
  [4] --->表示：三个一维数组中，每个数组的长度是4
,*/
public class ArrayArrayDemo{
    public static void main(String[] args){
        int[][] arr = new int[3][4];
        System.out.println(arr);

        System.out.println(arr[1]);
        System.out.println(arr[2][3]);
    }
}
#+END_SRC
#+BEGIN_SRC java
/*
  int[][] arr = new int[3][];
  二维数组中定义三个一维数组，每个一维数组长度没有指定
  arr[0]
  arr[1]
  arr[2]
  必须要new
  arr[0] = new int[5];
  arr[1] = new int[4];

  最简单的二维数组定义方式
  int[][] arr = {{1,4},{3,4,5},{0,9,4}};
,*/
public class ArrayArrayDemo_1{
    public static void main(String[] args){
        int[][] arr = {{1,2,3},{4,5},{5,6,7},{0}};

        //问题：打印7，是数组中的元素
        System.out.println(arr[2][1]);

        //问题：输出结果
        System.out.println(arr[3][0]);
    }
}
#+END_SRC
*** 二维数组的遍历
#+BEGIN_SRC java
/*
  二维数组的遍历
  二维数组中，存储4个一维数组，每个一维数组的长度不同

  遍历：for循环，遍历二维数组
  遍历过程中，for遍历一维数组

,*/
public class ArrayArrayDemo_2{
    public static void main(String[] args){
        int[][] arr = {{1,2,3},{4,5},{6,5,2},{0}};

        //外循环，遍历二维数组
        for(int i= 0;i<arr.length;i++){
            //内循环，遍历每个一位数组 arr[0] arr[1] arr[i]
            for(int j=0;j<arr[i].length;i++){
                System.out.println(arr[i][j]);
            }
            System.out.println();
        }
    }
}
#+END_SRC
*** 二维数组的求和练习
#+BEGIN_SRC java
/*
  二维数组的遍历求和
  第一小组销售额为{11,12}万元
  第二小组销售额为{21,22,23}万元
  第三小组销售额为{31,32,33,34}万元
  每个小组就是一个数组，三个数组存储到一个数组中，形成二维数组
  求和：
      每个小组求和
      所有元素求和
,*/
public class ArrayArraydDemo_3{
    public static void main(String[] args){
        //定义变量，保存2个求和的值
        //所有元素的求和
        int sum = 0;
        //每个一维数组的求和
        int groupSum = 0;

        for(int i= 0;i<arr.length;i++){
            for(int j=0;j<arr[i].length;j++){
                //将一维数组的元素求和
                groupSum + = arr[i][j];
            }
            System.out.println("每个小组总金额"+groupSun);
            //将每个一维数组的综合在相加
            sun+=groupSum;
            //每个一维数组求和，清空
            groupSum = 0;
        }
        System.out.println("本公司总金额"+sum);
    }
}
#+END_SRC
*** 随机点名案例
#+BEGIN_SRC java
/*
  存储全班人的姓名
  1. 存储姓名
  2. 预览所有人的姓名
  3. 随机出一个人的姓名
,*/
import java.util.Random;
public class CallName{
    public static void main(String[] args){
        //存储姓名，姓名存储到数组中
        //数组存储姓名，姓名的数据类型，String
        String[] names = {"张三","李四","王五","李蕾","韩梅梅","小明","小花"};

        //预览：遍历数组，打印所有姓名
        for(int i = 0;i<names.length;i++){
            System.out.println(names[i]);
        }
        System.out.println("---------------------------");

        //随机出一个人的名
        //利用随机数，生成一个整数，作为索引，到数组中找到对象的元素
        Random ran = new Random();
        //随机数，范围必须是0 ~ 数组的最大索引
        int index = ran.nextInt(names.length);//index 就是随机数，作为索引
        System.out.println(names[index]);
    }
}
#+END_SRC

** eclipse
source ---src 域名 www.baidu.com
com.baidu.部门.组号...
** 方法
一段具有特殊功能的代码块，需要时可以通过方法名重复的调用，减少冗余代码
*** 书写格式
修饰符 返回值类型 方法的名字（参数列表...）{
    方法体
    return ;
}

    修饰符：固定写法public static
    返回值类型：返回什么样的数据就用对应的数据类型来接
    没有返回值：void
    方法名：标识符
    参数列表：数据类型和参数的个数
    方法体：执行核心代码
    return：方法的返回，将计算的结果返回;结束方法（用于结束方法以及返回方法指定类型的值）
*** 方法的调用
1. 单独调用
2. 输出调用
3. 赋值调用
**** 方法的注意事项
1. 方法被调用才执行
2. 两个明确：返回值的数据类型，参数列表
3. 没有返回值的方法，不能使用输出调用和赋值调用（不能输出，不能调用）
4. return可以出现在没有返回值的方法里，用于结束方法

   作用：
      a.把返回值进行返回
      b.结束方法
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo3{
       public static void main(String[] args){
           printXing(3,6);
       }
       public static void printXing(int x,int y){
           for(int i=1;i<=x;i++){
               for(int j=1;j<=y;j++){
                   if(j==2)
                       //结束方法
                       return;
                       System.out.println("*");
                   }
               System.out.println();
           }
           //如果输出1就是结束方法，不是结束循环
           System.out.println(1);
       }
   }
   #+END_SRC
   [[./MethodDemo3.java]]
5. 要处理所有的数据，保证每一类数据都有返回
6. 抽取成方法是不定的，根据个人经验
**** 单独调用
方法名(参数值)
#+BEGIN_SRC java
package cn.commandoptionesc.method;
    public class MethodDemo{
        public static void main(String[] args){
            //调用方法
            //单独调用
            printXing(3,6);
        }
        //效果不需要进行返回---返回值类型---void
        //参数列表---int x,int y
        public static void printXing(int x,int y){
            for(int i=1;i<=x;i++){
                for(int j=1;j<=y;j++){
                    System.out.print("*");
                }
            System.out.println();
        }
    }
}
#+END_SRC
[[./MethodDemo.java]]
**** 输出调用
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo1{
    public static void main(String() args){
        //sum(2,4);
        //输出调用
        System.out.println(sum(2,4));
    }
    public static int sum(int m,int n){
        /* int sum=m+n;
           return sum;
        */
        return m+n;
    }
}
#+END_SRC
[[./MethodDemo1.java]]
**** 赋值调用
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo2{
    public static void main(String[] args){
        int result=sum(2,5);
        System.out.println(result);
    }
    public static int sum(int m,int n){
        int sum = m+n;
        return sum;
    }
}
#+END_SRC
[[./MethodDemo2.java]]
*** 方法练习
1. 判断一个整数是否是奇数
   #+BEGIN_SRC java
   //两个明确：返回值类型boolean 参数列表 int m
   package cn.commandoptionesc.method;
   public class MethodDemo4{
       public static void main(String[] args){
           boolean boo= isOdd(8);
           System.out.println(boo);
       }
       public static boolean isOdd(int m){
           //把不正常的范围进行优化
           if(m<0){
               System.out.println("rewrite");
               return false;
           }
           //正常的范围
           if(m%2!=0){
               return true;
           }
           //正常范围，但为偶数
           return false;
       }
   }
   #+END_SRC
   [[./MethodDemo4.java]]
2. 判断一个整数是否是质数
   #+BEGIN_SRC java
   //两个明确：返回值类型booblean 参数列表int m
   package cn.commandoptionesc.method;
   public class MethodDemo5{
       public static void main(String[] args){

       }
       public static boolean isPrime(int m){
           //不正常范围
           if(m<2){
               return false;
           }
           //正常范围下的依次判断
           for(int i=2;i<=m/2;i++){
               //判断是否能被整除
               if(m%i==0){
                   return false;
               }
           }
           return true;
       }
   }
   #+END_SRC
   [[./MethodDemo5.java]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo6{
       public static void main(String[] args){
           isPrime(9);
       }
       public static boolean isPrime(int m){
           if(m<2){
               System.out.println("N");
               return;
           }
           for(int i=2;i<=m/2;i++){
               if(m%i==0){
                   System.out.println("N");
                   return;
               }
           }
           System.out.println("Y");
       }
   }
   #+END_SRC
   [[./MethodDemo6.java]]

*** 方法的重载(overload)
在一个类中，出现了方法名相同的方法
1. 如果有最精确的方法就会进行精确的匹配
2. 如果没有精确匹配就会进行相对精确匹配
3. 如果出现了多个相对精确的匹配就会报错
    #+BEGIN_SRC java
        package cn.commandoptionesc.method;
        public class MethodDemo7{
            public static void main(String[] args){
                //方法名和参数列表共同作为方法签名
                //通过方法签名进行区分调用
                //如果有最精确的方法就会进行精确的匹配
                //如果没有精确匹配就会进行相对精确匹配
                //入股出现了多个相对精确的匹配就会报错
                System.out.println(sum(2,3));
            }
            //求和
            //sum(int,int)
            public static int sum(int i,int j){
                System.out.println("int,int");
                return i+j;
            }
            //sum(int,double)
            public static double sum1(int m,double n){
                System.out.println("int,double");
                return m+n;
            }
            //sum(double,double)
            public static double sum2(double d1,double d2){
                System.out.println("double,double");
                return d1+d2;
            }
        }

    #+END_SRC
*** 方法的传值
1. 基本数据类型
   值的拷贝
2. 引用数据类型
   地址值的拷贝，如果这个拷贝的地址找到了堆内存并进行了改动，原值就会改动，如果没有找到堆内存，原值就不会影响
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo8{
       //所有的方法的执行都是在栈中
       public static void main(String[] args){
           int i=2;
           //实参---实际参数
           //如果传入的是基本类型，就是值的拷贝
           m(i);
           //2
           System.out.println(i);
       }
       //形参---接受值
       public static void m(int i){
           i++;
       }
   }
   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo9{
       public static void main(String[] args){
           int i=2;
           int[] arr={1,2,3};
           m(arr[0]);
           //1
           System.out.println(arr[0]);
       }
       public static void m(int i){
           i++;
       }
   }
   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo10{
       public static void main(String[] args){
           int[] arr={1,2,3};
           //如果传入的是引用数据类型，实质是地址值的拷贝
           n(arr);

           //10
           System.out.println(arr[0]);
       }
       public static void n(int[] arr){
           arr[0]=10;
       }
   }
   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.method;
   public class MethodDemo11{
       public static void main(String[] args){
           int[] arr={1,2,3};
           mn(arr);
           //1
           System.out.println(arr[0]);
       }
       public static void mn(int[] arr){
           //拷贝之后的地址值被新的地址值覆盖
           arr=new int[]{2,3,4};
       }
   }
   #+END_SRC
   #+BEGIN_SRC java
   public class Ex{
       public static void main(String[] args){
           int[] a={1,2,3,4,5};
           expand(a);
           System.out.println(a);

           changeArray(a);
           System.out.println(a[0]);

           pringArray(a);
       }
       public static void expand(int[] a){
           int[] newArray=new int[a.length*2];
           System.out.println(a,0,newArray,0,a.length);
           a=newArray;
           for(int i=0;i<a.length;i++){
               System.out.print(a[i]+"\t");
           }
           System.out.println();
           System.out.println(a);
       }
       public static void changeArray(int[] a){
           a[0]=10;
           System.out.println(a[0]);
       }
       public static void printArray(int[] a){
           for(int i=0;i<a.length;i++){
               System.out.print(a[i]+"\t");
           }
           System.out.println();
       }
   }
   #+END_SRC
*** 方法的递归
#+BEGIN_SRC
sum(10)=10+9+8+7+6+5+4+3+2+1
       =10+9+8+7+6+5+4+3+2+1
       =10+sum(9)
            9+sum(8)
               8+sum(7)
                  7+sum(6)
                     6+sum(5)
                        5+sum(4)
                           4+sum(3)
                              3+sum(2)
                                 2+sum(1)
#+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.method;
public class MethodDemo12{
    public static void main(String[] args){
        System.out.println(diGui(10));
        System.out.println(diGui(5));
    }
    //递归方法求和
    public static int diGui(int n){
        //递归结束的条件
        if(n==1){
            return 1;
        }
        //调用方法自己本身
        return n+diGui(n-1);
        //return 10+diGui(9);
        //          9+diGui(8)
        //            8+diGui(7)
        //              7+diGui(6)
        //         ...
        //               2+diGui(1)
    }

    //递归求5的阶乘
    public static int diGui2(int n){
        //结束条件
        if(n==1){
            return 1;
        }
        return n*diGui2(n-1);
    }
}
#+END_SRC
局限性：可能会出现栈溢出错误
** 引用数据类型--类
*** 自定义类
#+BEGIN_SRC java
/*
  定义类
      使用类的形式，对现实中的事物进行描述
  事物：方法，属性
  方法：这个事物具备的功能
  属性：变量

- 格式
            public class 类名{
                属性定义
                    修饰符 数据类型 变量名 = 值
                方法定义
                    修饰符 返回值类型 方法名（参数列表）{
                    }
            }

            要求：使用java中的类，描述生活中的手机这个事物
                手机事物，具备哪些属性，属于他自己的特性
                 颜色，品牌，大小
       ,*/
      public class Phone{
          /*
            定义手机的属性
          ,*/
          String color;
          String brand;
          double size;
      }
    #+END_SRC

    #+BEGIN_SRC java
      /*
        测试，刚定义好的Phone类
        创建引用类型变量的格式

            数据类型 变量名 = new 数据类型();

            实现引用类型的步骤
                1. 导入包
                2. 创建引用类型的变量
                3. 变量.类型中的功能
       ,*/
      public class PhoneTest{
          public static void main(String[] args){
              Phone p = new Phone();
              // System.out.println(p);输出内存的地址

              p.color = "土豪金";
              p.brand = "苹果";
              p.size = 5.0;

              System.out.println(p.color+"..."+p.brand+"..."+p.size);
          }
      }
    #+END_SRC

*** 自定义类练习

    #+BEGIN_SRC java
      /*
        电饭锅，包含属性（品牌、容量大小、颜色等）
        定义类，描述事物，电饭锅
            属性：品牌，大小，颜色

            定义类，类名字，电饭锅
       ,*/
      public class DianFanGuo{
          //定义三个属性
          String brand;
          double size;
          String color;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        定义汽车类，类名Car
            属性：品牌 排气 类型
       ,*/
      public class Car{
          String brand;
          double paiLiang;
          String type;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        学生，包含属性（姓名，年龄，性别等）
        定义类，类型Studeng
            三个属性：姓名，年龄，性别
       ,*/
      public class Student{
          String names;
          int age;
          char sex;
      }
    #+END_SRC
    #+BEGIN_SRC java
      /*
        定义的测试类
            同时测试，电饭锅，汽车，学生

       ,*/
      public class Test{
          public static void main(String[] args){
              //创建电饭锅引用类型
              DianFanGuo dfg = new DianFanGuo();

              dfg.brand = "特斯拉";
              dfg.color = "红色";
              dfg.size = 30;

              System.out.println(dfg.brand +"..."+ dfg.color+"..."+dfg.size);


              Car c = new Car();
              c.brand = "巨力";
              c.type = "拖拉机";
              c.color = "蓝色";
              c.paiLiang = 0.5;

              System.out.println(c.brand+"..."+c.type+"..."+c.color+"..."+c.paiLiang);

              Student stu = new Student();
              stu.name = "张三";
              stu.age = 20;
              stu.sex = '男';

              System.out.println(stu.name+"..."+stu.age+"..."+stu.sex);
          }
      }
    #+END_SRC
** ArrayList集合
*** ArrayList创建变量的步骤
    #+BEGIN_SRC java
      /*
        ArrayList集合的使用
        也是引用数据类型
        步骤：
            1. 导入 java.util包中
            2. 创建引用类型的变量
                数据类型<要存储元素的数据类型>   变量名 = new 数据类型<要存储元素的数据类型>();
                集合存储的数据类型：要将数据类型存储到集合的容器中
                创建集合引用变量的时候，必须要指定好，存储的类型是什么

                ArrayList<String> array = new ArrayList<String>();

            3. 变量名.方法

            注意：集合存储的数据，8个基本类型对应8个引用类型
            存储引用类型，不存储基本类型
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo{
          public static void main(String[] args){
              //创建集合容器，指定存储的数据类型
              //存储字符串
              ArrayList<String> array = new ArrayList<String>();

              //创建集合容器，存储整数
              ArrayList<Integer> array2 = new ArrayList<Integer>();

              //创建集合容器，存储手机类型
              ArrayList<Phone> array3 = new ArrayList<Phone>();
          }
      }
    #+END_SRC
*** ArrayList的常见方法
    #+BEGIN_SRC java
      /*
        ArrayList集合中的方法
        add()  --->  向集合中添加元素，数据存储进去
            方法中的参数类型，与你定义集合对象时候的类型是一致的
            ArrayList<Integer> array = new ArrayList<Integer>();
            array.add(3);

        get(int index)  --->  取出集合中的元素，get方法的参数，写入索引

        size()  --->  返回集合的长度，集合存储元素的个数
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo_1{
          public static void main(String[] args){
              //定义集合，存储字符串元素
              ArrayList<String> array = new ArrayList<String>();
              //调用集合方法add存储元素
              array.add("abc");
              array.add("live");
              //输出集合的长度，调用集合方法size，size方法的返回值类型 int
              int size = array.size();
              System.out.println(size);

              //获取出集合中的一个元素，获取1索引的元素
              //集合的方法get，获取元素后结果数据类型
              String s = array.get(1);
              System.out.println(s);

              System.out.println(array.get(0));
              System.out.println(array.get(1));
          }
      }
    #+END_SRC
*** ArrayList集合的遍历

    #+BEGIN_SRC java
      /*
        集合的遍历
        实现思想也是索引思想
        集合的索引从0开始，到size()-1
        方法get(int index)
       ,*/
      import java.util.ArrayList;
      public class ArrayListDemo_2{
          public static void main(String[] args){
              ArrayList<Integer> array = new ArrayList<Integer>();
              array.add(121);
              array.add(125);
              array.add(123);
              array.add(120);
              array.add(128);

              //对集合进行遍历
              //使用方法size+get组合进行遍历
              for(int i = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }
          }
      }
    #+END_SRC
*** ArrayList集合补充方法

    #+BEGIN_SRC java
      /*
        集合ArrayList方法的补充
        add(int 索引，存储的元素)将元素添加到指定的索引上
        set(int 索引，修改后的元素)将指定索引的元素，进行修改
       ,*/
      public class ArrayListDemo_3{
          public static void main(String[] args){
              ArrayList<Integer> array = new ArrayList<Integer>();
              array.add(1);
              array.add(2);
              array.add(3);
              array.add(4);

              //在索引2上，添加元素7
              array.add(2,7);
              //使用方法size+get组合进行遍历
              for(int i = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }

              //将0索引上的元素，修改为10
              array.set(0,10);
              //使用方法size+get组合进行遍历
              for(int j = 0;i<array.size();i++){
                  System.out.println(array.get(i));
              }

              //将4索引上的元素，删除
              arry.remove(4);

              //清空索引上的元素
              array.clear();
          }
      }
    #+END_SRC

** 随机点名器案例

   #+BEGIN_SRC java
     /*
       随机点名器，集合改进（学生的姓名和年龄）
       现实中有学生这个事物，使用定义类的形式，描述学生事物
       属性：姓名，年龄

       姓名存储了数组，将容器换成是集合
       String[] s = {"" ,""};
       集合中，存储的是学生的姓名吗？应该存储Student类型

       存储学生：
           学生类型，存储到集合中
       总览：遍历集合
       随机：随机数，作为索引，到集合中找到元素
       三个功能，共享的数据，集合容器
      ,*/
     import java.util.ArrayList;
     import java.util.Random;
     public class CallName{
         public static void main(String[] args){
             //定义集合，存储的是StudentName类型变量
             ArrayList<StudentName> array = new ArrayList<StudentName>;
             //调用添加方法
             add(array);
             //调用遍历集合
             printArrayList(array);

             randomStudentName(array);
         }

         /*
           随机数，当做集合的索引，到集合中找到元素
          ,*/
         public static void randomStudentName(ArrayList<StudentName> array){
             Random r = new Random();
             int num = r.nextInt(array.size());
             //随机数，索引，到集合中get
             StudentName s = array.get(num);
             System.out.println(s.name+"..."+s.age);
         }

         /*
           总览学生的信息，遍历集合
         ,*/
         public static void printArrayList(ArrayList<StudentName> array){
             for(int i = 0;i<array.size();i++){
                 //存储集合的时候，集合.add(sn1)  sn1是StudentName类型变量
                 //获取的时候，集合.get()，获取出来的是什么，还是StudentName类型的变量
                 StudentName s = array.get(i);
                 System.out.println(s.name+"..."+s.age);
             }
         }
         /*
           定义方法，实现存储学生的姓名和年龄
           创建StudentName类型变量，存储到集合中
         ,*/
         public static void add(ArrayList<StudentName>array){
             StudentName sn1 = new StudentName();
             StudentName sn2 = new StudentName();
             StudentName sn3 = new StudentName();
             StudentName sn4 = new StudentName();
             StudentName sn5 = new StudentName();

             sn1.name = "张三1";
             sn1.age = 20;
             sn2.name = "张三2";
             sn2.age = 21;
             sn3.name = "张三3";
             sn3.age = 22;
             sn4.name = "张三4";
             sn4.age = 23;
             sn5.name = "张三5";
             sn5.age = 24;

             //将StudentName变量，存储到集合中
             array.add(sn1);
             array.add(sn2);
             array.add(sn3);
             array.add(sn4);
             array.add(sn5);
         }
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       描述学生事物的类
           属性：姓名和年龄
       学生类型的变量,存储到集合中
      ,*/
     public class StudentName{
         String name;
         int age;
     }
   #+END_SRC

** 库存管理案例

   #+BEGIN_SRC java
     /*
       定义，描述商品的类
       商品 4个属性
           商品名字  大小       价格   库存
           String   double   double  int
         定义类，类名Goods
      ,*/
     public class Goods{
         String brand;
         double size;
         double price;
         int count;
     }
   #+END_SRC

   #+BEGIN_SRC java
     /*
       实现库存管理案例：
           1. 存储商品信息
               创建出集合存储商品类型的变量,将商品类型的变量，存储到集合中

           2. 查看库存清单
               将集合进行遍历，获取出集合中存储的Goods类型
               输出每一个Goods类型的属性
               计算求和：总库存、总金额

           3. 修改商品的库存
               集合遍历，获取集合中存储的Goods类型变量
               变量调用Goods类的属性count，值进行修改（键盘输入）

           4.
      ,*/
     import java.util.Scanner;
     import java.util.ArrayList;
     public class Shopping{
         public static void main(String[] args){
             //创建ArrayList集合，存储Goods类型
             ArrayList<Goods> array = new ArrayList<Goods>();
             //调用添加商品信息的方法
             addGoods(array);

             //进入死循环，如果不选择3退出，就一直在运行
             while(true){
                 //调用选择功能的方法，获取到用户输入的功能序号
                 int num = chooseFunction();
                 //对序号判断，如果=1 进入查看库存功能；=2 进入修改库存功能；=3 结束
                 switch(num){
                 case 1:
                     //进入查看库存，调用查看库存的方法，传递存储商品信息的结合
                     printStore(array);
                     break;
                 case 2:
                     //进入修改库存功能，调用修改库存的方法，传递集合
                     update(array);
                     break;
                 case 3:
                     return ;
                 default:
                     System.out.println("无此功能");
                     break;
                 }
             }
         }
         /*
           定义方法，实现选择菜单，用户根据功能选择菜单
          ,*/
         public static int chooseFunction(){
             System.out.println("-------------------库存管理-------------------");
             System.out.println("1.查看库存清单");
             System.out.println("2.修改商品库存数量");
             System.out.println("3.退出");
             System.out.println("请输入要执行的操作序号:");
             Scanner sc = new Scanner(System.in);
             int num = sc.nextInt();
             return num;
         }

         /*
           方法定义，修改库存
           键盘的输入，将Goods中的属性值，修改
          ,*/
         public static void update(ArrayList<Goods> array){
             Scanner sc = new Scanner(System.in);
             for(int i = 0;i<array.size();i++){
                 //集合方法get获取的是集合的元素，元素类型Goods
                 Goods g = array.get(i);
                 System.out.println("请输入"+g.brand+"的库存数");
                 //Goods属性，count进行修改
                 g.count = sc.nextInt();
             }
         }

         /*
           定义方法，查看库存清单，遍历集合
          ,*/
         public static void printStore(ArrayList<Goods> array){
             System.out.println("----------------------------");
             System.out.println("品牌型号    尺寸     价格      库存数");

             //定义变量，保存总库存数，和总金额
             int totalCount = 0;
             double totalMoney = 0;

             for(int i = 0;i<array.size();i++){
                 //get(索引)获取出集合中的元素，存储的是Goods类，获取的也是Goods类型
                 //使用Goods类型变量，接收get方法结果
                 Goods g = array.get(i);
                 System.out.println(g.brand +"..."+g.price+"..."+g.size+"..."+g.count);
                 totalCount = totalCount + g.count;
                 totalMoney = totalMoney + totalCount*g.price;
             }
         }


         /*
           定义一个方法，将商品的信息存储到集合中.
           集合是所有方法的共享数据，参数传递
          ,*/
         public static void addGoods(ArrayList<Goods> array){
             //创建商品类型变量 Goods类型的变量
             Goods g1 = new Goods();
             Goods g2 = new Goods();
             g1.brand = "MacBook";
             g1.size = 13.3;
             g1.price = 9999.99;
             g1.count = 3;

             g2.brand = "Macbook air";
             g2.size = 15.6;
             g2.price = 999999.99;
             g2.count = 1;

             array.add(g1);
             array.add(g2);
         }
     }
   #+END_SRC

** 数组方法练习
*** 实现数组的遍历
定义方法，实现数组的遍历
遍历中，输出结果[11,33,565,66,78,89]
int[] arr ={3,4,45,7};
结果包含字符串,[],
实现步骤：
    1. 定义方法实现数组的遍历
    2. 先打印[ 中括号
    3. 遍历数组
       输出数组的元素和逗号
       判断是否遍历到了数组的最后一个元素，如果是最后一个元素，输出]中括号
#+BEGIN_SRC java
public class ArrayMethidTest{
    public static void main(String[] args){
        int[] arr = {4,6,7,1};
    }
    public static void printArray(int[] arr){
        //输出一半中括号，不要换行打印
        System.out.print("[");
        //数组遍历
        for(int i=0;i<arr.length;i++){
            //判断遍历到的元素，是不是数组的最后一个元素
            //如何判断 循环变量 到达 length-1
            if(i == arr.length-1){
                //输出数组的元素和]
                System.out.print(arr[i]+"]");
            }else{
                //不是数组的最后一个元素，输出数组和逗号
                System.out.print(arr[i]+",");
            }
        }
        System.out.println();
    }
}
#+END_SRC
*** 数组逆原理
数组的逆序
数组中的元素，进行位置上的交换
逆序不等于反向遍历
就是数组中最远的两个索引，进行位置交换，实现数组的逆序
使用的是数组的指针思想，就是变量，思想，可以随时变换索引
反转 reverse

逆序的实现思想，数组最远端位置的交换
数组的指针思想：就是数组的索引(指针是可以随时指向数组的任意一个索引的)
需要两个指针 ---> 一个大指针，一个小指针
大指针 ---> 最大索引
小指针 ---> 0索引
数组换位，借用第三方的变量，临时性存储
#+BEGIN_SRC java
/*

    实现步骤：
        1. 定义方法，实现数组的逆序
        2. 遍历数组实现数组的最远索引换位置
           使用临时的第三方变量

,*/
public class ArrayMethodTest_1{
    public static void main(String[] args){
        int[] arr = {1,2,3,4};
        reverse(arr);
        printArray(arr);
    }

    /*
      定义方法，实现数组的逆序
      返回值：没有返回值
      参数： 数组就是参数
    ,*/
    public static void reverse(int[] arr){
        //利用循环，实现数组遍历，遍历过程中，最远端换位
        //for的第一项，定义两个变量,最后，两个变量++ ，--
        for(int min = 0,max = arr.length-1;min<max;min++,max--){
            //数组中的元素，进行位置交换
            //min索引和max索引的元素
            int temp = arr[min];
            //max索引上的元素，赋值给min索引
            arr[min] = arr[max];
            //临时变量，保存的数据，赋值到max索引上
            arr[max] = temp;
        }
    }
    public static void printArray(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length;i++){
            if(i==arr.length-1){
                System.out.print(arr[i]+"]");
            }else{
                System.out.print(arr[i]+",");
            }
        }
    }
}
#+END_SRC
*** 数组元素排序
规则：比较大小位置交换
**** 选择排序(selectSort)：
数组中的每个元素都进行比较
数组中每个元素和其他元素进行比较换位置
#+BEGIN_SRC java
public class ArrayMethodTest_2{
    public static void main(String[] args){
        int[] arr = {3,1,5,7,9,0,2};
        selectSort(arr);
        printArray(arr);
    }
    /*
      定义方法，实现数组的选择排序
      返回值：没有
      实现步骤：
          1. 嵌套循环实现排序
             外循环，控制的是一共比较了多少次
             内循环，控制的是每次比较了多少个元素
          2. 判断元素的大小值
             小值，存储到小的索引
    ,*/
    public static void selectSort(int[] arr){
        for(int i = 0;i<arr.length-1;i++){
            //内循环，是每次都在减少，修改变量的定义
            for(int j = i+1;j<arr.length;j++){
                if(arr[i]<arr[j]){
                    //数组换位
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
    public static void printArray(int[] arr){
        System.out.print("[");
        for(int i = 0;i<arr.length;i++){
            if(i == arr.length - 1){
                System.out.print(arr[i] + "]");
            }else{
                System.out.print(arr[i]+",");
            }
        }
        System.out.println();
    }
}
#+END_SRC
**** 冒泡排序(bubbleSort)：
1. 数组中相邻元素进行比较
2. 数组的相邻元素换位置
#+BEGIN_SRC java
public class ArrayMethodTest_3{
    public static void main(String[] args){
        bubbleSort(arr);
        printArray(arr);
    }
    /*
      定义方法，实现数组的冒泡排序
      返回值：没有
      参数：数组
    ,*/
    public static void bubbleSort(int[] arr){
        for(int i = 0;i<arr.length-1;i++){
            for(int j = 0;j<arr.length-i-1;j++){
                if(arr[j]>arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }
    public static void printArray(int[] arr){
        System.out.print("[");
        for(int i = 0;i<arr.length;i++){
            if(i == arr.length -1){
                System.out.print(arr[i] + "]");
            }else{
                System.out.print(arr[i] + ",");
            }
        }
        System.out.println();
    }
}
#+END_SRC
**** 折半查找
前提：被查找数组中的元素，必须有序排列
折半后的指针索引和被查找元素比较
元素>中间索引上的元素
  小指针 = 中间索引 + 1
元素<中间索引上的元素
  大指针 = 中间索引 - 1
小指针的索引>大指针索引，结束
没找到的情况下，得到一个-1的索引
元素 == 数组中间索引上的元素，也结束
  结果就是中间索引
#+BEGIN_SRC java
public class ArrayMethodTest_4{
    public static void main(String[] args){
        int[] arr = {1,3,5,7,9,11,15};
        int index = binarySearch(arr,11);
        System.out.println(index);
    }
    /*
      定义方法，实现，折半查找
      返回值：索引
      参数：数组，被找到的元素
      实现步骤：
          1. 需要的变量定义
             三个，三个指针
          2. 进行循环折半
             可以折半的条件 min<=max
          3. 让被找元素，和中间索引元素进行比较
             元素>中间索引    小指针 = 中间+1
             元素<中间索引    大指针 = 中间-1
             元素==中间索引    找到了，结束了，返回中间索引
          4. 循环结束，无法折半
             元素没有找到，返回-1
    ,*/
    public static int binarySearch(int[] arr,int key){
        //定义三个指针变量
        int min = 0;
        int max = arr.length -1;
        int mid = 0;
        //循环折半，条件min<=max
        while(min<=max){
            //公式，计算中间索引
            mid = (min+max)/2;
            //让被找元素，和中间索引元素进行比较
            if(key>arr[mid]){
                min = mid + 1;
            }else if(key<arr[mid]){
                max = mid - 1;
            }else{
                //找到元素，返回元素索引
                return mid;
            }
        }
        return -1;
    }
}
     #+END_SRC
** 超市管理系统
#+BEGIN_SRC java
/*
  自定义类，描述商品信息
  商品属性:
      编号：int
      品名，String
      价格，double
      数量，int
      总价，double
,*/
public class FruitItem{
    int ID;
    String name;
    double price;
    int number;
    double money;
}
#+END_SRC
#+BEGIN_SRC java
/*
  超市管理系统
      实现：
      1. 商品数据的初始化
      2. 用户的菜单选择
      3. 根据选择执行不同的功能
          Creat，添加商品
          Update，修改商品
          Read，查看商品
          Delete，修改商品

          所有功能，必须定义方法实现
          主方法main 调用作用
,*/
public class Shop{
    public static void main(String[] args){
        //创建ArrayList集合，存储商品类型，存储数据类型FruiteItem类型
        ArrayList<FruitItem> array =new ArrayList<FruitItem>();
        init(array);
        while(true){
            //调用菜单方法
            mainMenu();
            //调用用户选择序号方法
            int choose =  chooseFunction();
            switch(choose){
                case 1:
                    //调用1：货物清单
                    showFruitList(array);
                    break;
                case 2:
                    //调用2：添加货物
                    addFruit(array);
                    break;
                case 3:
                    //调用3：删除货物
                    deleteFruit(array);
                    break;
                case 4:
                    //调用4：修改货物
                    updateFruit(array);
                    break;
                case 5:
                    return ;
                    default:
                    System.out.println("输入有误");
                    break;
                }
            }
        }
        /*
          定义方法，实现商品的修改功能
          返回值：无
          参数：集合


          提示用户选择的是修改功能
          提示用户输入需要修改的商品编号
          遍历集合，获取每个FruitItem的变量
          变量调用ID属性，属性和用户输入的编号比较
          如果相同：
              修改调FruitItem中的属性值
              键盘输入
        ,*/
        public static void updateFruit(ArrayList<FruitItem> array){
            System.out.println("选择的是修改功能");
            System.out.println("请输入商品的编号");

            Scanner sc = new Scanner(System.in);
            int ID = sc.nextInt();
            //遍历结合，获取每个FruitItem变量
            for(int i = 0;i<array.size();i++){
                FruitItem item = new FruitItem();
                //获取FruitItem的属性ID，和用户输入的ID比较
                if(item.ID == ID){
                    System.out.println("输入新的商品编号");
                    item.ID = sc.nextInt();

                    System.out.println("输入新的商品名字");
                    item.name = sc.next();

                    System.out.println("输入新的商品价格");
                    item.price = sc.nextDouble();

                    System.out.println("商品修改成功");
                    return ;
                }
            }
            System.out.println("您输入的编号不存在");
        }
        /*
          定义方法，实现商品的删除功能
          返回值：无
          参数：集合

          删除依靠的是商品的编号
          提示用户选择的是删除功能
          键盘输入商品的编号
          遍历结合，获取集合中的每个Fruititem变量
          变量通用属性 ID 和用户的输入编号对比，相同就删除
        ,*/
        public static void deleteFruit(ArrayList<FruitItem> array){
            System.out.println("选择的是删除功能");
            System.out.println("请输入删除的编号");
            Scanner sc = new Scanner(System.in);

            int ID = sc.nextIne();
            //遍历集合
            for(int i = 0;i<array.size();i++){
                //获取到每个FruitItem变量
                FruitItem item = array.get(i);
                //变量，调用属性ID，和用户输入的编号比较
                if(item.ID == ID){
                    //移除集合中的元素
                    //集合的方法remove实现
                    array.remove(i);
                    System.out.println("删除成功");
                    return ;
                }
            }
            System.out.println("您输入的编号不存在");
        }
        /*
          定义方法，实现商品的添加功能
          返回值：无
          参数：集合
          提示用户输入的是添加商品的功能

          提示用户输入的是什么

          创建FruitItem变量，变量调用的属性
          将输入的每个商品属性进行赋值
        ,*/
        public static void addFruit(ArrayList<FruitItem> arrau){
            System.out.println("选择的是添加商品功能");
            //创建Scanner变量
            Scanner sc = new Scanner(System.in);
            System.out.println("请输入商品的编号");
            //输入商品的编号
            int ID = sc.nextInt();
            //输入商品的名字
            System.out.println("请输入商品的名字");
            String name = sc.next();
            //输入商品的单价
            System.out.println("输入商品的单价");
            double price = sc.nextDouble();
            //创建FruitItem变量
            FruitItem item = new FruitItem();
            //item.属性赋值
            item.ID = ID;
            item.name = name;
            item.price = price;
            array.add(item);
        }
        /*
          定义方法，实现显示货物清单功能
          返回值：无
          参数：无
          参数：集合
          遍历集合，获取集合中的每个FruitItem变量，变量，调用属性
        ,*/
        public static void showFruitList(ArrayList<FruitItem> array){
            System.out.println();
            System.out.println("=======================商品库存清单========================");
            System.out.println("商品编号      商品名称     商品单价");
            //遍历集合
            for(int i = 0;i<array.size();i++){
                //集合get方法，获取出每个FruitItem变量，可以使用FruitItem接受get结果
                FruitItem item = array.get(i);
                //变量item调用类中属性
                System.out.println(item.ID+"  "+item.name+"  "+item.price);
            }
        }
        /*
          定义方法，实现接受用户的键盘输入
          返回编号
        ,*/
        public static int chooseFunction(){
            Scanner sc = new Scanner(System.in);
            return sc.nextInt();
        }
        /*
          定义方法，实现主菜单
          提示用户用户有哪些选择
          方法返回值：无
          参数：无
        ,*/
        public static void mainMenu(){
            System.out.println("                            ");
            System.out.println("-----------------欢迎光临----------------");
            System.out.println("1. 货物清单 2. 添加货物 3. 删除货物 4. 修改货物 5. 退出");
            System.out.println("请您输入要操作的功能序号");
        }
        /*
          定义方法，实现商品数据的初始化
          先将一部分数据，存储集合中
          返回值：无
          参数：集合
          方法名：init
        ,*/
        public static void init(ArrayList<FruitItem> array){
            //创建出多个FruitItem类型，并且属性赋值
            FruitItem f1 = new FruitItem();
            f1.ID = 9527;
            f1.name = "少林寺";
            f1.price = 12.7;

            FruitItem f2 = new FruitItem();
            f2.ID = 9522;
            f2.name = "哈密瓜";
            f2.price = 11.2;

            FruitItem f3 = new FruitItem();
            f3.ID = 9231;
            f3.name = "ABC";
            f3.price = 34.3;

            //创建3个FruitItem类型变量，存储到集合中
            array.add(f1);
            array.add(f2);
            array.add(f3);
        }
    }
#+END_SRC
* 面向对象
** 面向对象简介
*** 面向对象与面向过程的比较
*** 类与对象的关系
*** 对象的内存处理
** 基本概念
*** 成员变量和局部变量
成员变量又叫属性

|----------+------------------------------+--------------------------------|
| 区别     | 成员变量                     | 局部变量                       |
| 定义位置 | 定义在类中方法外             | 定义在方法或者语句中           |
| 作用范围 | 整个类中                     | 对应的方法或者语句中           |
| 内存位置 | 存储在堆内存中               | 存储在占内存中                 |
|          | 并且在堆内存中被赋予了默认值 | 而且没有默认值需要手动给定数据 |
| 生命周期 | 在对象创建的时候创建         | 在方法或≈者语句执行的时候创建   |
|          | 在对象被笑会的时候销毁       | 方法或者语句执行完成之后销毁   |
|----------+------------------------------+--------------------------------|

*** 匿名对象
匿名对象就是指没有名字的对象
- 注意事项
  1. 因为匿名对象没有名字，所以只能在创建的时候使用一次
  2. 匿名对象可以作为参数进行传递
  3. 匿名对象如果没有作为参数传递，那么在栈内存中是没有引用的
#+BEGIN_SRC java
package cn.commandoptionesc;

public class StudentDemo{
    public static void main(String[] args){

        //创建乐意个Student对象
        //注意：像这种没有名字的对象称之为匿名对象
        new Student().play();

        //new几次，就会创建几个对象，几个对象的地址是不一样的
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());

        //匿名对象可以作为参数进行传递
        printName(new Student());
    }

    public static void printName(Student s){
        System.out.println(s.name);
    }
}


//定义一个类表示学生
class Student{
    //姓名、年两、性别、班级、学号
    //属性：成员变量
    String name;
    int age;
    byte gender;
    String grade;
    String no;

    //定义方法表示“学习”行为
    //定义在方法中的变量成为局部变量
    public void study(String subject){

        System.out.println(name + "在学习" + subject);
    }

    //定义方法表示"吃"行为
    public void eat(String food){

        System.out.println(name + "再吃" + food);
    }

    //定义方法表示"玩耍"行为
    public void play(){

        System.out.println(name + "在玩耍");
    }
}
#+END_SRC
*** 构造方法
1. 类中存在的方法名与类名一致而没有返回值类型的方法
2. 作用：
   1. 构造方法最主要的作用是用于创建对象
   2. 可以在构造方法中对属性进行初始化，或者执行其他一些初始化的操作
3. 如果在类中没有手动给定狗仔方法，那么在编译的时候会自动添加一个默认的无参构造
4. 如果一个类中手动添加了构造方法，那么在编译的时候就不会再添加无参的构造方法
5. 构造方法虽然没有返回值类型，但是可以有return语句，其作用是避免一些不合常理的数据被赋值给属性
6. 构造方法可以进行重载
   #+BEGIN_SRC java
   public class DriverDemo{
       //创建Driver
       //构造方法、构造函数
       //这个类目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
       Driver d = new Driver("Amy",19.(byte)0);
       //当提供了无参构造，那么意味着可以利用无参构造创建对象
       Driver d2 = new Driver();
   }
   class Driver{
       String name;
       int age;
       byte gender;
       //驾照号
       String no;

       //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
       //与类同名，但是没有返回值类型
       //利用new关键字来调用构造方法，利用构造方法来创建对象
       public Driver(){
       }

       //定义一个含参构造
       //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
       public Driver(String n,int a,byte g){
           name = n;
           age = a;
           gender = g;
       }
   }
   #+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc;

public class DriverDemo{
    public static void main(String[] args){
    //创建Driver
    //构造方法、构造函数
    //这个类目目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
    Driver d = new Driver("Amy",15,(byte)0);
    //当提供了无参构造，那么意味着可以利用无参构造创建对象
    Driver d2 = new Driver();
    }
}

class Driver{
    String name;
    int age;
    //驾照号
    String no;

    //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
    //与类同名，但是没有返回值类型
    //利用new关键字来调用构造方法，利用构造方法来创建对象
    public Driver(){
    }

    //定义一个含参构造
    //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
    public (Driver(String n,int a,byte g)){
        if(a<18){
            System.out.println("年龄不合法，死机的最小年龄应该是18");
            //可以利用利用return来规避不合理的值，结构构造方法
            return;
        }
        name = n;
        age = a;
        gender = g;
    }
}
#+END_SRC
*** this关键字
1. 因为在java中所有的非静态的方法和属性都是通过对象来调用的，而在本类中如果想调用本类中的方法和属性，并没有本类的对象，所以要用到this来代表当前类的对象，来调用属性和方法
2. this代表本类在活动的对象的引用，可以认为是一个虚拟对象，用于在类内调用本类中的非静态方法和被静态属性
3. this()语句表示在本类的构造方法中调用本类其他形式的构造方法。需要注意的是，this语句必须放在构造方法的第一行
#+BEGIN_SRC java
package cn.commandoptionesc.thisx;

public class ThisDemo{

    //static修饰的属性或者方法就是静态的
    public static void main(Stringp[] args){


        //活跃的对象是s1，所以this代表s1
       Student s1 = new Student("Bob");
       System.out.println(s1.name);
       //此时，活跃的对象是s2，所以this代表s2
       Student s2 = new Student("Alex");
       //活跃的对象又变成s1，所以this代表s1
       s1.age = 15;
    }
}
class Student{
    //姓名
    String name;
    //年龄
    ing age;
    //性别
    byte gender;
    //学号
    String no;

    //在Java中，当出现变量名一致的时候，采取就近原则来使用
    //在Java中，所有的非静态属性哈非静态方法都是通过对象来调用的
    //在类中用this代替当前活跃的对象来调用属性或者方法
    public Student(String name){
        this,name = name;
    }
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    public Student(String name,int age,byte gender){
        //this.name = name;
        //this.age = age;
        //表示滴啊用Student(String,int)
        this(name,age);
        this.gender = gender;
    }
    public Student(String name,int age,byte gender,String no){
        //this.name = name;
        //this.age = age;
        //this.gender = gender;

        //this语句
        //会自动调用本类中符合形式的构造方法
        //this(String,int,byte)--自动找--->Student(name,age,byte);
        //this语句必须在构造方法的第一行
        this(name,age,gender);
        this.no = no;
    }
}
#+END_SRC
*** 构造代码块
**** 构造代码块
1. 所谓构造代码块是指定义在类内用{}包起来的代码，也称之为是初始化代码块
2. 无论调用哪个构造方法，构造代码块都会执行
3. 构造代码块是在创建对象的时候先与构造方法执行
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class ConstructorCodedemo{
    public static void main(String[] args){
        new Baby();
        new Baby("helen");
    }
}

//定义一个类表示婴儿
class Baby{
    String name;
    //在类中用{}括起来的代码称之为构造代码快或者叫初始化代码块
    //无论调用哪个构造方法，这个代码块都会执行
    //构造代码块是先于构造方法执行的
    {
        this.cry();
        this.eat();
    }

    public Baby(){
    }

    public Baby(String name){
        System.out.println("~~~~~~~");
        this.name = name;
    }

    public void cry(){
        System.out.println("这个婴儿在哭");
    }

    public void eat(){
        System.out.println("这婴儿再吃");
    }
}
#+END_SRC
**** 局部代码块
1. 所谓局部代码块，是指定义在方法中用{}包起来的代码
2. 作用是限制变量的生命周期从而提高栈内存的利用率
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class LocalCodeDemo{
    public static void main(String[] args){

        //在方法中用{}括起来的代码称之为局部代码块
        {
            //限制了变量的使用范围，缩短了变量的生命周期
            //提高了栈内存的利用率
            int j = 5;
            int i = 7;
            System.out.println(i+j);
        }
        System.out.println("running");
    }
}
#+END_SRC
*** 权限修饰符
1. 使用范围
   |-----------+--------+----------------+----------+----------|
   | 关键字    | 本类中 | 子类中         | 同包类中 | 其他类中 |
   |-----------+--------+----------------+----------+----------|
   | public    | 可以   | 可以           | 可意     | 可以     |
   | protected | 可以   | 可意           | 可以     | 不可以   |
   | 默认      | 可以   | 同包子类中可以 | 可意     | 不可以   |
   | private   | 可以   | 不可以         | 不可以   | 不可以   |
   |-----------+--------+----------------+----------+----------|
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   public class PrivateDemo {
       public static void main(String[] args) {
           Person p = new Person();
           p.setName("amy");
           p.setAge(17);
           System.out.println(p.getAge());
           System.out.println(p.getName());
       }
   }

   //定义一个代表人的类
   class Person{

       private String name;
       //私有
       private int age;

       //提供一个方法，将要赋值的属性作为参数
       public void setAge(int age){
           if(age < 0 || age >= 150)
               return;
           this.age = age;
       }

       public int getAge(){
           return this.age;
       }

       public void setName(String name){
           this.name = name;
       }

       public String getName(){
           return this.name;
       }
   }
   #+END_SRC
2. 注意事项
   - 限制修饰符的范围是public > protected > 默认 > private

   - 需要注意的是，默认的权限修饰符只能在本类中以及同包类中使用，同包子类本质上也是同包类

   - protected在子类中使用指的是在对应的子类中使用，跨子类是不能使用的
** 基本概念2
*** static
1. static本身是一个修饰符，可以修饰变量、方法、内部类、代码块
2. 静态是从类的层面来看的，已经超越了对象
**** 静态变量：
用static修饰变量那么这个变量我们就称之为静态变量，有称之为成员变量或者类变量
1.静态变量随着类的加载而加载到了方法区中的静态区，并且静态区中自动赋予一个默认值。静态变量优先于对象而存在，所以静态变量可以通过类名来调用，也可以通过对象来调用。该类产生的所有的对象实际上存的是该静态变量在静态区中的地址，静态变量是被所有对象所共享的
2. 实际过程中，如果某些特征是所有属性共有的特征，例如一个班级的学生，那么这个时候班级这个属性就是所有学生共有的，那么此时这个属性就可以设置为静态的
3. 静态内存流程
   [[./Img/1.png]]
   [[./Img/10.png]]
#+BEGIN_SRC java
package cn.commandoptionesc.staticx;

public class StaticDemo {
    public static void main(String[] args) {
        Student s1 = new Student();
        s1.name = "Bob";
        s1.age = 15;
        s1.grade = "四年级";

        Student s2 = new Student();
        s2.name = "Alex";
        s2.age = 16;
        s2.grade = "五年级";

        s1.toStr();
        s2.toStr();
    }
}

class Student{
    String name;
    int age;
    static String grade;

    public void toStr(){

        System.out.println(name + "\t" + age + "\t" + grade);
    }
}
#+END_SRC
**** 静态方法：
用static修饰的方法就叫做静态方法，也叫类方法
1. 在类加载的时候加载到了方法区中的静态区，只是存储在静态区，在方法被调用的时候到栈内存中执行。静态区中的元素不归属于某一个对象而是归属于类。静态方法优先于对象而存在的，所以静态方法可以通过类名来调用，也可以通过对象来调用,实际过程中静态方法一般是通过类名来调用。例如：Arrays.sort()，Arrays是一个类，sort是一个方法，通过类名来调用
2. 静态变量不可以定义到静态方法中。静态方法在方法区中只存储不执行，当被调用的时候才在栈中执行。而静态变量是根据类的加载而加载，上来就要进行初始化--- 所有的静态元素都是定义在类中
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo {
       public static void main(String[] args) {

       //静态变量要求在类加载的时候就得初始化，静态方法是在调用的时候才执行初始化
       //Modifier "static" not allowed here
       //static int i = 5;
       }
   }
   #+END_SRC
3. 静态方法中不可以直接调用本类中的非静态方法。在Java中所有非静态方法和非静态属性都是通过对象来调用的，静态方法是优先于对象存在的，也就意味着静态方法执行的时候可以没有对象。也因此在静态方法中不可以使用this和super。super与this都是和对象是想关联的，而静态优先于对象而存在。
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo {
       public static void main(String[] args) {

           Student s1 = new Student();
           s1.name = "Bob";

           //Non-static method 'printName(cn.commandoptionesc.staticx.Student)' cannot be referenced from a static context
           //printName(s1);
           //this.printName(s1);
       }
       public void printName(Student s){
           System.out.println(s.name);
       }
   }

   class Student{
       String name;
   }
   #+END_SRC
4. 静态方法可以重载。重载对修饰符没有要求的，对返回值也没有要求
5. 静态方法不可以重写（方法的覆盖）
   静态方法可以存在方法签名完全一致的静态方法，这不是重写，称之为隐藏。但是也适用于重写的那套规则。
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo2 {
       public static void main(String[] args) {
           /*
           a调用m方法应该打印"B running"
           但打印的是"A runnimg"
           所以不是重写
           StaticMethodA a = new StaticMethodB();
           a.m();
           */
       }
   }

   class StaticMethodA{
       public static void m(){
           System.out.println("A running");
       }
   }

   class StaticMethodB extends StaticMethodA{
       /*
       加上@Override报错：Method does not override method from its superclass
       @Override
       */

       //如果父子类中存在了方法签名完全一致的非静态方法，称之为隐藏(hide)
       //如果父子类中存在了方法签名完全一致的方法，要么都是静态的，要么都是非静态的
       public static void m(){
           System.out.println("B running");
       }
   }
   #+END_SRC
6. 注意：如果父子类中存在方法签名相同的方法要么都是普通的方法，要么都是静态方法
**** 静态代码块
1. 在类中用static修饰用{}括起来的代码块
2. 静态代码块针对的是类，所以也可以叫做类代码块
3. 实际上静态代码块是随着类的加载而加载到方法区，在类创建对象或者执行方法之前执行一次，终其一生只执行一
   #+BEGIN_SRC java
   package cn.commandoptionesc.staticx;

   public class StaticDemo3 {
       public static void main(String[] args) {
           //静态代码块只在类加载的时候执行一次，因为累值加载一次，所以静态代码块也只执行一次
           new A();
           new A();
       }
   }

   class A {

       //静态代码块
       static{
           System.out.println("A");
       }
   }
   #+END_SRC
4. 执行顺序：
   在这个类第一次被真正使用（第一次创建对象/调用方法）的时候执行一次。如果一个类包含多个静态代码块，则按照书写顺序执行。由于类只在第一次使用的时候加载，所以静态代码块也只执行一次。
   #+BEGIN_SRC java
   /*
   A1 A2 A3 A2 A3
   */
   public class ex4{
       public static void main(String[] args){
           new A();
           new A();
       }
   }
   class A{
       //静态代码块
       static{
           System.out.println("A 1");
       }

       {
           System.out.println("A 2");
       }

       public A(){
           System.out.println("A 3");
       }
   }
   #+END_SRC
5. 代码块执行顺序：
   先父类后子类，先静态后动态。（先父子类的静态，后子类的动态）静态优先，父类优先;

   代码是从上到下，从左到右一次编译执行：
   创建子类对象的时候需要先：创建父类对象 ---> 加载父类 ---> 执行父类静态代码块 ---> 执行子静态代码块 ---> 父类构造函数 ---> 子类构造代码块 ---> 子类构造函数
   试图加载B类，但是准备加载B类的时候发现B有父类A，所以先加载A类，执行A中的静态代码块，A类加载完成之后在加载B类，执行B中的静态代码块。试图创建B对象的时候，会先利用super语句创建一个A类对象，然后在创建B类对象
   #+BEGIN_SRC java
   /*
   new B();
   A1 B1 A2 A3 B2 B3

   new B();
   new B();
   A1 B1 A2 A3 B2 B3 A2 A3 B2 B3
   */
   public class ex4{
       public static void main(String[] args){
           new B();
           new B();
       }
   }
   class A{
       //静态代码块
       static{
           System.out.println("A 1");
       }

       {
           System.out.println("A 2");
       }

       public A(){
           System.out.println("A 3");
       }
   }
   class B extends A{
       static{
           System.out.println("B 1");
       }

       {
           System.out.println("B 2");
       }
       public B(){
           System.out.println("B 3");
       }
   }
   #+END_SRC

*** final
1. 常量
   当final修饰数据（基本类型和引用类型）的时候，表示这个变量的值不可变，称之为常量。终其一生只能赋值一次。在Java中所说的常量往往是指静态常量。因为实质上只有静态常量才是独有的一个。
   - 特点：
     + 常量在定义好之后不可改变，final固定的是栈内存中的数值
       #+BEGIN_SRC java
       package cn.commandoptionesc.finalx;

       public class FinalDemo1 {
           public static void main(String[] args) {

               final int i = 4;
               //Cannot assign a value to final variable 'i'
               //i = 5;

               //此时arr在栈内存存储的地址，所以final限制的是arr的地址不能变
               final int[] arr = {3,4,6,8};

               //做地址改变，不可行，报错
               //arr = new int[3];

               //没有改变地址，只是改变了元素值
               arr[0] = 10;
               System.out.println(arr[0]);
           }
       }

       class A {

           //final也可以修饰成员属性，称之为成员常量
           //final int id = 5;

           /*
           final int id;

           {
           id = 5;
           }*/

           /*
           //对于非静态成员常量而言，只需要在构造方法执行完成之前给值即可
           //final常量的值只能给一次
           final int id;
           public A(int id){
           this.id = id;
           }
           */

           //静态常量
           //final static int id = 6;

           final static int id;
           static{
           id = 6;
           }
       }

       #+END_SRC
     + 常量可以作为参数传递，传递之后是否还是一个常量要看接收的方法中是否定义为一个常量
       #+BEGIN_SRC java
       package cn.commandoptionesc.finalx;

       public class FinalDemo2 {
           public static void main(String[] args) {
               final int i = 3;
               m(i);
               System.out.println(i);
           }

           public static void m(int i ){
               i++;
           }
       }

       #+END_SRC
     + 对引用类型而言，final固定的是其在栈中的地址不可变。例如：数组在栈内存中存储的是地址，用final修饰，是不能改变数组的地址，但数组的值可以改变。对于对象而言，对象的引用不能改变，但是应用的属性值是可以进行改变的。
     + 成员常量只要是在对象创建完之前（构造方法/函数执行结束之前）赋初始值即可
     + 静态成员变量（static final）只要在类加载完成之前给值即可，而且只能在静态代码块中赋值
2. 最终方法
   - final修饰方法的时候，这个方法就是最终方法
     #+BEGIN_SRC java
     package cn.commandoptionesc.finalx;

     public class FinalDemo3 {
         public static void main(String[] args) {
             FA a = new FA();
             a.m();
         }
     }

     class FA{

         //final修饰的方法称之为最终方法
         public final void m(){
             System.out.println("m()");
         }
     }
     #+END_SRC
   - 特点：
     + 可以重载
       #+BEGIN_SRC java
       package cn.commandoptionesc.finalx;

       public class FinalDemo3 {
           public static void main(String[] args) {
               FA a = new FA();
               a.m();
               a.m(5);
           }
       }

       class FA{

           //final修饰的方法称之为最终方法
           public final void m(){
               System.out.println("m()");
           }

           public final void m(int i){
               System.out.println("m(int)");
           }
       }
       #+END_SRC
     + 不可以重写,可以继承
       #+BEGIN_SRC java
       package cn.commandoptionesc.finalx;

       public class FinalDemo3 {
           public static void main(String[] args) {
               FA a = new FA();
               a.m();
               a.m(5);

               //最终方法可以继承
               FB b = new FB();
               b.m();
           }
       }

       class FA{

           //final修饰的方法称之为最终方法
           //最终方法不允许被重写
           public final void m(){
               System.out.println("m()");
           }

           public final void m(int i){
               System.out.println("m(int)");
           }
       }

       class FB extends FA{

           //最终方法不允许被重写
           //'m()' cannot override 'm()' in 'cn.commandoptionesc.finalx.FA'; overridden method is final
           /*
           public void m(){

               System.out.println("B m()");
           }
           */
       }
       #+END_SRC
     + 最终方法不可以被重写也不能被隐藏
     + 静态方法可以被final修饰
       #+BEGIN_SRC java
       package cn.commandoptionesc.finalx;

       public class FinalDemo3 {
           public static void main(String[] args) {
               FA a = new FA();
               a.m();
               a.m(5);

           }
       }

       class FA{

           //静态方法可以被final修饰
           public final static void m(){
               System.out.println("m()");
           }

           public final static void m(int i){
               System.out.println("m(int)");
           }
       }
       #+END_SRC
3. 最终类
   - final修饰的类称之为最终类
   - 特点：
     + 最终类不可以被继承，也不能有匿名内部类形式。
     + 由于最终类不能被继承，一次重写也是不可以的。
*** abstract
1. 抽象类
   - 将一些名称一致但是细节不同的行为提取到父类中定义为抽象方法，抽象方法所在的类就是抽象类，用abstract来修饰的类
   - 抽象类中，不一定含有抽象方法，但是抽象方法所在的类一定是抽象类
   - 抽象类不可以在Java中创建/实例化。即使没有抽象方法也无法创建对象，可以创建匿名内部类
   - 抽象类被子类继承之后，必须重写其中的抽象方法，除非子类也是抽象类
   - 抽象类中可以没有抽象方法
   - 抽象类中可以定义一切的属性和方法
   - 抽象类不能用final修饰。最终类不可以是抽象类
     #+BEGIN_SRC java
     package cn.commandoptionesc.abstractx;

     public class AbstractDemo {
         public static void main(String[] args) {

             /*
             //匿名内部类
             Pet p = new Pet() {
                 @Override
                 public void eat() {
                 }
             }
             */

             Cat c = new Cat();

             /*
             //抽象类中可以有构造方法，就算添加上构造方法，也不是一个对象，依然是匿名内部类
             Animal a = new Animal() {
             };
             */
         }
     }

     /*
     //抽象类中可以没有抽象方法
     abstract class Animal{

     }
     */

     //抽象类中可以有构造方法
     abstract class Animal{
         public Animal(){

         }
     }

     /*
     //父类不能用final修饰，因为final修饰的类不能被继承，而抽象类一定要被继承来覆盖抽象方法
     final abstract class Pet{
         public abstract void eat();
         }
     */

     abstract class Pet{
         String name;
         public abstract void eat();

         public void sleep(){
             System.out.println(name + "在睡觉");
         }
     }


     class Cat extends Pet{
         //Class 'Cat' must either be declared abstract or implement abstract method 'eat()' in 'Pet'
         //一个类继承抽象类之后，必须覆盖抽象类中的抽象方法，或者这个子类本身也是抽象类
         @Override
         public void eat() {
             System.out.println("这只猫在吃鱼");
         }
     }

     class Dog extends Pet{
         @Override
         public void eat() {
             System.out.println("这只狗在吃骨头");
         }
     }
     #+END_SRC
2. 抽象方法：
   - 如果所有的子类中存在了一些名称一致而细节不同的方法的时候，这个时候可以在父子类中声明该行为，此时声明行为的时候不需要添加方法体，所以此时该方法就形成了抽象方法，使用abstract修饰
   - 简单来讲：就是在父子类进行继承的时候，子类重写父类的方法但是父类的方法在后续并不打算使用，因此就会将父类的方法的方法体删除声明抽象方法，子类直接重写即可
   - 抽象方法可以和抽象方法重载，也可以和实体方法重载
     #+BEGIN_SRC java
     package cn.commandoptionesc.ex;

     public class AbstractDemo{
         public static void main(String[] args){
             Cat c = new Cat();
             c.eat();
             c.eat(1);
             System.out.println(c.eat("猫粮"));
         }
     }

     abstract class Pet{
         public abstract void eat();
         public abstract String eat(String food);
         public int eat(int num){
             System.out.println("吃了" + num + "斤食物");
             return  num;
         }
     }

     class Cat extends Pet{

         @Override
         public void eat() {
             System.out.println("这只猫在吃鱼");
         }

         @Override
         public String eat(String food) {
             return food;
         }
     }
     #+END_SRC
   - 抽象方法没有方法体
   - 抽象方法不可以被static、final、private修饰，因为final和privat修饰符修饰的方法都不可以被重写；static修饰的方法，优先于对象存在，没有具体对象没有办法加载
   - 抽象方法可以使用默认权限修饰，要求子类必须和父类同包
   - 抽象方法可以被protected权限修饰，要求要么同包要么是子类
#+BEGIN_SRC java
package cn.commandoptionesc.abstractx;

public class AbstractDemo {
    public static void main(String[] args) {

        /*
        //匿名内部类
        Pet p = new Pet() {
            @Override
            public void eat() {

            }
        }
        */

        /*
        //抽象类中可以有构造方法，就算添加上构造方法，也不是一个对象，依然是匿名内部类
        Animal a = new Animal() {
        };
        */

        Cat c = new Cat();
        c.name = "xiaoli";
        c.eat();
        c.eat(1);
        c.sleep();
        System.out.println(c.eat("猫粮"));
    }
}

/*
//抽象类中可以没有抽象方法
abstract class Animal{

}
*/

//抽象类中可以有构造方法
abstract class Animal{
    public Animal(){

    }
}

/*
//父类不能用final修饰，因为final修饰的类不能被继承，而抽象类一定要被继承来覆盖抽象方法
final abstract class Pet{
public abstract void eat();
}
*/

abstract class Pet{
    String name;

    public abstract void eat();
    public abstract String eat(String food);
    public int eat(int num){
        System.out.println("吃了" + num + "斤食物");
        return num;
    }

    public void sleep(){
        System.out.println(name + "在睡觉");
    }
}


class Cat extends Pet{
    //Class 'Cat' must either be declared abstract or implement abstract method 'eat()' in 'Pet'
    //一个类继承抽象类之后，必须覆盖抽象类中的抽象方法，或者这个子类本身也是抽象类
    @Override
    public void eat(){
        System.out.println("这只猫在吃鱼");
    }

    @Override
    public String eat(String food) {
        return food;
    }
}

class Dog extends Pet{
    @Override
    public void eat() {
        System.out.println("这只狗在吃骨头");
    }

    @Override
    public String eat(String food) {
        return food;
    }
}
#+END_SRC
*** 接口interface
1. 接口用interface来声明，其中所有方法都为抽象方法，但是从JDK1.8开始，接口中允许存在实体方法
2. 通过implements关键字让接口和类产生联系，这个过程就叫实现
3. 利用接口的向上造型来创建对象，就是接口的多态
4. 接口中方法的abstract关键字可以忽略
5. 类实现接口的时候必须实现这个接口中的所有的方法
6. 由于接口中都是抽象方法，所以接口不能实例化
7. 可口中没有构造函数
8. 虽然接口在编译完成之后会产生class文件，但是接口不是类
9. 接口中可以定义属性，这个属性默认是一个静态常量即接口中的属性默认是用public static final来修饰
10. 接口中的抽象方法默认用public abstract修饰，而且只能是public修饰的，public可以省略不写。在接口的子类中实现接口的方法记得用public修饰
11. Java中类支持单继承，多实现。一个类只能继承一个类，但是一个类可以实现多个接口。
    #+BEGIN_SRC java
      package cn.commandoptionesc.interfacex;

      public class InterfaceDemo {
          public static void main(String[] args) {
          }
      }

      //定义一个类表示图形Shape
      //用interface定义的是一个接口
      interface Shape{

          double getGirth();
          double getArea();

      }

      interface Girth{
          double getGirth1();
          double getArea1();

      }


      class ExD implements Shape,Girth{

          @Override
          public double getGirth() {
              return 0;
          }

          @Override
          public double getArea() {
              return 0;
          }

          @Override
          public double getGirth1() {
              return 0;
          }

          @Override
          public double getArea1() {
              return 0;
          }
      }
    #+END_SRC
12. 一旦出现了多实现，那就必不可免的会导致方法调用混乱
    #+BEGIN_SRC java
    package cn.commandoptionesc.interfacex;

    public class InterfaceDemo{

    }
    interface A{
        int m();
    }
    interface B{
        boolean m();
    }
    class C implements A,B{
        //一旦出现多实现，就避免不了的会导致方法混乱调用
        //Java中又没有public int/boolean 这种写法
        /*
        public int/boolean m(){
        }
        */
    }
    #+END_SRC
13. 类和类之间是单继承，类和接口之间是多实现，接口和接口之间是多继承
    #+BEGIN_SRC java
    package cn.commandoptionesc.interfacex;
    public class InterfaceDemo{

    }
    interface Shape{
    }
    interface Girth{
    }
    interface Girth1 extends Shape,Cloneable{
    }
    #+END_SRC
14. 注意：Java中接口之间是多继承，并且接口和类之间是多实现的关系，所以就形成了一张继承关系网，由于在网状结构中寻找一个根节点比较困难，为了提高效率，Java在编译的时候放弃检查接口和类之间是否有实现关系。当类进行强势转换的时候，JVM在编译的时候会对两个类进行检查，检查这两个类之间是否有几成关系。如果有几成关系，则编译的时候会通过，但是运行的时候不一定正确，如果没有继承关系，则在编译的时候直接报错。
    #+BEGIN_SRC java
    package cn.commandoptionesc;

    public class InterfaceDemo2 {
        public static void main(String[] args) {

            //在Java中，支持的是类和类之间的单继承，所以可以形成一颗继承结构树
            //在继承结构树中，可以比较容易的确定两个类之间是否有继承关系
            //因此在编译的时候会检查声明类和实现类（强转的类型）之间是否有继承关系
            /*
            A a = new B1();
            //a的声明类型是A，要转化的类是B1，B1继承了A类，所以A和B1之间有继承关系
            //因为有继承关系，所以在编译期间允许转换，在编译期间仅仅是检查是否有继承关系
            //而不去检查到底是要转化为哪一个子类
            //到了运行的时候，才会去检查这个对象到底能不能转换
            //到了运行的时候，a的实际类型是B1，要强转的类型也是B1，可以转换
            //编译可以，运行也可以
            B1 b1 = (B1)a;
            */

            /*
            //ClassCastException - 类型转换异常
            A a = new B1();
            //a的声明类型是A，要转化的类型是B2，A和B2之间有继承关系，所以编译通过
            //但是到了实际运行的时候，a的实际类型是B1，要强转的类型是B2，类型不一致，所以运行失败
            //编译可以，运行失败
            B2 b2 = (B2)a;
            */

            /*
            A a = new B1();
            //a的声明类型是A，要转化的类型是C，A和C之间没有继承关系，所以编译失败
            C c = (C)a;
            */

            //ClassCastException - 类型转换异常
            //在Java中，类和接口之间是多实现，接口和接口之间是多继承的
            //在一个网状结构中，想要确定连个结点之间是否有联系是一件比较麻烦的操作
            //所以Java为了减少编译花费的时间，那么在编译阶段放弃检查
            //也就意味着用接口声明对象的时候不检查结构关系，所以用任何一个接口都可以进行强转
            //但是到了运行的时候回检查是否有关系
            //到了运行的时候，要转化的类型是D，实际类型是B1，B1和D之间没有关系，所以运行失败
            A a = new B1();
            D d = (D)a;

        }
    }

    class A{

    }

    class B1 extends A{}
    class B2 extends A{}
    class C{

    }

    interface D{

    }
    #+END_SRC
15. 作用：统一结构。接口可以作为模板，配合多态实现解耦
*** 内部类
1. 定义类或者接口中的类就称之为内部类。内部类是封装的第三种形式
2. 内部类根据使用的位置和修饰符不同分为：方法内部类、成员内部类、静态内部类和匿名内部类
3. 特点：
   - 除了静态内部类，其余的内部类中都不允许定义静态属性和静态方法，但是可以定义静态变量
   - 除了静态内部类，其余的内部类都可以使用安全外部类的属性和方法，但是静态内部类只能使用外部类的静态成员
4. 方法内部类
   - 定义在方法里的类叫做方法内部类，也叫局部内部类
   #+BEGIN_SRC java
   package cn.commandoptionesc.innerclass;

   public class InnerClassDemo1 {
       public static void main(String[] args) {

       }
   }

   class Outer1{
       public void m(){
           System.out.println("m running");

           //在方法中定义的类，称之为方法内部类/局部内部类
           class Inner1{
               public void m(){
                   System.out.println("inner m running");
               }
           }
       }
   }
   #+END_SRC
   - 特点：
     + 可以定义成员属性和成员方法
     + 不可以定义静态属性和静态的方法，但是可以定义静态常量
     + 可以继承其他类和实现接口。注意：在这个继承和实现知识只能继承和实现外部类的接口和类，内部类和内部接口是不能被继承和实现的。
     + 可以使用外部类的属性和方法
     + 不可以使用当前方法里的局部变量，但是可以使用当前方法中的局部常量
   - 作用：方法内部类是为了私有本类方法中的参数
   #+BEGIN_SRC java
   package cn.commandoptionesc.innerclass;

   public class InnerClassDemo1 {
       public static void main(String[] args) {

       }
   }

   class Outer1{

       int x = 4;
       static int y = 5;
       public void m(){
           int i = 3;
           System.out.println("m running");

           //在方法中定义的类，称之为方法内部类/局部内部类
           //可以使用外部类的成员属性和方法
           //方法内部类可以继承类，也可以实现接口
           //方法内部类可以使用final或者是abstract修饰
           class Inner1 {

               int a = 3;

               /*
               //方法内部类中可以声明非静态属性和方法，可以声明静态常量，但是不能声明静态变量和静态方法
               //static int b = 4;
               static final int b = 5;
               */

               public void m(){
                   x = 5;

                   /*
                   //方法内部类使用当前方法中的数据的时候，要求这个数据要是一个常量
                   //Variable 'i' is accessed from within inner class, needs to be final or effectively final
                   i = 6;
                   */

                   System.out.println(x);
                   System.out.println(y);
                   System.out.println(i);
                   System.out.println("inner m running");
               }
           }

           Inner1 i1 = new Inner1();
           i1.m();

       }
   }
   #+END_SRC
5. 成员内部类
   - 定义在类内方法外的类叫做成员内部类，也就是成员变量的位置，利用外部类对象来创建成员内部类对象
   - 特点
     + 成员内部类可以定义非静态变量和非静态方法
     + 不可以定义静态变量和静态方法
     + 可以定义静态常量
     + 可以使用外部类中的一切属性和一切方法
     + 内部类的权限可以定义为私有的
     + 可以继承类或者实现接口
   #+BEGIN_SRC java
   package cn.commandoptionesc.innerclass;

   public class InnerClassDemo2 {
       public static void main(String[] args) {

           /*
           //创建外部类对象
           Outer2 o2 = new Outer2();
           */

           //表示创建了一个内部类对象
           Outer2.Inner2 oi2 = new Outer2().new Inner2();
           oi2.m();
       }
   }

   class Outer2{

       int i = 3;
       //在类中定义了一个内部类，这个内部类称之为成员内部类
       //成员内部类可以继承别的类或者实现接口
       //成员内部类可以使用权限修饰符final/abstract修饰
       class Inner2{

           int j = 3;

           int i = 7;

           /*
           //成员内部类中可以定义非静态属性和非静态方法，但是不能定义静态变量和静态方法
           static int m = 8;
           */

           //成员内部类可以定义静态常量
           static final int n = 8;


           public void m(){

               //当内部类和外部类存在同名属性的时候,通过外部类.this.属性来调用
               System.out.println(Outer2.this.i);

               //成员内部类使用外部类中的一切属性和方法
               System.out.println(i);
           }
       }
   }
   #+END_SRC
6. 静态内部类
   - 用static修饰的成员内部类叫做静态内部类。可以直接利用外部类来创建静态内部类的对象
   - 特点
     + 可以定义成员属性成员方法
     + 可以定义静态属性和静态方法
     + 不允许使用外部类里面的非静态属性和静态方法
   #+BEGIN_SRC java
   package cn.commandoptionesc.innerclass;

   public class InnerClassDemo3 {
       public static void main(String[] args) {

           Outer3.Inner3 oi3 = new Outer3.Inner3();
           oi3.m();
       }
   }

   class Outer3{

       int i = 5;
       static int j = 8;

       //静态内部类可以使用权限修饰符final/abstract修饰
       static final class Inner9{}
       static public class Inner8{}
       static abstract class Inner7{}

       //静态内部类可以继承别的类，也可以实现接口
       static class Inner6 extends Exception{}
       static class Inner5 implements Cloneable{}

       //用static修饰的内部类称之为静态内部类
       static class Inner3{


           //静态内部类中可以定义非静态方法和非静态属性，也可以静态方法和静态属性
           int x = 4;
           static int y = 6;

           public void m(){

               /*
               //静态内部类不能使用外部类中的非静态属性和非静态方法
               System.out.println(i);
               */

               //静态内部类中可以使用外部类中的静态属性和静态方法
               System.out.println(j);
           }
       }
   }
   #+END_src
7. 匿名内部类
   - 没有名字的内部类叫做匿名内部类。包含成员匿名内部类，方法匿名内部类
   - 注意：
     抽象类可以创建匿名内部类，实体类只要不是最终类就可以创建匿名内部类。当利用接口创建匿名内部类的时候，实际上是实现了对应的接口。
   - 如果匿名内部类定义在了方法或者语句内的时候，使用规则和方法是一致的。当定义在类内时，使用方法和成员内部类相同。本质上是继承了对应的类或者实现了对应的接口
   - 可以使用匿名内部类的方式创建对象
   - 特点：
     + 匿名内部类本质上是集成了对应的类或者实现对应的接口
     + 只要一个类可以被继承，那么这个类就可以出现匿名内部类的形式，当利用一个类来创建一个匿名内部类的时候，实际上这个匿名内部类是继承了这个类
     + 匿名内部类有构造函数。但是不能进行手动的添加
     + 当利用匿名内部类定义到了方法中，此时匿名内部类的使用规则和方法内部类一致
     + 如果匿名内部类定义到了类中，此时匿名内部类的使用规则和成员内部类一致
   #+BEGIN_SRC java
   package cn.commandoptionesc.innerclass;

   public class InnerClassDemo4 {

       //当匿名内部类定义在类中，使用规则和成员内部类一致
       Pet p = new Pet(){

       };
       public static void main(String[] args) {

           //匿名内部类
           //匿名内部类本质上是继承了new的类
           //当匿名内部类定义在方法中的时候，使用规则就喝方法内部类一致
           Animal a = new Animal() {
               @Override
               public void eat() {

               }
           };

           //匿名内部类本质上是实现了这个接口
           Pet p = new Pet() {
           };

           //只要一个类可以被继承，那么这个类就可以存在匿名内部类形式
           Cat c = new Cat(){

           };

           /*
           //最终类不能产生匿名内部类
           //Cannot inherit from final 'cn.commandoptionesc.innerclass.Dog'
           Dog d = new Dog(){
           };
           */

       }
   }

   abstract class Animal{
       public abstract void eat();
   }

   interface Pet{}

   class Cat{}

   final class Dog{}
   #+END_SRC
*** 包
1. 声明包用的package，包的产生是为了解决同名文件的问题
2. 注意：
   一个Java文件中只允许存在一个package语句，而且这个package语句必须方法整个Java文件的首行
3. 导入包用的是import。在导包的时候，*表示通配符，用于导入指定包下的所有的类而不包括子包下的类。例如import java.util.*。表示导入util包下的所有的类而不包括util子包下的类
4. java.lang包下的类在程序运行的时候会自动导入，所以java.lang包下的类在使用的时候不需要写导包语句
5. 同一个包下的类在使用的时候也不需要导包
6. 注意：
   包名在命名的时候尽量不以java,javax等开头
#+BEGIN_SRC java
//定义包的语句必须放在整个Java的第一行
package cn.commandoptionesc.packagex;

//如果需要使用不同包的类，需要用import来导包
//可以使用*导入指定包下的所有的类
//表示导入java.util包下的所有的类但是不包括util子包的类
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
//import java.util.Arrays;
//import java.util.Scanner;


public class PackageDemo {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        System.out.println(Arrays.toString(new int[]{2,4,5,6}));
        //ConcurrentHashMap
    }
}
#+END_SRC
*** 垃圾分代回收机制
1. 垃圾回收针对的是堆内存
2. 对象在堆内存中存储，对象在使用完成之后会在不定的某个时刻被垃圾回收期(GC - Garbage Collector)解析掉。现阶段回收过程无法手动控制。当调用构造方法的时候，创建好一个对象，因为java中对每种数据类型都明确给定了大小，在创建对象的时候，会自动计算大小分配内存，所以在内存的回收和释放的时候也是由Java自己管理
3. 堆内存分为了新生代（年轻代）和老生代。新生代划分为伊甸园区和幸存区。一个对象新创建是放到了伊甸园区，如果这个对象在栈内存中没有引用，那么会在扫描的时候被解析，释放内存；在伊甸园区经过了一次扫描如果依然存活则标记到幸存区。幸存区的扫描频率要略低于伊甸园区。如果在幸存区中经过了多次扫描这个对象依然没有被解析则标记到老生代。如果老生代的对象发生了回收，导致程序的卡顿甚至崩溃
4. 发生在新生代的回收称之为minor gc，即初生代回收；发生在老生代的回收称之为full gc，即完全回收
* 面向对象的特征
** 封装
1. 封装是面向对象方法的重要原则，就是把对象的属性和方法（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。封装是一种信息隐藏技术。
2. 形式
   a. 方法，其实是封装的一种常见的形式，通过将某段常用的逻辑进行提取从而形成一种新的形式。
   b. 属性的私有化，在类中定义了属性之后，如果允许在类外直接操作属性会导致用户直接给属性赋予一些不合常理的数据。将属性私有化，将属性用private修饰，然后提供对外的访问（getXXX）和设置（setXXX）的方法，在方法中进行限定，使属性值更加符合的场景要求。
   c. 内部类，内部类作为封装的一种形式，是为了让代码的结构更加的紧凑
3. 作用
   a. 提高了复用性（降低了代码的冗余度）、安全性、使代码结构更加紧密
   b. 使属性私有化 - 隐藏信息，实现细节
   c. 使属性值更符合要求 - 可以对成员进行更精准的控制
   d. 提高了代码的安全性 - 类内部的结构可以自由修改
   e. 良好的封装能够减少耦合
#+BEGIN_SRC java
package cn.commandoptionesc.object;

public class PrivateDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("amy");
        p.setAge(17);
        System.out.println(p.getAge());
        System.out.println(p.getName());
    }
}

//定义一个代表人的类
class Person{

    private String name;
    //私有
    private int age;

    //提供一个方法，将要赋值的属性作为参数
    public void setAge(int age){
        if(age < 0 || age >= 150)
            return;
        this.age = age;
    }

    public int getAge(){
        return this.age;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }
}
#+END_SRC
** 继承
*** 1. 介绍
   如果一些类中的属性和方法是相同的，那么可以把这些类中相同的属性和方法提取到一个新的类中，然后利用extends关键字让原来的类和行的类产生练习，这种练习称之为继承。而这个时候原来的类称之为是子类，新的类称之为父类
*** 2. 注意事项
   - Java中支持的是类和类之间的'单继承'，即一个子类只能有一个父类，但是一个父类可以有多个子类。
   - 通过继承，子类可以继承父类全部的数据域，但是只有一部分数据域对子类可见，所以子类也只能使用这一部分可见的数据域
*** 3. 单继承与多继承的比较
   - 多继承在代码的复用性上要优于单继承，但是存在方法调用的混乱
     #+BEGIN_SRC java
     public class ex3{
         public static void main(String[] args){
         }
     }
     class A{
         public void m(){
             System.out.println("A");
         }
     }
     class B{
         public void m(){
             System.out.println("B");
         }
     }
     class C extends A,B{

     }
     C c = new C();
     c.m();
     #+END_SRC
   - 单继承也可以提高代码的复用性，可以避免方法调用的混乱，提高了方法调用的安全性
*** 4. 特征
   - 继承关系是传递的
   - 继承简化了人们对事物的认识和描述，能清晰的体现相关类间的层次结构关系
   - 继承提高了代码的复用性
   - 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性
*** 5. 优点
   - 提高复用性
   - 提高安全性，避免方法调用产生混乱
   - 统一结构
*** 6. 方法的重写
   - 子类里存在了方法签名（方法名+参数列表）完全一致的非静态方法，就构成了方法的重写（覆盖）
   - 子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要曹勇方法的重写，方法重写又称方法覆盖
   - 遵循原则：方法的重写需要遵循“两等两小一大”的原则：方法签名、返回值类型、权限修饰符
     + 方法签名要求完全一致
     + 如果父类里的返回值是基本数据类型/void/最终类，那么子类里重写的返回值类型必须一致（如果父类的方法是private的话，子类是无法被继承的，即使子类重新定义这个方法，也不算重写）
       #+BEGIN_SRC java
       public class ex5{
           public static void main(String[] args){
           }
       }
       class A{
           public void m(){
           }
       }
       class B extends A{
           public void m(){
           }
       }
       #+END_SRC
     + 如果父类方法的返回值类型是一个引用类型，子类方法的返回值类型是父类方法的返回值类型的子类
       #+BEGIN_SRC java
       public class ex{
           public static void main(String[] args){
           }
       }
       class Pet{}
       class Dog extends Pet{}

       class A{
           public Pet m(){}
       }
       class B extends A{
           //public Pet m(){}
           public Dog m(){}
       }
       #+END_SRC
     + 子类方法的权限修饰符的范围要大于等于父类方法权限修饰符的范围，需要注意的是，对于8种基本数据类型之间没有继承关系的，它们是同级关系
        #+BEGIN_SRC java
        public ex2{
            public static void main(String[] args){}
        }
        class A{
            protected void m(){}
        }
        class B extends A{
            //父类用的protected，子类要么用相同的protected要么用比父类大的public
            //protected void m(){}
            public void m(){}
        }
        #+END_SRC
*** 7. super关键字
   - super表示在子类中对父类对象的引用，可以看做是一个虚拟对象
   - 在子类中可以通过super调用父类中的非讲台方法或者非静态属性
   - 在子类的构造方法中看，可以通过super关键字调用父类中的对应形式的构造方法，如果不指定，默认调用父类的无参构造
   - 如果父类中值提供了含参的构造方法，那么子类的构造方法中必须手动定义super语句来调用父类中的含参构造
   - super语句必须放在狗仔方法的第一行，所以super语句不能同时出现
   #+BEGIN_SRC java
   package cn.commandoptionesc.extendsx;

   public class ExtendsDemo4 {
       public static void main(String[] args) {
           B b = new B();
           b.m();
       }
   }

   //
   class A {
       public A(int i){

       }
       public void m(){
           System.out.println("A ");
       }
   }

   //
   class B extends A{
       //如果在子类中没有手动指定，那么在子类的构造方法中
       //默认添加一个无参super()调用父类中对应形式的构造方法
       public B(){
           super(5);
       }

       public B(int i){
           //先创建一个父类对象，然后才能在子类中调用父类对象中的属性或者方法
           super(i);
           System.out.println(i);
       }

       @Override
       public void m() {
           super.m();
           System.out.println("B");
       }
   }

   #+END_SRC
** 多态
1. 多态是指允许不同类的对象对同一消息做出相应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态主要针对对象的行为及方法，而不是对象的属性。
2. 体现形式：
   - 编译时多态
     在编译时期就要进行动态绑定的行为，主要体现为方法的重载
   - 运行时多态
     + 在运行时期才能确定绑定的运行过程，主要体现形式是向上造型、方法的重写
     + 需要注意的是运行时多态的前提需要产生了继承关系或者实现关系
3. 向上造型
   指的是用父类声明对象而用子类创建对象的行为方式，利用向上造型创建的对象所能使用的属性或者方法需要看的是声明类，而具体怎么执行所调用的方法看的是实现类
4. 作用：统一结构，实现解耦
#+BEGIN_SRC java
package cn.commandoptionesc.method;

public class ObjectDemo {
    public static void main(String[] args) {

        //用父类Pet生命对象，用子类创建对象 ---> 向上造型
        //向上造型创建对象，在编译的时候，并不会去检查具体子类
        //在编译的时候，首先发现Pet p所以确定这个对象是一个Pet对象
        //继续往后编译会检查后边要使用的类和前面生命的类是否有继承关系
        //Cat和Pet有继承关系，那么久编译通过，而此时并没有去检查具体是哪一个子类
        //编译的时候没有确定子类，也就不知道子类中具体有哪些方法
        //所以在使用的时候，就不允许调用子类中独有的方法
        //此时只允许调用父类中声明的方法
        Pet p = new Cat();
        //向上造型创建的喜爱那个在调用方法的时候调用的是子类中的方法
        p.eat();

        //向上造型创建的对象不能调用子类中独有的的方法
        //p.catchMouse();
    }
}

//定义一个类表示宠物
class Pet{
    public void eat(){
        System.out.println("在吃东西");
    }

}

//定义一个类表示猫
class Cat extends Pet{
    @Override
    public void eat() {
        System.out.println("这只猫在吃鱼");
    }

    public void catchMouse(){
        System.out.println("这只猫抓到了一直老鼠");
    }
}

//定义一个类表示狗
class Dog extends Pet{
    @Override
    public void eat() {
        System.out.println("这只狗再吃骨头");
    }

    public void bark(){
        System.out.println("这是狗在汪汪叫");
    }
}

#+END_SRC
* API(一)
** Object
1. Object是Java中任何一个类都默认继承了Object
2. 在Java中任何一个类都是Object的子类
3. 重要方法
   |----------+-------------------------------------------------------------------------------------------------------------------------------|
   | 方法     | 解释                                                                                                                          |
   | clone    | 1. 表示创建一个和当前对象属性值一样的对象                                                                                     |
   |          | 2.这个方法在使用的时候，要求对象对应的类必须实现接口Cloneable。这个接口中没有任何的方法和属性，仅仅标记这个类的对象可以被克隆 |
   | finalize | 通知GC进行垃圾回收。仅仅是起通知作用，而GC不一定启动                                                                          |
   | getClass | 获取对象的实际类型                                                                                                            |
   | hashCode | 1. 获取对象的哈希码。根据哈希散列算法产生对象的哈希码                                                                         |
   |          | 2. 同一个对象的哈希码是一样的，不同的对象的哈希码是不同的                                                                     |
   | toString | 当直接打印一个对象的时候，底层实际上在调用这个对象的toString方法                                                              |
   | equals   | 1. 判断两个对象是否是同一个对象                                                                                               |
   |          | 2. equals默认是比较两个对象的地址是否一致。实际过程中往往需要重写equals方法                                                   |
   |          | 3. 重写equals要拆分成4步：                                                                                                    |
   |          | a. 比较地址是否一致                                                                                                           |
   |          | b. 判断参数是否为空                                                                                                           |
   |          | c. 比较类型是否一致                                                                                                           |
   |          | d. 判断属性值是否一样                                                                                                         |
   |----------+-------------------------------------------------------------------------------------------------------------------------------|
4. clone/hashcode
   #+BEGIN_SRC java

   package cn.commandoptionesc.object;

   public class ObjectDemo1 {
       private int i;
       public static void main(String[] args) throws Exception{

           ObjectDemo1 o1 = new ObjectDemo1();
           o1.i = 5;

           //表示的是克隆，创建一个和o1属性值一样的对象
           ObjectDemo1 o2 = (ObjectDemo1) o1.clone();
           System.out.println(o2.i);
           System.out.println(o1);
           System.out.println(o2);

           //用向上造型创建o对象
           //o对象的声明类型是Object，实际类型是String
           Object o = "abc";
           //获取对象的实际类型
           System.out.println(o.getClass());

           //同一个对象的哈希码是一样的，不同的对象的哈希码是不同的
           System.out.println(o.hashCode());
           System.out.println(o.hashCode());
           System.out.println(o.hashCode());
           System.out.println(new Object().hashCode());
           System.out.println(new Object().hashCode());
           System.out.println(new Object().hashCode());
       }
   }
   #+END_SRC
5. toString
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   public class ObjectDemo2 {
       public static void main(String[] args) {
           Person p = new Person();
           p.setName("Sam");
           p.setAge(15);

           //当直接打印一个对象的时候，实际上底层会调用这个对象的toString方法
           System.out.println(p);
           System.out.println(p.toString());
       }
   }

   class Person{
       private  String name;
       private int age;

       public String getName() {
           return name;
       }

       public void setName(String name) {
           this.name = name;
       }

       public int getAge() {
           return age;
       }

       public void setAge(int age) {
           this.age = age;
       }

       @Override
       public String toString() {
           return name + "\t" + age;
       }
   }
   #+END_SRC
6. equals
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   import java.util.Objects;

   public class ObjectDemo3 {
       public static void main(String[] args) {
           Student s1 = new Student();
           s1.setName(new String("Sam"));
           s1.setAge(15);
           s1.setNo("gwer1234");

           Student s2 = new Student();
           s2.setName(new String("Sam"));
           s2.setAge(15);
           s2.setNo("gwer1234");

           //比较的是地址是否一样
           System.out.println(s1.equals(s2));
       }
   }

   class Student{
       private String name;
       private int age;
       private String no;

       public String getName() {
           return name;
       }

       public void setName(String name) {
           this.name = name;
       }

       public int getAge() {
           return age;
       }

       public void setAge(int age) {
           this.age = age;
       }

       public String getNo() {
           return no;
       }

       public void setNo(String no) {
           this.no = no;
       }

       @Override
       public boolean equals(Object o) {
           //判断两个对象的地址是否一样
           if(this == o)
               return true;

           //判断参数是否为null
           if(o == null)
               return false;

           //判断类型是否一致
           if(this.getClass() != o.getClass())
               return false;

           //比较属性
           Student s  = (Student) o;

           //比较年龄是否一致
           if(this.age != s.age)
               return false;

           //比较姓名
           if(this.name == null){
               if(s.name != null)
                   return false;
           }else if(!this.name.equals( s.name))
                return false;

           //比较学号
           if(this.no == null){
               if(s.no != null)
                   return false;
           }else if(!this.name.equals(s.name))
               return false;
           return true;
       }
   }
   #+END_SRC
#+BEGIN_SRC java

package cn.commandoptionesc.object;

import java.util.Objects;

public class ObjectDemo4 {
    public static void main(String[] args) {
        Student1 s1 = new Student1();
        s1.setName(new String("Sam"));
        s1.setAge(15);
        s1.setNo("gwer1234");

        Student s2 = new Student();
        s2.setName(new String("Sam"));
        s2.setAge(15);
        s2.setNo("gwer1234");

        //比较的是地址是否一样
        System.out.println(s1.equals(s2));
    }
}

class Student1 {
    private String name;
    private int age;
    private String no;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getNo() {
        return no;
    }

    public void setNo(String no) {
        this.no = no;
    }

    @Override
    public String toString() {
        return "Student1{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", no='" + no + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student1 student1 = (Student1) o;
        return age == student1.age &&
                name.equals(student1.name) &&
                no.equals(student1.no);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, no);
    }
}
#+END_SRC

** String
1. String类是一个最终类
2. 字符串在Java底层是依靠字符数组来存储，字符数组是一个常量不可变
3. 字符串的内存：
   [[./Img/2.png]]
4. String str = "a";这句话只产生了一个对象
5. String str = new String("a");这句话产生了2个对象
6. String str = "a";String str2 = new String("a");这两句话产生了2个对象
7. 因为+在底层是调用StringBuilder中append，所以如果需要进行大量的字符串拼接的时候，建议直接使用StringBuilder,因为在底层要进行多次转换。
8. String类中提供了大量的操作字符串，但是不改变原字符串的方法
*** + 拼接与StringBuilder类的append方法
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo1 {
    public static void main(String[] args) {

        /*
        //字符串是一个常量，定义好之后不能变
        String str = "abc";
        //对字符串改值的时候，实际上是给str赋值了一个新的字符数组的地址
        str = "def";
        System.out.println(str);
         */

        //直接指向运行时常量池的空间地址
        String str1 = "ab";
        //会进入运行时常量池中指向值的地址
        String str2 = new String("ab");
        //"a"和"b"都是字面量，Java在编译的时候会对字面量运算来进行优化
        //所以这句话编译完成之后就是String str3 = "ab";
        //也就意味着str3和str1的地址值是一样的
        String str3 = "a" + "b";

        String str4 = "a";
        /*
        str4 += "b"本质上是一个变量和一个字面量在运算，那么这个时候Java在编译的时候不会优化
         +拼接在底层是调用StringBuilder中的append
        str4 += "b"等价于：
        new StringBuilder(str4).append("b").toString();
        */
        str4 +="b";

        System.out.println(str1 == str2);
        System.out.println(str1 == str3);
        System.out.println(str1 == str4);


    }
}

#+END_SRC
*** + 拼接与StringBuilder类的appen方法的验证
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo2 {
    public static void main(String[] args) {

        // 获取1970-01-01 00：00：00到现在时间的毫秒值
        long begin = System.currentTimeMillis();
        /*
        //7800+
        String str = "";
        for(int i = 0;i < 100000;i++){
            str += "a";
        }
        */

        //198
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i < 10000000;i++){
            sb.append("a");
        }
        String str = sb.toString();
        long end = System.currentTimeMillis();
        System.out.println(end - begin);
    }
}
#+END_SRC
*** charAt、toCharArray
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo3 {
    public static void main(String[] args) {

        /*
        String str = "big data";
        //获取字符串指定下标位置上的字符
        char c = str.charAt(2);
        System.out.println(c);

        //将字符串转化为字符数组
        char[] cs = str.toCharArray();
        for(char c1 : cs){
            System.out.println(c1);
        }
        */

        //将字符数组转化为字符串
        char[] cs = {'b','i','g',' ','d','a','t','a'};
        String str = new String(cs);
        System.out.println(str);
    }
}
#+END_SRC
*** compareTo、compareToIgnoreCase、concat、caontains
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo {
    public static void main(String[] args) {

        /*
        //7
        String s1 = "hijklmn";
        String s2 = "abcdefg";
        System.out.println(s1.compareTo(s2));
        */

        //-10
        String s1 = "hijklmn";
        String s2 = "hsafsaf";
        /*
            1. 当比较两个字符串的时候，实际上底层会将这两个字符串转化为字符串
                s1 --- arr1,s2 --- arr2
            2. 拿两个字符组对应位置上的字符进行比较
            3. 如果对应位置上的字符一样，则比较下一位
            4. 如果对应位置上的字符不一样，则返回对应位置上的字符之差
            5. 如果每一位都一样，但是一个字符数组首先遍历完，那么返回两个字符数组的长度之差
         */
        //如果返回值是正数，则说明s1 > s2
        //如果返回值是负数，则说明s1 < s2
        System.out.println(s1.compareTo(s2));

        //a - 97
        //A - 65
        String s3 = "abcdef";
        String s4 = "ABCDEF";
        System.out.println(s3.compareTo(s4));
        //忽略大小写进行比较
        System.out.println(s3.compareToIgnoreCase(s4));

        //concat()方法用于将指定的字符串参数连接到字符串上
        String s5 = "asdfgh";
        String s6 = "zxcvbn";
        System.out.println(s5.concat(s6));
        System.out.println(s5);

        //判断字符串中是否包含指定子串，包含返回true否则false
        System.out.println(s5.contains("a"));
    }
}

#+END_SRC

*** endsWith、startsWith、equals、instanceof、equalsIgnoreCase
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo2 {
    public static void main(String[] args) {

        String str = "abc";

        //判断字符串是否是指定结尾
        System.out.println(str.endsWith("e"));

        //判断字符串时候是指定开头
        System.out.println(str.startsWith("a"));

        String str2 = new String("abc");
        //System.out.println(str == str2);
        //String的equals做过重写，不在是建单的比较两个字符串的地址是否一样
        //而是比较两个字符串的值是否一样
        System.out.println(str.equals(str2));

        //判断"abc"是否是String对象
        System.out.println("abc" instanceof Object);


        String s1 = "abc";
        String s2 = "ABC";
        System.out.println(s1.equals(s2));
        //忽略大小写比较两个字符串是否一样 --- 用在验证码
        System.out.println(s1.equalsIgnoreCase(s2));

    }
}

#+END_SRC
*** getBytes、String
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo3{
    public static void main(String[] args) throws Exception{

        /*
        String str = "大数据";

        //将字符串按照当前项目的默认编码转化为字节数组
        //idea中默认编码是UTF-8
        //将字符转化为字节考虑编码，按照不同的编码转化出来的字节个数也是不一样的
        //byte[] bs = str.getBytes();
        //将字符串按照指定编码转化为字节数组
        byte[] bs = str.getBytes("gbk");
        System.out.println(bs.length);
        */

        /*
        //将字节数组转化为字符串
        //如果不指定编码，则是使用当前项目的编码
        byte[] bs = {97,98,99,100,101,102,103};
        //String str = new String(bs);

        //指定编码
        //String str = new String(bs,"gbk");

        System.out.println(str);
        */

        //将字节数组指定部分的元素转化为字符串
        //第二个参数表示从字节数组的哪一个位置开始转换
        //第三个参数表示要转化的字节个数
        byte[] bs2 = {97,98,99,100,101,102,103};
        String str = new String(bs2,2,4);

        System.out.println(str);

    }
}

#+END_SRC
*** hashCode、indexOf、intern、isEmpty
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo4 {
    public static void main(String[] args) {

        /*
        //96345
        String str = "abc";
        //"abc"的哈希吗
        //((31 * h + 'a') * 31 + 'b') * 31 + 'c'
        //"def"的哈希吗
        //((31 * 0 + 'd') * 31 + 'e') * 31 + 'f'
        //同一个字符串的哈希吗一定是相同的
        System.out.println(str.hashCode());
        */

        String str = "big data";
        //获取i出现的下标
        int index = str.indexOf("i");
        System.out.println(index);

        String str1 = "big data";
        //获取指定字符/字符串在字符串中第一次出现的下标
        int index1 = str.indexOf("a");
        System.out.println(index1);

        String str2 = "big data";
        //从指定的下标找指定元素出现的位置
        //如果指定的元素没有找到，则返回 -1
        int index2 = str.indexOf("d",5);
        System.out.println(index2);

        String s1 = "abc";
        String s2 = new String("abc");
        //intern返回这个字符串的常量池地址而不是堆内存的地址
        String s3 = new String("abc").intern();
        System.out.println(s1 == s2);
        System.out.println(s1 == s3);

        //判断字符串的长度是否为0
        System.out.println(s1.isEmpty());
        String s4 = " ";
        System.out.println(s4.isEmpty());
    }
}

#+END_SRC
*** lastIndexOf、replace、substring、toUpperCase、toLowerCase、trim
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo5 {
    public static void main(String[] args) {

        /*
        String str = "data";
        //lastIndexof表示找指定的字符串最后一次出现的下标
        int index = str.lastIndexOf("a");
        System.out.println(index);

        //获取指定字符串的长度
        System.out.println(str.length());

        //用指定字符进行替换
        //将这个字符串中的'a'替换为'+'
        System.out.println(str.replace('a','+'));
        */

        String str1 = "big data";
        //从指定下标开始，截取到末尾来截取一个子字符串
        String sub = str1.substring(4);
        System.out.println(sub);

        //在Java中，一般表示范围的时候，包括头部但是不包括尾部
        String sub1 = str1.substring(4,7);
        System.out.println(sub1);

        //将字符串中的所有的字符转化为大写
        System.out.println(str1.toUpperCase());

        //这个方法对汉字没有影响
        String str2 = "大数据";
        System.out.println(str2.toUpperCase());

        String str3 = "COMMAND OPTION";
        //将字符串中的所有的字符转化为小写
        System.out.println(str3.toLowerCase());

        //去掉字符串头部和尾部的空白字符
        String str = "    \t abc      ";
        System.out.println(str);
        System.out.println(str.trim());
    }
}

#+END_SRC
*** toString与String.valueOf的区别
#+BEGIN_SRC java
package cn.commandoptionesc.stringx;

public class StringDemo6 {
    public static void main(String[] args) {

        /*
        Object o = new Object();
        String s1 = o.toString();
        //对于对象而言，对象的toString和String.valueOf的效果是一样的
        String s2 = String.valueOf(o);
        System.out.println(s1);
        System.out.println(s2);
        */

        int[] arr = {2,3,7};
        String s1 = arr.toString();
        String s2 = String.valueOf(arr);
        System.out.println(s1);
        System.out.println(s2);

        char[] cs = {'a','b','c'};
        //对于字符数组而言，String.valueOf和toString方法的效果是不一样的
        //toString是获取字符数组的地址
        String s3 = cs.toString();
        //将字符数组中的每一个元素拿出来拼接成了一个字符串，而不是打印这个字符数组的地址
        String s4 = String.valueOf(cs);
        System.out.println(s3);
        System.out.println(s4);
    }
}

#+END_SRC
** 正则表达式
1. 针对字符串进行操作，利用指定的规则对字符串进行匹配、筛选、替换等操作
2. 符号：
   |--------+-------------------------------|
   | 正则   | 解释                          |
   | [xyz]  | x、y、z中的任何要给都可以     |
   | [^abc] | 表示出了a/b/c以外的元素       |
   | .      | 表示任意字符                  |
   | \\\\   | 匹配\                         |
   | \\.    | 匹配.                         |
   | \\w    | 单词字符，等价于[a-z A-Z 0-9] |
   | \\W    | 非单词字符                    |
   | \\d    | 数字，等价于[0-9]             |
   | \\D    | 非数字                        |
   | \\s    | 空白字符                      |
   | \\S    | 非空白字符                    |
   | +      | 至少一次                      |
   | ?      | 至多一次                      |
   | *      | 零次或者多次                  |
   | {n}    | 恰好出现n次                   |
   | {n,}   | 至少出现n次                   |
   | {n,m}  | 至少出现n次，但是不超过m次    |
3. 当()将一些字符放在一组的时候，构成了正则表达式中的捕获组
4. 捕获组的编号是从1开始递增，可以通过\\n的形式来引用对应编号的捕获组
5. 捕获组的编号计算是从（出现的顺序来依次递增）
*** 正则表达式举例
#+BEGIN_SRC java

package cn.commandoptionesc.regex;


import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo1 {
    public static void main(String[] args) {

        //判断一个字符串是否是"abc"

        // 第一种
        String str = "demo1";
        System.out.println(str.equals("abc"));

        //第二种
        String str1 = "demo3";
        //利用正则表达式完成判断
        //利用这个对象来指定规则
        Pattern p = Pattern.compile("abc");
        //需要获取一个匹配器
        Matcher m = p.matcher(str1);
        //获取一个匹配结果
        boolean b = m.matches();
        System.out.println(b);

        //第三种
        //第三种等价于第二种
        boolean b2 = str.matches("abc");
        System.out.println(b2);
    }
}
#+END_SRC
*** 空括号
[xyz]、[^abc]
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo2 {
    public static void main(String[] args) {

        /*
        //判断字符串是否是由一个数字组成
        String str = "1";
        //[xyz] --- 表示x、y、z中的任何一个
        System.out.println(str.matches("[0123456789]"));
        //[]中是一个连写范围的时候，可以使用'-'来表示连续范围
        System.out.println(str.matches("[0-9]"));
        */

        /*
        //匹配：字符串由3个字符组成，第一个字符是小写字母，第二个字符是一个数字，第三个字符是一个大写字母
        String str = "";
        System.out.println(str.matches("[a-z][0-9][A-Z]"));
        */

        /*
        //匹配：字符串由一个字符组成，而这个字符不是a/b/c
        String str = " ";
        System.out.println(str.matches("[^abc]"));
        */
    }
}
#+END_SRC
*** . \
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo3 {
    public static void main(String[] args) {

        /*
        //匹配：字符串由2个字符组成，第一个字符是数字，第二个字符可以是任意字符
        String str = "2+";
        // . 表示任意字符
        System.out.println(str.matches("[0-9]."));
        */

        /*
        //匹配： .
        String str = ".";
        System.out.println(str.matches("\\."));
        */

        /*
        //匹配：\
        String str = "\\";
        System.out.println(str.matches("\\\\"));
        */
    }
}

#+END_SRC

*** + ？ *
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo4 {
    public static void main(String[] args) {

        /*
        //匹配：由小写字母组成的字符串
        String str = "ace";
        //可以理解为这个字符串中至少由一个小写字母组成
        // + 表示至少一次
        System.out.println(str.matches("[a-z] + "));
        */

        /*
        //匹配：由数字开头的最多2个字符组成的字符串
        String str = "32";
        // ? 表示之多一次
        System.out.println(str.matches("[0-9].?"));
        */

        //匹配：由数字开头的字符串
        String str = "2a3";
        // * 表示零次或者多次
        System.out.println(str.matches("[0-9].*"));
    }
}

#+END_SRC
*** {n} {n,} {n,m}
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo1 {
    public static void main(String[] args) {

        /*
        //判断字符串中是否有数字
        String str = "b5a";
        System.out.println(str.matches(".*[0-9].*"));
        */

        /*
        //匹配：由5个小写字符组成的字符串
        String str = "224jhhj";
        //{n}表示恰好出现n次
        System.out.println(str.matches("[a-z]{5}"));
        */

        /*
        //匹配：由至少5个小写字母组成的字符串
        String str = "abcdeg";
        //{n,}表示敲好出现5次
        System.out.println(str.matches("[a-z]{5,}"));
        */

        //匹配：由6-12个字符组成的字符串
        String str = "";
        //{n,m}表示至少出现n次但是不超过m次
        System.out.println(str.matches(".{6,12}"));
    }
}

#+END_SRC
*** 捕获编号
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo2 {
    public static void main(String[] args) {

        /*
        //匹配：字符串中出现2次 "ab" 的字符串
        String str = "sfsfsf";
        //当()将一些字符放在一组的时候，构成了正则表达式中的捕获组
        System.out.println(str.matches(".*(ab).*(ab).*"));

        //捕获组的编号是从1开始依次向上递增
        // \\n表示引用前边对应编号的捕获组
        System.out.println(str.matches(".*(ab).*\\1.*"));
        */

        /*
        //匹配：叠字
        String str = "哈哈哈";
        System.out.println(str.matches("(.)\\1+"));
        */

        /*
        //匹配：AABB形式的词语
        String str = "高高兴兴";
        System.out.println(str.matches("(.)\\1(.)\\2"));
        */

        /*
        //匹配：ABAB形式的词语
        String str = "溜达溜达";
        System.out.println(str.matches("(..)=\\1"));
        */

        //捕获组的编号是从(出现的顺序开始依次编号)
        // (A(BC)D)E)(F)
        // \\1 A((BC)D)E
        // \\2 (BC)D
        // \\3 BC
        // \\4 F
    }
}

#+END_SRC
*** $n
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

public class RegexDemo3 {
    public static void main(String[] args) {

        /*
        String str = "abc2def3xyz";
        //将字符串中所有的数字替换为*
        System.out.println(str.replaceAll("[0-9]","*"));

        //将字符串中的所有的数字都去除
        System.out.println(str.replaceAll("[0-9]",""));
        */

        /*
        String str = "我我我我爱爱爱爱学学习";
        //将这个字符串还原为"我爱学习"
        //$n在替换过程中表示引用前边对应编号的捕获组
        System.out.println(str.replaceAll("(.)\\1+","$1"));
        */

        String str = "Amy Sam Tom Bob Lucy";
        System.out.println(str.replaceAll("(.*)(Sam)(.*)(Lucy)","$1$4$3$2"));
    }
}

#+END_SRC
*** 切分split
#+BEGIN_SRC java
package cn.commandoptionesc.regex;

import java.util.Arrays;

public class RegexDemo4 {
    public static void main(String[] args) {

        String str = "abc2def3xyz";
        //以数字为符号将字符串切分
        //作为切分符号的数字在切分过程中会被切掉
        String[] arr = str.split("[0-9]");
        System.out.println(Arrays.toString(arr));
    }
}

#+END_SRC
** 包装类
1. 在Java中，基本类型的变量身上没有任何的方法和属性提供使用，如果需要操着这个基本类型，那么需要自动以过程来使用。因此Java针对每种基本类型都提供了对应的类形式来便捷的操作数据。提供的类形式就称之为包装类
2. 包装类：

   |----------+------+-------+---------+------+-------+--------+-----------+--------|
   | 基本类型 | byte | short | int     | long | float | double | char      | booble |
   | 包装类   | Byte | Short | Integer | Long | Float | Double | Character | Booble |
   |----------+------+-------+---------+------+-------+--------+-----------+--------|
3. 将基本类型的变量直接赋值给引用类型的对象，这个过程称之为自动封箱。自动封箱在底层会调用对应类身上的valueOf方法
4. 将引用类型的对象直接赋值给基本类型的变量，这个过程称之为自动拆箱。自动拆箱在底层会调用对应对象身上的***Value方法
#+BEGIN_SRC java
package cn.commandoptionesc.integer;

public class IntegerDemo {
    public static void main(String[] args) {

        //int i = 157;

        /*
        //将基本类型的变量封装成对应的包装类型
        Integer in = new Integer(i);
        System.out.println(in);
        */

        /*
        //将基本类型的变量i赋值给了对应的引用类型的对象in
        //自动封箱
        //在底层就会调用Integer类身上的valueOf方法将i封装成Integer对象
        //等价于  Integer in = Integer.valueOf(i);
        Integer in = i;
        */

        /*
        double d = 3.57;
        //相当于Double dou = Double.valueOf(d);
        Double dou = d;
        */

        //自动拆箱
        Integer in = new Integer(4);
        //在底层会调用in对象身上的intValue方法
        int i = in;

        Double dou = new Double(3.28);
        //double d = dou.doubleValue();
        double d = dou;

        Character ch = new Character('a');
        //char c = ch.charValue();
        char c = ch;






    }
}

#+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.integer;

public class IntegerDemo2 {
    public static void main(String[] args) {

        //这种写法在底层会自动封箱，调用对应类身上的ValueOf方法
        //当数据在 -128 ~ 127的时候，会从cache数组中获取对应位置上的值
        //cache是一个静态数组，所以从同一个数组中拿值
        Integer i1 = 25;// new Integer(325);
        Integer i2 = 25;// new Integer(325);

        //用==比较，比较两个对象的地址是否一致
        System.out.println(i1 == i2);

        //当包装类型和基本类型进行运算的时候，底层会将包装类型进行自动拆箱
        //所以是两个基本类型在参与运算
        Integer i3 = new Integer(500);
        int i4 = 500;
        System.out.println(i3 == i4);
    }
}

#+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.integer;

public class IntegerDemo3 {
    public static void main(String[] args) {

        Integer i = new Integer("123");
        System.out.println(i);
        //NumberFormatException --- 数字格式异常
        //Integer i2 = new Integer("abc");
        Double d = new Double("6.81");
        System.out.println(d);
        //只要字符串不是"true"那么结果就是false
        Boolean b = new Boolean("true");
        System.out.println(b);

        int i2 = Integer.parseInt("124");
    }
}

#+END_SRC
** 数字运算
1. BigDecimal是一个能够对小数进行精确运算的类。在静思园的时候要求参数以字符串形式传入
2. BigInteger：能存储和计算超大整数
3. Math：针对基本类型提供了初等数学运算 - 指数、对数、、幂、三角函数等
#+BEGIN_SRC java
package cn.commandoptionesc.big;

import java.math.BigDecimal;

public class BigDecimalDemo {
    public static void main(String[] args) {

        //小数在计算的时候无法保证精确
        double d1 = 3.31;
        double d2 = 2.97;
        System.out.println(d1 - d2);

        //如果需要对小数运算保证精确性，那么需要BigDecimal
        BigDecimal b1 = new BigDecimal(3.31);
        BigDecimal b2 = new BigDecimal(2.97);
        //等价于3.31 - 2.97
        System.out.println(b1.subtract(b2));
        //等价于3.31 + 2.97
        System.out.println(b1.add(b2));

        //如果需要BigDecimal进行精确运算，那么需要将参数以字符串形式来传入
        //当字符串传形式传入的时候，在底层会以字符数组形式来计算
        BigDecimal b3 = new BigDecimal("3.31");
        BigDecimal b4 = new BigDecimal("2.97");

        System.out.println(b3.subtract(b4));
        System.out.println(b3.add(b4));
    }
}

#+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.big;

import java.math.BigInteger;

public class BigIntegerDemo {
    public static void main(String[] args) {

        BigInteger b1 = new BigInteger("234234256325345325325");
        BigInteger b2 = new BigInteger("3435352345234642341234252345");
        BigInteger r = b1.multiply(b2);
        System.out.println(r);
    }
}

#+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.big;

public class MathDemo {
    public static void main(String[] args) {

        /*
        //自然底数
        System.out.println(Math.E);

        //圆周率
        System.out.println(Math.PI);

        //绝对值
        System.out.println(Math.abs(-9));

        //立方根
        System.out.println(Math.cbrt(27));

        //向上取整
        System.out.println(Math.ceil(3.1));

        //向下取整
        System.out.println(Math.floor(2.9));

        //四舍五入
        System.out.println(Math.round(3.45));

        //获取[0,1)的随机小数
        System.out.println(Math.random());

        //产生6位数字组成的验证码
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i < 6;i++){
            //产生0-9之间的随机数字
            //[0,10)
            int num = (int)Math.random() * 10;
            sb.append(num);
        }
        System.out.println(sb.toString());
        */

        String str = "abcdefghijklmnopqrstuvwxyz0123456789";
        char[] cs = str.toCharArray();
        int len = cs.length;
        StringBuilder sb = new StringBuilder();
        for(int i = 0;i < 8;i++){
            int index = (int)(Math.random() * len);
            sb.append(cs[index]);
        }
        System.out.println(sb.toString());
    }
}

#+END_SRC
** 日期
1. Date类：这个类是属于java.util包下
   - 如果不指定，默认获取的是当前系统的时间
   - SimpleDateFormat负责在字符串和日期之间来进行转化的，在转化的时候需要制定格式
   #+BEGIN_SRC java
   package cn.commandoptionesc.Date;

   import java.text.SimpleDateFormat;
   import java.util.Date;

   public class DateDemo {
       public static void main(String[] args) throws Exception{

           /*
           //需要先获取一个Date对象
           //如果不指定，默认获取的是当前系统的时间
           Date date = new Date();
           System.out.println(date);
           */

           /*
           //指定日期：2000-10-15
           //这个long类型的参数所对应的必须是从1970-1- 00:00:00 到指定时的毫秒值
           Date date1 = new Date(242412424124L);
           System.out.println(date1);
           */

           /*
           //这是方法是在1900-01的基础上进行累加
           //这种写法比较麻烦，需要计算日期
           //而且实际开发过程中，日期形式往往是以字符串形式体现
           //那么还得考虑将字符串你转化为数字之后才能使用
           //Date上的横线表示已过时---这个方法依然可以使用，但不推荐使用，在后续版本中可能会被删除
           Date date2 = new Date(2000,10,15);
           System.out.println(date2);
           */

           //实际开发中，日期往往是以字符串形式给定
           //实际生活中，日期的表现形式是比较多样的
           //2000-10-15
           //2000.10.15
           //2000/10/15
           //例如：
           String str = "2000-10-15 14:25:54";
           //这个类可以将字符串转化为日期，也可以将日期转化为字符串
           //在转化的时候，需要制定格式
           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
           //将一个字符串来转化日期
           //将日期在转化为字符串
           Date date = sdf.parse(str);

           //希望打印格式是:XXX年XX月XX日 XX时XX分XX秒
           SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
           String s = sdf2.format(date);
           System.out.println(date);
           System.out.println(s);
           //yyyy-MM-dd -> yyyy/MM/dd
       }
   }
   #+END_SRC
2. Calender类：这个类是属于java.util包下的，是JDK1.2推出来用于取代Date类，但是实际开发中依然会使用Date
   [[./Img/3.png]]
   #+BEGIN_SRC java
   package cn.commandoptionesc.Date;

   import java.util.Calendar;

   public class CalendarDemo {
       public static void main(String[] args) {

           //Calendar本身是一个抽象类，不允许new

           Calendar c = Calendar.getInstance();
           //java.util.GregorianCalendar[time=1596697392492,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2020,MONTH=7,WEEK_OF_YEAR=32,WEEK_OF_MONTH=2,DAY_OF_MONTH=6,DAY_OF_YEAR=219,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=1,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=3,SECOND=12,MILLISECOND=492,ZONE_OFFSET=28800000,DST_OFFSET=0]
           //java.util.GregorianCalendar --- 格里高利历
           //time = ...... --- 从1970-01-01 00:00:00到指定时间的毫秒值
           //zone --- 时区
           //offset --- 时区偏移量
           //firstDayOfWeek = 1 --- 一个周的第一天为1
           //MONTH = 11 --- 第12月，因为这个月是从0开始计算
           //WEEK_OF_YEAR = 52 --- 这一年的第52个周
           //WEEK_OF_MONTH = 4 --- 这一周的第4天，从星期天开始算，4表示星期三
           //DAY_OF_MONTH = 25 --- 这个月的第25天
           //DAY_OF_YEAR = 359 --- 这一天是这一年的359天
           //DAY_OF_WEEK =4 --- 这一天是这一周的第四天
           System.out.println(c);
       }
   }
   #+END_SRC

* API(二)
** 异常
1. 异常是Java中提供的一套用于问题的反馈和处理的机制
   #+BEGIN_SRC java
   package cn.commandoptionesc.ex;

   import java.io.File;
   import java.io.FileNotFoundException;

   public class ExDemo {
       public static void main(String[] args) throws FileNotFoundException {
           try {
               String msg = readTxt("~/Documents/ex.txt");
           }catch (FileNotFoundException e){
               //处理问题
           }
       }
       public static String readTxt(String path)throws FileNotFoundException{
           //路径不存在
           if(判断路径是否存在)
               //将问题包装成一个异常对象来抛出
               throw new FileNotFoundException();
           return "读取到的内容";
       }
   }
   #+END_SRC
2. Java中异常的提携结构：
   - 异常的顶级父类是Throwable，包含2个子类：Error和Exception
   - Error：错误 - 表示一个合理的应用程序中出现的不应该补货的严重问题 - Error出现无法处理 - StackOverflowError
   - Exception：异常。出现之后可以处理，处理方式分为两种：throws抛出或者try-catch捕获
     + 编译时异常（已检查异常）：在编译阶段就已经出现，要求必须立即处理
     + 运行时异常（未检查异常）：在编译时不报错而是在运行阶段出现，可以处理可以不处理，在Java中，所有的运行时异常都需要继承RuntimeException
   #+BEGIN_SRC java
   package cn.commandoptionesc.exception;

   import java.text.ParseException;
   import java.text.SimpleDateFormat;

   public class ExceptionDemo1 {
       public static void main(String[] args) {

           /*
           //运行时异常
           inta[] arr = new int[4];
           System.out.println(arr[5]);
           */

           /*
           //编译时异常
           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
           sdf.parse("2019-01-10");
           */



           int[] arr = new int[4];
           try {
               System.out.println(arr[5]);
           }catch(ArrayIndexOutOfBoundsException e){
               System.out.println("出现一个数组下标越界异常");
           }

           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
           try {
               sdf.parse("2019-01-10");
           }catch(ParseException e){
               e.printStackTrace();
           }
       }
   }

   #+END_SRC
3. 如果需要的异常在Java中没有提供，那么久需要自定义异常。如果需要自定义异常，那么需要写一个类继承Exception或者是其子类
4. 如果程序中排除了异常，那么异常之后的代码就不再执行。但是异常被捕获之后，catch之后的程序可以继续执行
5. 异常的处理方法：
   - 如果每一个异常的处理方式都不一样，那么可以分别catch分别处理
   - 如果所有异常的处理方式都一样，那么可以捕获一个异常的父类，进行统一处理   catch(exception e){}
     #+BEGIN_SRC java
     package cn.commandoptionesc.exception;

     import java.io.FileNotFoundException;
     import java.io.IOException;

     public class ExceptionDemo3 {
         public static void main(String[] args) throws FileNotFoundException {

             try {
                 //readTxt("文件路径");
                 String str = readTxt(null);
                 System.out.println(str);
             }catch (Exception e){
                 //System.out.println("捕获了一个空指针异常");
                 e.printStackTrace();
             }
             System.out.println("finish");
         }

         public static String readTxt(String path) throws FileNotFoundException,FileFormatException1,NullPointerException{

             if(path == null)
             throw new NullPointerException();
             if(path.startsWith("H:\\")) {
                 throw new FileNotFoundException();
             }
             if(!path.endsWith(".txt")){
                 throw new FileFormatException1("需要一个txt文件，但是传入的不是tet文件");
             }
             return "读取成功啦";
         }
     }

     class FileFormatException1 extends IOException {

         public FileFormatException1(){
     }
         public FileFormatException1(String msg){
             super(msg);
         }
     }
     #+END_SRC
   - 如果异常需要分组处理，那么同一组的异常之间可以用 | 隔开 - 这种方式是JDK1.7提供的方式
     #+BEGIN_SRC java
     package cn.commandoptionesc.exception;

     import java.io.FileNotFoundException;
     import java.io.IOException;

     public class ExceptionDemo4 {
         public static void main(String[] args) throws FileNotFoundException {

             //当调用这个方法的时候，会发现这个方法有异常抛出，需要处理
             try {
                 //readTxt("文件路径");
                 String str = readTxt(null);
                 System.out.println(str);
             }catch (FileNotFoundException | FileFormatException2 e){
                 System.out.println(e.getMessage());
             }catch(NullPointerException e){
                 //System.out.println("捕获了一个空指针异常");
                 //打印栈轨迹
                 e.printStackTrace();
             }
             System.out.println("finish");
         }

         public static String readTxt(String path) throws FileNotFoundException,FileFormatException2,NullPointerException{

             //判断参数是否为空
             if(path == null)
                 throw new NullPointerException();
             if(path.startsWith("H:\\")) {
                 //需要反馈这个问题，将问题以异常对象形式来反馈
                 throw new FileNotFoundException();
             }
             if(!path.endsWith(".txt")){
                 throw new FileFormatException2("需要一个txt文件，但是传入的不是tet文件");
             }
             return "读取成功啦";
         }
     }


     class FileFormatException2 extends IOException {

         public FileFormatException2(){

         }
         public FileFormatException2(String msg){
             super(msg);
         }

     }
     #+END_SRC
6. 异常不影响方法的重载，但是在重写的时候，子类异常不能超过父类的异常
   #+BEGIN_SRC java
   package cn.commandoptionesc.exception;

   import java.io.IOException;
   import java.sql.SQLException;

   public class ExceptionDemo5 {
       public static void main(String[] args) {

       }
   }

   class A{
       public void m() throws IOException{
           System.out.println("A m()");
       }
       public void m(int i) throws SQLException {
           System.out.println("A m(int)");
       }
   }

   class B extends A{
       //子类在重写父类中的方法的时候，抛出的编译异常不能超过父类异常的范围
       @Override
       public void m() throws IOException {
           System.out.println("B m()");
    }
}
   #+END_SRC
7. try-catch-finally中的finally的特点是：无论出现异常与否，这个finally中的代码都会执行一次
   #+BEGIN_SRC java
   package cn.commandoptionesc.exception;

   public class ExceptionDemo {
       public static void main(String[] args) {

           //如果异常在处理完成之后需要进行善后
           //finally:五路你出现异常与否，finally代码块都得执行一次
           try{
               System.out.println(10/0);
           }catch(Exception e){
               System.out.println("捕获异常");
           }finally{
               System.out.println("running");
           }
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.exception;

   public class ExceptionDemo2 {
       public static void main(String[] args) {
           System.out.println(m());
       }

       //代码是从上到下从左到右来一次编译运行的
       public static int m(){

           int i = 5;
           try{
               //先编译try中的return，return i++;因为++在i之后，所以先将i的值5取出来
               //将5标记为结果，然后i自增为6，准备返回的时候，发现还有一个finally需要执行
               //执行finally将i自增为7，进行返回，此时标记的返回结果是5，所以返回的也是5
               return i++;
           }catch(Exception e){
               return i++;
           }finally {
               i++;
               System.out.println("finally:" + i);
           }
       }
   }
   #+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc.exception;

import java.io.FileNotFoundException;
import java.io.IOException;

public class ExceptionDemo2 {
    public static void main(String[] args) throws FileNotFoundException {

        //当调用这个方法的时候，会发现这个方法有异常抛出，需要处理
        try {
            //readTxt("文件路径");
            String str = readTxt(null);
            System.out.println(str);
        }catch (FileNotFoundException e){
            //打印栈轨迹
            e.printStackTrace();
        }catch(FileFormatException e){
            System.out.println(e.getMessage());
        }catch(NullPointerException e){
            System.out.println("捕获了一个空指针异常");
        }
        System.out.println("finish");
    }

    public static String readTxt(String path) throws FileNotFoundException,FileFormatException,NullPointerException{

        //判断参数是否为空
        if(path == null)
            throw new NullPointerException();



        //路径不存在
        //模拟：如果盘符是以H开头，表示路径不存在
        if(path.startsWith("H:\\")) {
            //需要反馈这个问题，将问题以异常对象形式来反馈
            throw new FileNotFoundException();
        }

        //如果传入的路径对应的文件不是TXT文件
        if(!path.endsWith(".txt")){
            throw new FileFormatException("需要一个txt文件，但是传入的不是tet文件");
        }
        return "读取成功啦";
    }
}


class FileFormatException extends IOException {

    //private String message;

    public FileFormatException(){

    }
    public FileFormatException(String msg){
        //this.message = msg;
        super(msg);
    }

    /*
    @Override
    public String getMessage() {
        return message;
    }
    */
}
#+END_SRC
** 集合
1. 集合是Java中提供的一套容器机制，这个容器的特点是大小不固定
2. Collection是集合的顶级接口，包含了很多的字接口以及实现类：List、Set、Queue等
3. <E>表示泛型，用于规定集合中元素的类型，因为泛型的限制，所以集合中存储的类型必须是引用类型:Collection<Integer>,Collection<Double>等；int[] arr,---arr的数据类型是数组，元素类型是int；Collection<String> c;---c的数据类型是Collection，元素类型是String
#+BEGIN_SRC java
package cn.commandoptionesc.Collection;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionDemo {
    public static void main(String[] args) {

        //创建一个集合对象
        //表示创建了一个集合，集合中存储的元素类型是String
        //集合在创建的时候，后边类型的泛型可以不写，会根据前边的类型进行自动推到
        Collection<String> c = new ArrayList<>();

        //添加元素
        c.add("a");
        c.add("b");
        c.add("f");

        String[] arr = c.toArray(new String[0]);
        for(String s : arr){
            System.out.println(s);
        }

        Object[] os = c.toArray();
        for(Object o : os){
            System.out.println(o);
        }

        //获取元素个数
        System.out.println(c.size());

        //判断元素是否存在
        boolean r = c.contains("o");
        System.out.println(r);

        //清空集合
        c.clear();

        //判断集合是否为空
        System.out.println(c.isEmpty());


        //删除指定的元素
        c.remove("b");
        //如果移除的元素不存在，则不会出现任何问题
        //底层会首先判断这个元素是否存在
        c.remove("e");

        System.out.println(c);
    }
}

#+END_SRC
4. List:列表
   - 元素有序（指的是保证元素的添加顺序），允许添加重复元素
   - 提供了下标来获取元素
   #+BEGIN_SRC java
   package cn.commandoptionesc.Collection;

   import java.util.ArrayList;
   import java.util.List;

   public class ListDemo {
       public static void main(String[] args) {

           List<String> list = new ArrayList<>();
           list.add("f");
           list.add("e");
           list.add("a");
           list.add("y");
           list.add("e");
           //在列表的指定下标位置上来插入元素:[f,e,a,s,y,e]
           list.add(3,"s");
           //IndexOutOfBoundsException:下标越界
           //list.add(-1,"f");
           System.out.println(list);

           List<String> list2 = new ArrayList<>();
           list2.add("f");
           list2.add("e");
           list2.add("a");
           list2.add("y");
           list2.add("e");
           System.out.println(list.equals(list2));

           List<String> list3 = new ArrayList<>();
           list3.add(new String("f"));
           list3.add(new String("e"));
           list3.add(new String("a"));
           list3.add(new String("y"));
           list3.add(new String("e"));
           //比较两个list是否一致
           //逐位比较，每一位上的元素是否一致
           System.out.println(list.equals(list3));

           List<String> list4 = new ArrayList<>();
           list4.add("f");
           list4.add("e");
           list4.add("a");
           list4.add("y");
           list4.add("e");

           //获取指定下标位置上的元素
           System.out.println(list4.get(0));

           //获取指定元素第一次出现的下标
           //如果没有找到，则返回-1
           System.out.println(list4.indexOf("s"));

           //获取指定元素最后一次出现的下标
           System.out.println(list4.lastIndexOf("e"));

           //溢出指定的元素，但是注意，只移除第一个
           list4.remove("e");

           //移除指定位置上的元素
           list4.remove(0);

           //替换指定位置上的元素
           System.out.println(list.set(0,"h"));

           //截取字列表 - 包头不包尾
           System.out.println(list.subList(0,3));
       }
   }

   #+END_SRC
   - 实现类：ArrayList底层是基于数组的，默认初始容量为10.每次扩容默认是在上一次容量的基础上增加一半的容量，也就意味着初始容量是10，那么扩容之后的容量就是15，再次扩容之后的容量就是22 - 用数组来模拟一个ArrayList - 线程不安全的列表 - ArrayList是便于查询而不便于增删
     #+BEGIN_SRC java
     package cn.commandoptionesc.collection;

     import java.util.Arrays;

     public class ArrayListDemo {
         public static void main(String[] args) {

         }
     }

     //模拟ArrayList
     class ArrList{

         //需要先定义一个数组来存储元素
         private String[] data;
         //表示元素个数，也表示要添加的元素的下标
         private  int size = 0;

         public ArrList(){

             //如果没有参数，则数组的初始容量定义为10
             data = new String[10];
         }

         public ArrList(int initialCapacity){

             //需要先判断这个容量是否合法
             if(initialCapacity < 0)
                 throw new IllegalArgumentException();
             //如果容量合法，则赋值
             data = new String[initialCapacity];
         }

         //添加元素
         public void add(String str){

             //判断是否需要扩容
             if(size >= data.length)
                 grow();
             data[size] = str;
             size++;
         }

         private  void grow(){
             if(data.length <= 1)
                 data = Arrays.copyOf(data,data.length + 1);
             else
                 data = Arrays.copyOf(data,data.length + (data.length >> 1));
         }
     }

     #+END_SRC
     #+BEGIN_SRC java
     package cn.commandoptionesc.collection;

     import java.util.Arrays;
     import java.util.Objects;

     public class ArrayListDemo {
         public static void main(String[] args) {
             ArrList list = new ArrList(3);
             list.add("a");
             list.add("b");
             list.add("c");
             list.add("d");
             list.add("e");

             list.add(0,"f");

             System.out.println(list.indexOf("c"));
             list.remove(0);
             System.out.println(list);
         }
     }

     //模拟ArrayList
     class ArrList{

         //需要先定义一个数组来存储元素
         private String[] data;
         //表示元素个数，也表示要添加的元素的下标
         private  int size = 0;

         public ArrList(){

             //如果没有参数，则数组的初始容量定义为10
             data = new String[10];
         }

         public ArrList(int initialCapacity){

             //需要先判断这个容量是否合法
             if(initialCapacity < 0)
                 throw new IllegalArgumentException();
             //如果容量合法，则赋值
             data = new String[initialCapacity];
         }

         //添加元素
         public void add(String str){

             //判断是否需要扩容
             if(size >= data.length)
                 grow();
             data[size] = str;
             size++;
         }

         //扩容
         private  void grow(){
             if(data.length <= 1)
                 data = Arrays.copyOf(data,data.length + 1);
             else
                 data = Arrays.copyOf(data,data.length + (data.length >> 1));
         }

         //插入元素
         public void add(int index,String str){

             //判断插入的下标是否越界
             if(index > size || index < 0)
                 throw new IndexOutOfBoundsException("size:" + size + ",Index:" + index);

             //判断是否需要扩容
             if(size >= data.length)
                 grow();

             for(int i = size - 1;i >= index;i--){
                 data[i + 1] = data[i];
             }

             //将元素放入index位
             data[index] = str;

             //元素个数+1
             size++;
         }
         //清空列表
         public void clear(){

             data = new String[10];
             size = 0;
         }

         //获取指定元素第一次出现的下标
         //data[i] = null
         //str = null
         public int indexOf(String str){

             for(int i = 0;i < size;i++){
                 if(data[i] == str || data[i] != null && data[i].equals(str))
                     return i;
             }
             //如果整个循环结束都没有返回，那就说明没有这个元素
             return -1;
         }

         //判断是否有指定的元素
         public boolean contains(String str){

             int index = indexOf(str);
             return index != -1;
         }

         @Override
         public boolean equals(Object obj){
             //判断地址是否一致
             if(this == obj)
                 return true;

             //判断参数是否为空
             if(obj == null)
                 return false;

             if(obj.getClass() != this.getClass())
                 return  false;

             ArrList list = (ArrList) obj;

             if(this.size != list.size)
                 return false;

                 for(int i = 0;i < size; i++){
            String s1 = this.data[i];
            String s2 = list.data[i];
            if(s1 == null){
                if(s2 != null)
                    return false;
            }else if(!s1.equals(s2))
                return false;
        }
        return true;
    }

    //判断下标是否越界
    private void outOfIndex(int index){
        if(index < 0 || index >= size)
            throw new IndexOutOfBoundsException("Size:" + size + ",Index:" + index);
    }

    //获取指定下标上的元素
    public String get(int index){

            //判断下标是否越界
            outOfIndex(index);

            return data[index];
    }

        //判断集合是否为空
        public boolean isEmpty() {
            return size == 0;
        }

        //获取指定元素最后一次出现的下标
    public int lastIndexOf(String str){
        for(int i = size - 1;i >= 0;i--){
            if(data[8] == str || data[i] != null && data[i].equals(str))
                return i;
        }
        return -1;
    }

    //移除指定下标位置上的元素
    public void remove(int index){

            //判断下标是否越界
            outOfIndex(index);
            for(int i = index;i < size -1;i++){
                data[i] = data[i + 1];
            }
            size--;
        }

        //移除指定的元素,注意只移除第一个
        public void remove(String str){

            //获取元素的下标
            int index = indexOf(str);

            if(index != -1){
                this.remove(index);
            }
        }

        //替换指定位置上的元素
        public void set(int index,String str){
            //判断下标是否越界
            outOfIndex(index);
            data[index] = str;
        }

        //获取元素个数
        public int size(){
            return size;
        }

        //截取子列表
        public ArrList subList(int fromIndex,int toIndex){

            //判断下标是否合法
            if(toIndex < fromIndex || fromIndex < 0 || toIndex < 0 || fromIndex > size || toIndex > size)
                throw new IllegalArgumentException();
            ArrList sub = new ArrList();
            for(int i = fromIndex;i < toIndex;i++){
                sub.add(data[i]);
            }
            return sub;
        }

        //重写toString
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder("[");
            for(int i = 0;i < size;i++){
                sb.append(data[i]).append(",");
            }

             String str = sb.toString();
             if(str.length() > 2)
                 str = str.substring(0,str.length() - 2);
             return str += "]";
         }
     }

     #+END_SRC
   - 实现类：LinkedList底层是基于节点的，没有初始容量，也就不需要考虑扩容 - 线程不安全的列表 - LinkedList是便于增删而不便于查询
     [[./Img0/4.png]]
     #+BEGIN_SRC java
     package cn.commandoptionesc.collection;

     import java.util.LinkedList;
     import java.util.List;

     public class LinkedListDemo {
         public static void main(String[] args) {

             //LinkedList和ArrayList的使用方式一致，但是底层实现是不一样
             List<String> list = new LinkedList<>();
             list.add("a");
             list.add("b");
             list.add("t");

             System.out.println(list);
         }
     }
     #+END_SRC
     #+BEGIN_SRC java
     package cn.commandoptionesc.collection;

     public class LinkedListDemo2 {
         public static void main(String[] args) {
             LinkList list = new LinkList();
             list.add("a");
             //list.add("a");
             //list.add("b");
             //list.add("c");
             //list.add("d");
             //list.add("e");
             //list.add("f");

             //list.remove(0);
             //list.remove(5);
             list.remove(2);

             //System.out.println(list.indexOf("c"));

             //list.add(0,g);
             //list.add(6,"g");
             //list.add(2,"g");

             //list.clear();
             System.out.println(list);
         }
     }

     //模拟一个LinkedList
     class LinkList {

         private Node first;//头节点
         private Node last;//尾节点
         private int size = 0;//记录元素个数

         //添加元素
         public void add(String str){

             //创建一个节点存储这个元素
             Node n = new Node(null,str,null);
             //判断这是不是添加的第一个元素
             if(size == 0){
                 //如果是一个元素，头节点和尾节点就是同一个节点
                 first = last = n;
             }else{
                 //尾节点的下一位是新节点
                 this.last.next = n;
                 //新节点的上一位是尾节点
                 n.prev = this.last;
                 this.last = n;
             }
             size++;
         }

         //插入元素
         public void add(int index,String str){

             //判断下标是否越界
             if(index < 0 || index > size)
                 throw new IllegalArgumentException();

             //创建一个Node对象来存储元素
             Node n = new Node(null,str,null);
             if(index == size){
                 //尾部追加
                 this.add(str);
                 return ;
             }else if(index == 0){
                 //头部插入
                 //新节点的下一位是原来的头节点
                 n.next = first;
                 //原来的头节点的上一位是新节点
                 first.prev = n;
                 //新节点成为头结点
                 first = n;
             }else {
                 //中间插入
                 //先找到要插入的下标位置对应的节点
                 Node node = this.getNode(index);

                 //原来的上一位的下一个节点成为新节点
                 node.prev.next = n;
                 //新节点的上一位是原来节点的上一位
                 n.prev = node.prev;
                 //新节点的下一位是原来的节点
                 n.next = node;
                 //原来节点的上一位是新节点
                 node.prev = n;


             }
             size ++;
         }

         //获取指定下标位置上的节点
         private Node getNode(int index){

             if(index <= size/2){
                 //下标在前半段
                 int i = 0;
                 Node n = this.first;

                 while (i < index){
                     n = n.next;
                     i++;
                 }
                 return n;
             }else{
                 //下标在后半段
                 int i = size - 1;
                 Node n = this.last;
                 while(i > index){
                     n = n.next;
                     i--;
                 }
                 return n;
             }
         }

         //清空集合
         public void clear(){

             size = 0;
             this.first = this.last = null;
         }

         //获取指定元素出现的节点
         public int indexOf(String str){

             Node n = this.first;
             for(int i = 0;i < size;i++){
                 String s = n.str;
                 if(str == s || s !=null && s.equals(str))
                     return i;

                 n = n.next;
             }
             return -1;
         }

         //判断是否有指定元素
         public boolean contains(String str){
             int index = indexOf(str);
             return index != -1;
         }

         private void outOfIndex(int index){
             if(index < 0 || index >= size)
                 throw new IndexOutOfBoundsException("Size:" + size + ",Index" + index);
         }


         //获取指定下标上的元素
         public String get(int index){
             //先判断下标是否越界
             outOfIndex(index);
             //获取指定小标上的元素
             Node n = this.getNode(index);
             return n.str;
         }

         public boolean isEmpty(){
             return size == 0;
         }

         //获取指定元素最后一次出现的下标
         public int lastIndexOf(String str){

             Node n = this.last;
             for(int i = size - 1;i >= 0;i--){
                 String s = n.str;
             if(s == str || s !=null && s.equals(str))
                 return i;
                 n = n.prev;
             }
             return -1;
         }

         //移除指定下标上的元素
         public void remove(int index){

             //判断下标是否越界
             this.outOfIndex(index);

             //判断是否只有1个元素
             if(size == 1){
                 first = last = null;
             }else if(index == 0){
                 //头部移除
                 //头节点的下一个就变成了新的头节点
                 first = first.next;
                 //原来的头节点的指向清空
                 first.prev.next = null;
                 //新的头节点的上一位也要清空
                 first.prev = null;
             }else if(index == size -1){
                 //尾部移除
                 //尾节点的上一位就变成了新的尾节点
                 last = last.prev;
                 //原来的尾节点的指定要清空
                 last.next.prev = null;
                 //新的尾节点的下一位也要清空
                 last.next = null;
             }else{
                 //中间移除
                 //先找到要移除的位置的元素
                 Node n = this.getNode(index);
                 //原来节点的上一位的下一个节点要指向原来的下一位
                 n.prev.next = n.next;
                 //原来节点的下一位的上一位节点要指向原来的上一位
                 n.next.prev = n.prev;
                 //这个节点的指向要清空
                 n.prev = null;
                 n.next = null;
                 n = null;
             }
             size --;
         }

         //移除指定的元素，只移动第一次
         public void remove(String str){
             int index = this.indexOf(str);
             if(index != -1)
             remove(index);
         }

         //替换指定位置上的元素
         public void set(int index,String str){
             //下标越界
             outOfIndex(index);
             //获取指定下标上的节点
             Node n = this.getNode(index);
             n.str = str;
         }

         //获取元素个数
         public int size(){
             return size;
         }

         //截取子字符串
         public LinkList subList(int fromIndex,int toIndex){
             if(fromIndex > toIndex || fromIndex < 0 || toIndex < 0 || fromIndex > size || toIndex > size)
                 throw new IllegalArgumentException();

             LinkList list = new LinkList();
             //获取到指定下标位置上的节点
             Node n = this.getNode(fromIndex);
             for(int i = fromIndex; i < toIndex;i++){
                 list.add(n.str);
                 n = n.next;
             }
             return list;
         }

         //添加方法
         @Override
         public String toString() {
             StringBuilder sb = new StringBuilder("[");
             Node n = this.first;
             for(int i = 0;i < size;i++){
                 sb.append(n.str).append(",");
                 //向后推后一位
                 n = n.next;
             }

             String str = sb.toString();
             if(str.length() > 2)
                 str = str.substring(0,str.length() - 2);

             return str += "]";
         }

         //提供一个内部类类存储节点信息
         private class Node {

             Node prev;//上一个节点
             String str;//数据
             Node next;//下一个节点

             public Node(Node prev, String str, Node next) {
                 this.prev = prev;
                 this.str = str;
                 this.next = next;
             }
         }
     }
     #+END_SRC
   - Vector:向量。类似于ArrayList，底层也是基于数组来存储，但是每次扩容的时候，默认是增加一倍 - Vector是一个线程安全的集合
   - Stack:栈。继承了Vector，本身是一个后进先出/先进后厨的结构。
     |-----------+--------------------|
     | 入栈/压栈 | 将元素放入栈中     |
     | 出站/弹栈 | 将元素从栈中取出   |
     | 栈底元素  | 最先放入栈中的元素 |
     | 栈顶元素  | 最后放入占中的元素 |
     |-----------+--------------------|
     #+BEGIN_SRC java
     package cn.commandoptionesc.collection;

     import java.util.Stack;

     public class StackDemo {
         public static void main(String[] args) {

             Stack<String> s = new Stack<>();

             //添加元素 - 入栈
             s.push("a");
             s.push("b");
             s.push("c");
             s.push("d");

             //从栈顶到栈地来寻找指定的元素第一次出现的位置，注意从1开始计费
             System.out.println("b");

             //获取但是不移除栈顶元素
             //如果栈为空，则抛出EmptyStackException
             //System.out.println(s.peek());

             //获取但是移除栈顶元素
             //System.out.println(s.pop());

             //判断是否为空
             //System.out.println(s.empty());

             //判断栈是否为空
             System.out.println(s);
         }
     }

     #+END_SRC
5. Set:散列集合
   - 特点：不保证元素的顺序，而且要求元素元素不重复
   - HashSet：在地城会对元素进行排序，默认是升序排序。要求存储在TreeSet中的元素对应的类必须实现Comparable接口
   #+BEGIN_SRC java
   package cn.commandoptionesc.collection;

   import java.util.HashSet;
   import java.util.Set;

   public class HashSetDemo {
       public static void main(String[] args) {


           Set<String> set = new HashSet<>();
           //不保证元素的存储顺序
           //没有下标
           set.add("big");
           set.add("java");
           set.add("java");
           set.add("commandoptionesc");
           set.add("java");

           for(String str : set){
               System.out.println(str);
           }


           System.out.println(set);
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.collection;

   import java.util.TreeSet;

   public class TreeSetDemo {
       public static void main(String[] args) {

           TreeSet<String> set = new TreeSet<>();

           set.add("r");
           set.add("a");
           set.add("g");
           set.add("i");
           set.add("r");

           System.out.println(set);

           TreeSet<Student> set1 = new TreeSet<>();
           set1.add(new Student("Bob",17,9));
           set1.add(new Student("Amy",18,70));
           set1.add(new Student("Tom",16,85));
           set1.add(new Student("Sam",16,60));
           for(Student s : set1){
               System.out.println(s);
           }
       }
   }

   class Student implements Comparable<Student>{
       private String name;
       private int age;
       private int score;

       public Student(String name,int age,int score){
           this.name = name;
           this.age = age;
           this.score = score;
       }

       @Override
       public String toString() {
           return "Student{" +
           "name='" + name + '\'' +
                  ", age=" + age +
                  ", score=" + score +
                  '}';

       }


       //决定排序顺序
       //需要指定要根据哪个属性进行排序
       //根据分数降序排序
       //降序排序：o - this
       //升序排序：this - o
       @Override
       public int compareTo(Student o) {
           //根据分数降序排序
           //return o.score - this.score;
           //根据年龄升序排序
           //排序的时候，如果值相减为0，则会认为是重复元素
           //Set不会存储重复的元素
           return this.age - o.age;
       }
   }
   #+END_SRC
6. Queue：队列，遵循先进先出的原则
   #+BEGIN_SRC java
   package cn.commandoptionesc.collection;

   import java.util.LinkedList;
   import java.util.Queue;

   public class QueueDemo {
       public static void main(String[] args) {

           //创建了一个队列
           Queue<String> queue = new LinkedList<>();

           //添加元素
           queue.add("a");
           queue.add("a");
           queue.add("a");

           //往外拿元素
           System.out.println(queue.poll());
           System.out.println(queue);

       }
   }

   #+END_SRC
** 和集合相关的类
1. Iterator：迭代器。实际上是利用迭代的方式去遍历一个集合。迭代器在迭代过程中不允许直接增删原集合，而是需要通过迭代器提供的remove方法移除。增强for循环本质上是一个简化版的迭代器，增强for循环底层也是利用迭代器来迭代遍历的。要求能够被迭代的元素对应的类必须实现Iterable接口。
   #+BEGIN_SRC java
   package cn.commandoptionesc.collection;

   import java.util.HashSet;
   import java.util.Iterator;
   import java.util.Set;

   public class IteratorDemo {
       public static void main(String[] args) {


           Set<String> set = new HashSet<>();
           set.add("a");
           set.add("b");
           set.add("d");
           set.add("e");
           set.add("f");

           //利用迭代器遍历，需要先获取迭代器
           Iterator<String> it = set.iterator();
           //判断是否有下一个
           while(it.hasNext()){
               //挪动指针获取元素
               String s = it.next();
               System.out.println(s);
               //迭代器在迭代过程中不允许直接增删原集合，而是需要通过迭代器提供的remove方法移除
               //set.remove(s);
               it.remove();
           }

           System.out.println(set);
       }
   }

   #+END_SRC
2. Collections：集合的工具类，提供了大量的操作集合的方法
** 泛型
1. 泛型的学名是参数化类型 - ParameterizedType
2. 在JDK1.5之前，没有泛型的概念，从JDK1.5开始，出现了泛型
   #+BEGIN_SRC java
   package cn.commandoptionesc.type;

   import java.util.ArrayList;
   import java.util.List;

   public class TypeDemo {
       public static void main(String[] args) {

           //在JDK1.5之前，没有泛型的概念，此时集合中的元素类型可以是任意类型
           //可以通过泛型规定元素类型，使得集合中的元素就统一了
           //再去使用集合的时候就不需要考虑类型带来的问题
           //List<String> list = new ArrayList<String>();
           //从JDK1.7开始，允许后边可以不写泛型，会根据前边的类型进行自动的推导
           //List<String> list = new ArrayList<>();

           List list = new ArrayList();
           list.add("a");
           list.add(2);
           list.add(true);

           for (Object o : list) {
               //需要判断类型之后才操作
               if (o instanceof String) {
                   System.out.println("这是一个字符串");
                   String str = (String) o;
               } else if (o instanceof Integer) {
                   System.out.println("这是一个整数");
                   Integer i = (Integer) o;

               }
           }
       }
   }
   #+END_SRC
3. 泛型的擦除：用具体类型来替换泛型的过程，反省的擦除发生在编译期间
4. 如果需要定义一个泛型类，那么只需要在类名之后添加<泛型名>就可以声明一个泛型
5. 通常情况下，只使用一个大写字母来给泛型命名，最常用的大写字母：T-type，E-Element,K-key,V-value,R-Result
#+BEGIN_SRC java
package cn.commandoptionesc.type;

public class TypeDemo2 {
    public static void main(String[] args) {

        Demo<String,Double> d1 = new Demo<>();
        d1.set("a");
    }
}

//将位置的属性的类型以泛型的形式来体现
//泛型的命名只要符合标识符的命名即可，但是通常状态下，一般使用1个大写字母来表示泛型
class Demo<T,A>{

    private  T t;
    private  A a;

    public T get(){
        return t;
    }

    public void set(T t){
        this.t = t;
    }


}

#+END_SRC
6. 在Java中，也允许给方法来单独定义一个泛型，此时这个方法称之为泛型方法
   #+BEGIN_SRC java
   package cn.commandoptionesc.type;

   public class TypeDemo3 {
       public static void main(String[] args) {

           TypeMethod t = new TypeMethod();
           t.printString("ac");
           t.printString(3);
       }
   }

   class TypeMethod{

       //需要传入一个参数，然后将参数转化为字符串打印出来
       //需要给当前的方法来单独定义一个泛型
       //此时这个泛型是这个方法独有的
       public<T> void printString(T t){
           System.out.println(t);
       }
   }

   #+END_SRC
7. ？extends类/接口，表示传入这个类/接口及其子类/子接口对象，此时称之为泛型的上限
   #+BEGIN_SRC java
   package cn.commandoptionesc.type;

   import java.util.ArrayList;
   import java.util.List;

   public class TypeDemo4 {

       public static void main(String[] args) {
           List<Cat> cats = new ArrayList<>();
           List<Dog> dogs = new ArrayList<>();
           List<Apple> apples = new ArrayList<>();

           //假设向各个集合中添加了很多元素
           //泛型没有向上造型
           forEachAnimal(cats);
           forEachAnimal(dogs);
           //forEachAnimal(apples);
       }

       //提供一个方法来遍历元素类型是动物的集合
       //泛型的上限就是Animal
       //此时传入的参数就不能超过Animal，可以传入Animal及其子类对象
       //public static void forEachAnimal(List <<? extends Animal> extends Object> animals){
       public static void forEachAnimal(List<? extends Animal> animals){
           for(Animal animal : animals){
               System.out.println(animal);
           }
       }
   }

   class Animal{
   }
   class Cat extends Animal{

   }
   class Dog extends Animal{

   }
   class Apple{

   }
   #+END_SRC
8. ？super类/接口，表示传入这个类/接口及其父类/父接口对象，此时称之为泛型的下限
9. 上限和下限不能同时存在，即？extends XXX super XXX这种格式是不允许的
** Map<K,V>
1. Map - 映射：需要由2组元素构成，一组元素称之为键，另一组元素称之为值
2. 在Map中，每一个键必须对应一个值，把这种结构称之为键值对，即一个Map由多个键值对组成，键是唯一的
   #+BEGIN_SRC java
   package map;

   import java.util.HashMap;
   import java.util.Map;

   public class MapDemo1 {
       public static void main(String[] args) {

           Map<String,Integer> map = new HashMap<>();
           //添加元素
           map.put("Bob",15);
           map.put("Alex",17);
           map.put("Helen",14);
           map.put("Peter",16);
           map.put("Mark",15);
           //如果键重复,则对应的f值会被覆盖
           //map.put("Bob",19);

           /*
           Map<String,Integer> map2 = new HashMap<>();
           map2.put("Bob",15);
           map2.put("Alex",17);
           map2.put("Peter",16);
           map2.put("Helen",14);
           map2.put("Mark",15);
           //判断内容是否一样，不是判断顺序
           System.out.println(map.equals(map2));
           */

           //根据指定的键来获取值
           //如果键不存在，则返回一个null
           System.out.println(map.get("Lucy"));

           //判断映射是否为空
           System.out.println(map.isEmpty());

           //移除指定的键对应的键值对
           map.remove("Alex");

           //返回映射中元素个数
           System.out.println(map.size());



           //清空映射
           //map.clear();

           //判断是否包含指定的键
           //System.out.println(map.containsKey("Helen"));

           //判断是否包含指定的值
           System.out.println(map.containsValue(16));

           System.out.println(map);
       }
   }

   #+END_SRC
3. 遍历映射：
   - 方式一：可以先获取映射中所有的键，然后遍历键，根据键获取值
   - 方式二：在Map中，将键值对封装成Entry对象，即每一个键值对实际上就是一个Entry，可以考虑直接获取所有的Entry
   #+BEGIN_SRC java
   package map;

   import java.util.HashMap;
   import java.util.Map;
   import java.util.Set;

   public class MapDemo2 {
       public static void main(String[] args) {


           Map<String,Integer> map = new HashMap<>();
           map.put("Bob",15);
           map.put("Alex",17);
           map.put("Helen",14);
           map.put("Peter",16);
           map.put("Mark",15);

           /*
           //方式一：
           //先获取所有的键 - 将所有的键放入一个Set集合中
           Set<String> keys = map.keySet();
           for(String key : keys){
               System.out.println(key + "=" + map.get(key));
           }
           */

           //方式二：
           //可以考虑直接获取所有的键值对 - 将所有的键值对放入一个Set集合中
           //此时Set中存放的是键值对，所以泛型应该表示键值对，即泛型应该是Entry类型
           Set<Map.Entry<String,Integer>> entrys = map.entrySet();
           for(Map.Entry<String,Integer> entry : entrys){
               System.out.println(entry.getKey() + "=" + entry.getValue());
           }
       }
   }

   #+END_SRC
4. Map不是集合，但是Map是Java集合框架的成员 - Java Collections Framework（Java集合框架），包含了数组、集合、映射以及相关的工具类，例如：Collection及其子类，Map及其子类，Arrays，Collections，Iterator，Comparable，Comparator等
5. HashMap - 哈西映射：
   - 底层是基于数组 + 链表结构来存储数据。数组默认初始容量是16，数组的每一个位置都称之为是一个桶（bucket），每一个桶中维系一个链表
   - 默认加载因子是0.75，当已用桶数/总的桶数>0.75，会发生扩容。扩容默认是增加一倍的同属
   - HashMap本身是一个异步线程不安全的映射
     [[./Img/5.png]]
6. Hashtable:
   - Hashtable是Java中最早的映射之一
   - 底层是基于数组+链表结构来存储，默认初始容量是11，默认加载因子是0.75
   - Hashtable是一个同步线程安全的映射
   #+BEGIN_SRC java
   package cn.commandoptionesc.map;

   import java.util.HashMap;
   import java.util.Map;
   import java.util.Scanner;

   /**
   * 输入一个字符串，然后统计这个字符串哪种每一个字符出现的次数
   */
   public class MapExer {
       public static void main(String[] args) {

           //输入一个字符串
           Scanner s = new Scanner(System.in);
           String str = s.nextLine();

           Map<Character,Integer> map = new HashMap<>();
           //遍历这个字符串中的每一个字符，将每一个字符取出来进行次数计算
           for(int i = 0;i < str.length();i++){
               //获取指定下标位置上的字符
               char c = str.charAt(i);
               //先判断字符之前是否出现过
               if(map.containsKey(c)){
                   //如果出现过，那么需要在当前的次数上+1
                   map.put(c,map.get(c) + 1);
               }else{
                   map.put(c,1);
               }
           }

           //遍历映射，打印次数
           for(Map.Entry<Character,Integer> entry : map.entrySet()){
               System.out.println(entry.getKey() + ":" + entry.getValue());
           }
       }
   }

   #+END_SRC
* API(三)
** File
1. File是Java中提供的一套用于表示文件/目录(文件夹)的类
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;
   import java.io.IOException;

   public class FileDemo1 {
       public static void main(String[] args) throws IOException {

           //表示创建file对象指向Other文件下的ex.txt
           //如果这个文件不存在，那么执行完成之后也不会创建这个文件，但是也不报错
           //在底层只是将传入的字符串标记为一个文件
           //只要不去使用，那么久不会去检查这个文件是否存在

           /*
           //Win系统下 "ex.txt"文件路径写法
           //File file = new File("F:\\ex.txt");
           */

           //Mac系统下 "ex.txt"文件路径写法
           //File file = new File("/Users/admin/Documents/BigData/Another/Java/Other/ex.txt");
           //File file = new File("../Other/ex.txt");

           File file = new File("../Other/ex");

           //创建文件 - 在创建的时候要求制定的路径下没有同名文件
           //返回值表示文件是否创建成功；
           //这个方法只能创建文件不能创建目录
           //boolean b = file.createNewFile();

           //创建目录
           //只能创建目录不能创建文件
           //可以创建多层目录
           //boolean b  = file.mkdirs();

           //删除文件/目录
           //如果利用代码去删除文件，这个文件不是挪到回收站中，而是直接从家计算机删除
           //所以注意，这个操作是不可逆的
           //在删除目录的时候需要目录为空 - 即这个目录中不能有字文件或者字目录
           boolean b = file.delete();
           System.out.println(b);
           System.out.println("运行完成");
       }
   }

   #+END_SRC
2. 删除目录及其子目录和子文件 -> 获取这个目录下所有的子文件和子目录(listFiles)，如果是子文件可以直接删除，如果是子目录，那么得获取这个子目录中的子文件和子目录，后续功能和当前的功能是一致的 - 递归
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileDemo2 {
       public static void main(String[] args) {

           File file = new File("../Other");

           //获取other文件下所有的子文件和子目录
           File[] files = file.listFiles();
           for(File f : files){
               System.out.println(f);
           }

           //判断是否是一个文件
           System.out.println(file.isFile());
           //判断是否是一个目录
           System.out.println(file.isDirectory());
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileExer1 {
       public static void main(String[] args) {

           File file = new File("../Other/ex");
           deleteFile(file);
       }
       public static void deleteFile(File file){

           //判断传入的参数是否为空
           if(file == null){
               throw new NullPointerException("传入的参数不能为空！！！");
           }

           //判断是否是一个目录
           if(file.isDirectory()){
               //如果是目录，那么需要获取子目录和子文件
               File[] files = file.listFiles();
               //遍历这个数组，再来一个个的一次处理
               for(File f : files){
                   deleteFile(f);
               }
           }

           //无论是文件还是目录，都需要删除
           file.delete();
       }
   }

   #+END_SRC
3. File提供了大量的操作文件/目录的方法
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileDemo3 {
       public static void main(String[] args) {

           File file = new File("../Other/ex.txt");

           //判断这个文件/目录是否是一个可执行文件/目录
           //但是这个方法在windows中没有办法测试
           //可执行：打开、读取、写入、删除
           //boolean b = new file.canExecute();
           //System.out.println(b);

           //判断文件是否可写
           //boolean b = file.canWrite();
           //System.out.println(b);

           //判断文件或者目录是否存在

           //System.out.println(file.exists());

           /*
           //获取指定目录的可用空间，返回值是以字节来计数的，所以返回值类型是long
           File file1 = new File("../Other");
           System.out.println(file.getFreeSpace());
           */
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileDemo4 {
       public static void main(String[] args) {

           File file = new File("../Other/ex.txt");

           /*
           //这三个方法的特点，都不会去判断这个文件是否存在
           //separatorChar - 路径分隔符，实际上就是 '/'
           //获取文件名
           System.out.println(file.getName());
           //获取父目录
           System.out.println(file.getParent());
           //获取路径 - 在创建file的时候，传入什么路径，这儿获取的就是什么路径
           System.out.println(file.getPath());
           */

           //判断是否是一个隐藏文件
           //System.out.println(file.isHidden());

           //获取文件的大小
           //System.out.println(file.length());
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;
   import java.io.FileFilter;

   public class FileDemo5 {
       public static void main(String[] args) {
           File file = new File("../Other");

           //获取所有的子文件和子目录
           //File[] files = file.listFiles();
           //for(File f : files){
           //    System.out.println(f);
           //}

           //指向获取子文件
           File[] files = file.listFiles(new FileFilter() {
               @Override
               //在这个方法中指定规则，如果符合规则，那么就会将文件/目录放入数组files中
               public boolean accept(File pathname) {
                   return pathname.isFile();
               }
           });
           for(File f : files){
               System.out.println(f);
           }
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileDemo6 {
       public static void main(String[] args) {

           File file = new File(".//Other/ex.txt");

           //如果路径没有发生变化只是文件名改变，那么久执行重命名操作
           //如果文件名没有发生变化但是路径改变，那么久执行剪切操作
           //也可以路径和文件名同时变化
           file.renameTo(new File("../Other/ex1.txt"));
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.file;

   import java.io.File;

   public class FileDemo7 {
       public static void main(String[] args) {

           File file = new File("../Other/ex.txt");

           //将文件设置为只读模式
           //只读的特点：文件可以读取但是不能写入
           //file.setReadOnly();
           //设置不可写
           file.setWritable(false);
           //setReadOnly和setable在windows中的效果是等价的
       }
   }

   #+END_SRC
** IO
1. IO -> IO流 - Input/Output Stream - 输入输出流
   - 输入流：数据从外部流向程序。例如读取文件 - 将数据从文件读取到程序中
   - 输出流：数据从程序流向外部。例如向文件中写数据 - 将数据从程序写到文件中
2. IO是Java中提供的一套用于进行数据传输的机制
3. 流的分类
   - 按照传输方向：输入流和输出流
   - 按照传输形式：字节流和字符流

   |--------+-------------+--------------|
   |        | 输入流      | 输出流       |
   | 字符流 | Reader      | Writer       |
   | 字节流 | InputStream | OutputStream |
   |--------+-------------+--------------|
4. 数据的来源/目的地：自盘、内存、网络、输入设备
5. 向TXT文件中写入字符串 - 输出流、字符流、与文件相关的流 - FileWriter
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileWriter;
   import java.io.IOException;

   public class FileWriterDemo {
       public static void main(String[] args) throws IOException {

           //指定写入的文件
           //如果文件不存在，会创建一个新文件
           //如果文件存在，也会创建一个新文件将原来的文件覆盖掉
           //FileWriter writer = new FileWriter("../Other/io/ex.txt");

           //如果不想产生新文件将原来的文件覆盖，就需要在创建流对象的时候添加布尔值
           FileWriter writer = new FileWriter("../Other/io/ex.txt",true);

           //写数据
           //数据并不是直接写到文件中，而是先写到缓冲区中
           //等缓冲区满了，然后在将缓冲区中的数据放到文件中
           //现在缓冲区没有塞满，程序结束了，数据没有写到文件中，而是死在了缓冲区中
           writer.write("hello big data");

           //冲刷缓冲区
           writer.flush();

           //需要关流，释放文件
           //close之前，在底层会自动进行一次冲刷操作
           writer.close();

           System.out.println("运行完成");

       }
   }

   #+END_SRC
6. 流中的异常处理
   - 流对象需要放在try之外定义并且赋予null值，然后放到try之内进行初始化
   - 无论流写入数据成功与否，都需要灌流，所以close操作需要放到finally里面
   - 关流之前需要判断，判断流是否初始化成功，实际上就是判断流对象是否为空
   - 因为关流也存在失败的可能，所以需要最后将writer设置为null，那么无论如何这个writer都会被回收掉
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileWriter;
   import java.io.IOException;

   public class FileWriterDemo2 {
       public static void main(String[] args) {

           //需要将writer进行外置声明,并且赋予null值进行初始化
           FileWriter writer = null;
           try {
               //放到try之内进行初始化去创建这个流对象
               writer = new FileWriter("../Other/io/ex.txt");
               writer.write("hello");
           } catch (IOException e) {
               e.printStackTrace();
           } finally {
               //在关流之前需要判断流是否初始化成功，实际上就是判断流是否为空
               if(writer != null){

                   try {
                       //无论前面执行成功与否，这个流都需要进行关闭
                       //如果close失败，那么这个流会依然占用文件，其他流就无法使用
                       writer.close();
                   } catch(IOException e){
                       e.printStackTrace();
                   }finally{
                       //如果关流失败，那么久将writer的引用清空，这个writer就会被标记为垃圾对象
                       //强制回收，释放文件
                       //如果关流成功，也是将这个对象标记为垃圾对象
                       writer = null;
                   }
               }
           }
       }
   }

   #+END_SRC
7. JDK1.7中，提供了try-with-resource方法来处理流中的异常，但是要求try()中的对象对应的类必须实现Closable接口或者是Closable的子接口AutoClosable;如果在方法中接收到了一个流对象处理，那么需要在定义一个变量单独接收这个流.
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.File;
   import java.io.FileWriter;
   import java.io.IOException;

   public class FileWriterDemo3 {
       public static void main(String[] args) {

           //正因为传统的流中的异常处理方式比较麻烦，所以在JDK1.7中，提供了一种更简单的处理方法
           //try-with-resources
           //要求放到try()中的数据必须实现closable接口
           try(FileWriter writer = new FileWriter("../Other/io/ex.txt")){
               writer.write("abc");
               //这个close可写可不写，这种方式下，执行完成之后会自动关流
               writer.close();
           }catch(IOException e){
               e.printStackTrace();
           }
       }

       public void m(FileWriter writer){
           //try-with-resources这种方式要求被处理对象的声明过程必须放在try()之中
           try(FileWriter w = writer) {
               writer.write("abc");
           }catch(IOException e){
               e.printStackTrace();
           }
       }
   }

   #+END_SRC
8. FileReader：读取字符文件，结合FileWriter实现文件赋值的效果
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileNotFoundException;
   import java.io.FileReader;
   import java.io.IOException;

   public class FileReaderDemo {
       public static void main(String[] args) throws IOException {

           //创建一个输入流，指向要读取的文件
           FileReader reader = new FileReader("../Other/io/ex.txt");
           //读取数据
           //返回值表示的是读取的一个字节
           //int i = reader.read();
           //转化为字符打印出来
           //System.out.println((char)i);

           //需要将文件中所有的数据都读取出来
           //定义一个变量来记录每次读取的数据
           int i;
           //如果读取到了文件的末尾，会返回-1
           while((i = reader.read()) != -1){
               System.out.println((char)i);
           }

           //关流
           reader.close();
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileReader;
   import java.io.FileWriter;
   import java.io.IOException;

   //将ex.txt文件赋值一份方法哦另外一个文件夹
   public class CopyFileDemo {
       public static void main(String[] args) throws IOException {

           //创建输入流指向要读取的文件
           FileReader reader = new FileReader("../Other/io/ex.txt");
           //创建输出流指向要写出的文件
           FileWriter writer = new FileWriter("../Other/io1/ex.txt");
           //读取数据
           //定义变量用于记录每次读取的数据
           int i;
           //定义循环来读取数据
           while((i = reader.read()) != -1){
               //需要将读取到的数据来写出
               writer.write(i);
           }
           //关流
           reader.close();
           writer.close();
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileReader;
   import java.io.IOException;

   public class FileReaderDemo2 {
       public static void main(String[] args) throws IOException {

           //创建一个输入流指向要读取的文件
           FileReader reader = new FileReader("../Other/io/ex.txt");
           //准备缓冲区 - 输入流的缓冲区需要自己来定义
           //准备了一个字符数组作为缓冲区来使用
           char[] cs = new char[5];
           //将数据线写到cs数组中，等数组写满了，再一次行的向外打印
           //返回值表示的这次读取到的字符个数
           //定义一个变量来记录每次读取到的字符个数
           int len;
           //第一次读取，读取了hello这5个字符，将5赋值给len
           //第二次读取，读取了f这1个字符，将1赋值给len
           //第三次读取，没有读取到数据，那么说明读到了末尾，那么僵-1赋值给len
           while((len = reader.read(cs)) !=-1){
               System.out.println(new String(cs,0,len));
           }
           //关流
           reader.close();
       }
   }

   #+END_SRC
   #+BEGIN_SRC java
   package cn.commandoptionesc.io.file;

   import java.io.FileReader;
   import java.io.FileWriter;
   import java.io.IOException;

   public class CopyFileDemo2 {
       public static void main(String[] args) throws IOException {

           //创建一个输入流指向要读取的文件
           FileReader reader = new FileReader("../Other/io/ex.txt");
           //创建一个输出流指向要写入的文件
           FileWriter writer = new FileWriter("../Other/io1/ex1.txt");
           //准备一个字符数组作为缓冲区
           char[] cs = new char[10];
           //定义一个变量来记录每次读取到的字符个数
           int len;
           //读取数据
           while((len = reader.read(cs)) != -1){
               //将读取到的数据写出
               writer.write(cs,0,len);
           }
           //关流
           writer.close();
           reader.close();
       }
   }

   #+END_SRC
9. 缓冲流：
   - BufferedReader：提供了缓冲区，允许在读取数据的时候实现按行读取的效果 - 在实际过程中，一行实际上就是一个自然段
     #+BEGIN_SRC java
     package cn.commandoptionesc.io.buffer;

     import java.io.BufferedReader;
     import java.io.FileReader;
     import java.io.IOException;

     public class BufferedReaderDemo {
         public static void main(String[] args) throws IOException {

             //实际上是利用这个流去读取数据
             FileReader fr = new FileReader("../Other/io/ex.txt");
             //创建一个缓冲流 - 在构建缓冲流的时候需要传入一个其他的字符输入流
             //这个流失提供缓冲区的FileReader读取出数据之后，会利用这个BufferedReader
             BufferedReader reader = new BufferedReader(fr);
             //按行读取
             //String line = reader.readLine();
             //System.out.println(line);
             //定义变量来记录每一行数据
             String line;
             //如果读取到文件末尾，返回一个null
             while((line = reader.readLine()) != null){
                 System.out.println(line);
             }
             //关流
             //可以只关外层流 - 会顺带着将里层的流关掉
             reader.close();
         }
     }

     #+END_SRC
     #+BEGIN_SRC java
     package cn.commandoptionesc.io.buffer;

     import java.io.BufferedReader;
     import java.io.File;
     import java.io.FileReader;
     import java.io.IOException;

     //统计Java代码的行数
     //思路拆分：
     // 1. 先遍历，从目录中先找到所有的Java文件 ---
     // 2. 读取Java文件然后统计Java代码的行数
     public class BufferedReaderDemo2 {

         //记录行数
         private static int count = 0;

         /*
         //记录行数
         private static int lineCount = 0;
         //记录字数
         private static int letterCount = 0;
         */

         public static void main(String[] args) throws IOException {

             //创建File指向要读取的文件
             File file = new File(".");
             countLine(file);
             System.out.println("额外添加，验证是否正确");
             //System.out.println("Java代码总的行数:" + lineCount);
             //System.out.println("字符的个数：" + letterCount);
             System.out.println("Java代码总的行数：" + count);
         }

         private static void countLine(File file) throws IOException {

             //判断这个参数是否为空
             if(file == null)
                 throw new NullPointerException("路径不能为空!!!!");

             //判断是否目录还是文件
             if(file.isDirectory()){
                 //如果是目录，要获取这个目录下所有的子目录和子文件
                 File[] fs = file.listFiles();
                 //遍历数组，一次处理每一个子目录或者子文件
                 for(File f : fs){
                     countLine(f);
                 }
             }else if(file.getName().endsWith(".java")){
                 //在计算机中，file如果不是目录那么就是文件
                 //如果是文件要考虑是Java文件
                 //如果是Java文件，那么读取这个Java文件来统计行数
                 FileReader fr = new FileReader(file);
                 //创建缓冲流对象
                 BufferedReader br = new BufferedReader(fr);

                 //判断是否读取到了文件的末尾
                 /*
                 String line;
                 while((line = br.readLine()) != null){

                     //每读取一行，统计的行数就需要+1
                     lineCount++;
                     //记录字符个数
                     letterCount += line.length();
                 }
                 */
                 while(br.readLine() != null){
                     count++;
                 }
                 //关流
                 br.close();
             }
         }
     }

     #+END_SRC
   - BufferedWriter：本身比其他的字符输出流提供了更大的缓冲区
10. 文件的字节流
    - FileOutputStream：文件字节输出流，以字节的形式将数据写出到文件中 - 字节流没有缓冲区
    - FileInputStream：文件字节输入流，以字节的形式将数据从文件中读取出来
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.filestream;

    import java.io.FileOutputStream;
    import java.io.IOException;

    public class FileOutputStreamDemo {
        public static void main(String[] args) throws IOException {

            //创建一个文件字节输出流
            FileOutputStream out = new FileOutputStream("../Other");
            //写出数据
            //字节流没有缓冲区，会将数据直接写到文件中
            out.write("hello".getBytes());
            //关流
            out.close();
        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.filestream;

    import java.io.FileInputStream;
    import java.io.IOException;

    public class FileInputStreamDemo {
        public static void main(String[] args) throws IOException {

            //穿件文件字节输出流
            FileInputStream in = new FileInputStream("../Other/io/ex.txt");
            //创建一个字节数组作为缓冲区
            byte[] bs = new byte[10];
            //定义一个变量记录每次读取到的字节个数
            int len;
            //读取数据
            while((len = in.read(bs)) != -1){
                System.out.println(new String(bs,0,len));
            }
            //关流
            in.close();
        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.filestream;

    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.IOException;

    public class CopyFileDemo {
        public static void main(String[] args) throws IOException {

            //创建输入流指向要读取的源文件
            FileInputStream in = new FileInputStream("../Other/io/test.png");
            //创建输出流指向要写出的文件
            FileOutputStream out = new FileOutputStream("../Other/test.png");
            //创建一个字节数组作为缓冲区
            byte[] bs = new byte[10];
            //定义一个变量来记录每次读到的字节个数
            int len;
            //读取数据
            while((len = in.read(bs)) != -1){
                //将读取到的数据写出
                out.write(bs,0,len);
            }
            //关流
            in.close();
            out.close();
        }
    }

    #+END_SRC
11. 凡是字符流可以完成的操作，字节流都可以完成，只是传输的时候，字符流传输字符文件会比字节流要快一些
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.string;

    import java.io.IOException;
    import java.io.StringReader;

    public class CopyFileDemo {
        public static void main(String[] args) throws IOException {

            //这个字符串在运行的时候是存储在内存中
            String str = "hello big data";
            //创建一个流对象指向这个字符串
            StringReader reader = new StringReader(str);
            //定义变量来记录每次读取到的字符
            int i;
            while((i = reader.read()) != -1){
                System.out.println((char) i);
            }
            //关流
            reader.close();

        }
    }

    #+END_SRC
12. 字符串流 - 用于读写字符串
    - StringReader：从内存中将字符串读取出来
    - StringWriter：将字符串写到内存中
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.string;

    import java.io.IOException;
    import java.io.StringWriter;

    public class StringWriterDemo {
        public static void main(String[] args) throws IOException {

            //创建一个流
            //这个流底层实际上是使用了StringBuffer来拼接字符串
            StringWriter writer = new StringWriter();
            //写数据
            //将数据写到内存中
            writer.write("hello");
            writer.write("big data");
            //关流
            writer.close();
        }
    }

    #+END_SRC
13. 字节数组流 - 用于读写字节数组
    - ByteArrayOutputStream：产生字节数组，将这个字节数组放到内存中
      #+BEGIN_SRC java
      package cn.commandoptionesc.io.bytearray;

      import java.io.ByteArrayOutputStream;
      import java.io.IOException;

      class ByteArrayOutputStreamDemo {
          public static void main(String[] args) throws IOException {

              //创建一个字节数组输出流
              ByteArrayOutputStream out = new ByteArrayOutputStream();
              //写出数据
              //产生一个字节数组放到内存中
              out.write("hello".getBytes());
              //关流
              out.close();
              byte[] data = out.toByteArray();
              System.out.println(new String(data));
          }
      }

      #+END_SRC
    - ByteArrayInputStream：将字节数组从内存中读取出来
      #+BEGIN_SRC java
      package cn.commandoptionesc.io.bytearray;

      import java.io.ByteArrayInputStream;
      import java.io.IOException;

      public class ByteArrayInputStreamDemo {
          public static void main(String[] args) throws IOException {

              //准备字节数组
              byte[] data = "hello big data".getBytes();
              //创建一个字节数组输入流
              ByteArrayInputStream in = new ByteArrayInputStream(data);
              //读取数据
              byte[] bs = new byte[5];
              int len;
              while((len = in.read(bs)) != -1){
                  System.out.println(new String(bs,0,len));
              }
              //关流
              in.close();
          }
      }

      #+END_SRC
14. 转换流：字节流和字符流之间进行转换的桥梁，在这个过程中注意编码的转换问题
    - ByteputStreamWriter：将字符转化为字节，在底层将数据以字节形式来写出
      #+BEGIN_SRC java
      package cn.commandoptionesc.io.transform;

      import java.io.FileOutputStream;
      import java.io.IOException;
      import java.io.OutputStreamWriter;

      public class OutputStreamWriterDemo {
          public static void main(String[] args) throws IOException {

              //创建字节流
              FileOutputStream fout = new FileOutputStream("../Other/io/ex.txt");
              //创建转换输出流
              //实际底层依然是利用FileOutputStream来写出，但是对外提供确实以字符流形式来提供
              //在底层将字符转化为字节，然后以字节形式来写出
              //如果没有指定编码，那么数据和当前工程的编码一致
              OutputStreamWriter out = new OutputStreamWriter(fout);
              //OutputStreamWriter out = new OutputStreamWriter(fout,"gbk");
              //写出数据
              out.write("什么东西");
              //关流
              out.close();
          }
      }

      #+END_SRC
    - InputStreamReader：将字节转化为字符，在底层将数据已字节形式来读出来
      #+BEGIN_SRC java
      package cn.commandoptionesc.io.transform;

      import java.io.FileInputStream;
      import java.io.IOException;
      import java.io.InputStreamReader;

      public class InputStreamReaderDemo {
          public static void main(String[] args) throws IOException {

              //创建一个字节流
              FileInputStream fin = new FileInputStream("../Other/io/ex.txt");
              //创建转化输入流
              //在底层是使用FileenputStream来读取数据
              //读出来的数据是字节形式，但是却以字符形式来提供
              //转换输入流在底层实际上是将字节流转化为字符流
              InputStreamReader in = new InputStreamReader(fin);
              //InputStreamReader in = new InputStreamReader(fin,"gbk");

              //读取数据
              char[] cs = new char[10];
              int len;
              while((len = in.read(cs)) != -1){
                  System.out.println(new String(cs,0,len));
              }
              //关流
              in.close();
          }
      }

      #+END_SRC
15. 系统流：
    - 本质是System类中提供的静态常量，作用是从控制台来获取数据或者将数据打印到控制台上
    - 分类
      |------------+------------|
      | 分类       | 说明       |
      | System.in  | 标准输入流 |
      | System.out | 标准输出流 |
      | System.err | 标准错误流 |
      |------------+------------|
    - 系统流全部都是字节流
    - 系统流用完之后不需要关闭
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.system;

    import java.io.IOException;

    public class SystemDemo {
        public static void main(String[] args) throws IOException {

            //标准输入流
            //Scanner
            int i = System.in.read();
            //标准输出流和标准错误流在底层实现上一模一样
            //只有颜色不一样
            //实际过程中，正常结果用标准输入流来打印
            //错误结果或者异常信息一般使用的是标准错误流
            //标准输出流
            System.out.println(i);
            //标准错误流
            System.out.println(i);

        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.system;

    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;

    public class GetLineDemo {
        public static void main(String[] args) throws IOException {

            //从控制台来获取一行数据
            //从控制台读取数据 --- System.in
            //读取一行数据 --- BufferedReader
            //BufferedReader在构建的时候需要传入一个字符流，但是System.in是字节流
            //将字节流转化为字符流 - InputStreamReader
            InputStreamReader in = new InputStreamReader((System.in));
            BufferedReader reader = new BufferedReader(in);
            //读取一行数据
            String line = reader.readLine();
            System.out.println(line);
            //系统流用完之后不需要关闭
        }
    }

    #+END_SRC
16. 打印流 - PrintStream/PrintWriter：
    - 是Java提供的一套能够进行辩解打印的机制，并且提供了辩解的换行方式
    - 标准输出流/标准错误流本质上都是打印流
    - 打印流只有输出流
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.print;

    import java.io.FileNotFoundException;
    import java.io.PrintStream;

    public class PrintStreamDemo {
        public static void main(String[] args) throws FileNotFoundException {

            //创建打印流
            PrintStream ps = new PrintStream("../Other/io/ex.txt");
            //写出数据
            //写出一行数据并且换行
            ps.print("hello");
            ps.print("big data");
            //关流
            ps.close();
        }
    }

    #+END_SRC
17. 合并流 - SequenceInputStream：
    - 只有输入流没有输出
    - 合并多个字节流，将这多个字节流中的数据合并到一块，实际过程中作用往往是将多个文件合并成一个文件。在创建合并流的时候，需要获取一个Enumeration对象，所以往往是利用Vector先来存储多个字节流，然后在利用这个Vector生成一个Enumeration对象，最后再构建合并流
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.other;

    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.IOException;

    public class UnionFileDemo {
        public static void main(String[] args) throws IOException {

            copy("../Other/io/a.txt","../Other/io/union.txt");
            copy("../Other/io/b.txt","../Other/io/union.txt");
            copy("../Other/io/c.txt","../Other/io/union.txt");
            copy("../Other/io/d.txt","../Other/io/union.txt");
        }

        public static void copy(String inpath,String outpath) throws IOException{

            //创建一个输入流来指向输入路径
            FileInputStream in = new FileInputStream(inpath);
            //创建一个输出流来指向输出路径
            FileOutputStream out = new FileOutputStream(outpath,true);
            //读取数据
            byte[] data = new byte[10];
            int len;
            while((len = in.read(data)) != -1){
                //将读取到的数据写出
                out.write(data,0,len);
            }
            //关流
            in.close();
            out.close();
        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.other;

    import java.io.*;
    import java.util.Enumeration;
    import java.util.Vector;

    public class SequenceInputStreamDemo {
        public static void main(String[] args) throws IOException {

            //创建字节流指向要读取的文件
            FileInputStream in1 = new FileInputStream("../Other/io/a.txt");
            FileInputStream in2 = new FileInputStream("../Other/io/b.txt");
            FileInputStream in3 = new FileInputStream("../Other/io/c.txt");
            FileInputStream in4 = new FileInputStream("../Other/io/d.txt");

            //创建一个Vector对象存储FileInputStream
            //Vector是一个集合
            Vector<InputStream> v = new Vector<>();
            v.add(in1);
            v.add(in1);
            v.add(in1);
            //利用合格集合产生一个迭代器
            //Enumeration是最古老的迭代器，出现在Iterator之前
            Enumeration<InputStream> e = v.elements();
            //创建合并流
            SequenceInputStream sis = new SequenceInputStream(e);
            //创建输出流
            FileOutputStream out = new FileOutputStream("../Other/io/union.txt");
            //读取数据
            byte[] data = new byte[10];
            int len;
            while((len = sis.read(data)) != -1){
                //将读取到的数据写出
                out.write(data,0,len);
            }
            //关流
            out.close();
            sis.close();
        }
    }

    #+END_SRC
18. 序列化/反序列化流：
    - 序列化：将数据按照指定格式进行转化
    - 反序列化：将数据按照指定格式转化回来
    - 注意问题：
      + 如果一个对象想要被序列化，那么这个对象对应的类必须实现Serializable。这个借口中没有任何的方法和属性，仅仅是用于标记当前类的对象可以被序列化
      + 被static、transien修饰的属性不会被序列化出去
      + 当一个类实现Serializable借口之后，这个类中如果没有指定SerialVersionUID（版本号），那么在运行的时候会根据类中的属性和方法自动计算一个版本号。如果类中的属性或者方法改变，那么就会自动重新计算一个新的版本号。在序列化的时候，版本号会随着对象一起呗序列化出去。在反序列化的时候，会先校验版本号是否一致，如果一致才能反序列化
      + 实际过程中，序列化和反序列化会被大量的应用，只要涉及到数据的传输和存储的问题，都会考虑序列化
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.serial;

    import java.io.Serializable;

    public class Student implements Serializable {
        private String name;
        private int age;
        //static String classroom;
        //transient修饰的属性是强制不被序列化
        private transient double height;
        private String gender;
        private static final long serialVersionUID = 234255L;
        private String no;

        public String getNo() {
            return no;
        }

        public void setNo(String no) {
            this.no = no;
        }

        public String getGender() {
            return gender;
        }

        public void setGender(String gender) {
            this.gender = gender;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public double getHeight() {
            return height;
        }

        public void setHeight(double height) {
            this.height = height;
        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.serial;

    import java.io.FileOutputStream;
    import java.io.IOException;
    import java.io.ObjectOutputStream;

    public class ObjectOutputStreamDemo {
        public static void main(String[] args) throws IOException {

            //准备一个Student对象
            Student s = new Student();
            s.setName("Alex");
            s.setAge(15);
            //s.classroom = "302";
            s.setHeight(144.8);

            //创建一个序列化流
            //表示序列化产生的数据写到"../Other/io/ex.txt中
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("../Other/io/ex.txt"));
            //序列化对象
            out.writeObject(s);
            //关流
            out.close();
        }
    }

    #+END_SRC
    #+BEGIN_SRC java
    package cn.commandoptionesc.io.serial;

    import java.io.FileInputStream;
    import java.io.IOException;
    import java.io.ObjectInputStream;

    public class ObjectInputStreamDemo{
        public static void main(String[] args) throws IOException,ClassNotFoundException {

            //创建反序列化对象
            ObjectInputStream in = new ObjectInputStream(new FileInputStream("../Other/io/ex.txt"));
            //反序列化对象
            Student s = (Student) in.readObject();
            //关流
            in.close();
            System.out.println(s.getName());
            System.out.println(s.getAge());
        }
    }


    #+END_SRC
19. 其他：
    1. RandomAccessFile:用于操作文件的类，在操作文件的时候，将文件看做是一个大型的字节数组，可以根据下标操作文件中指定的位置

       #+BEGIN_SRC java
         package cn.commandoptionesc.other;

         import java.io.IOException;
         import java.io.RandomAccessFile;

         public class RandomAccessFileDemo {
             public static void main(String[] args) throws IOException {

                 //“r”以只读模式打开文件，对文件进行任何的写操作都是不被允许的
                 //"rw"以读写模式打开文件，允许对文件进行读写
                 //"rwd"/"rws"以读写模式打开文件，并且要求每次对数据更新都需要同步更新到底层的存储设备上
                 //如果数据比较重要不允许丢失，那么可以考虑使用rwd/rws，但是同时意味着这种模式会比较慢
                 RandomAccessFile raf = new RandomAccessFile("../Other/io/ex.txt","rw");

                 //挪动下标
                 raf.seek(10);
                 //在读写数据的时候将文件看做是一个大型的字节数组来操作的
                 raf.write("abcdef".getBytes());
                 System.out.println(raf.read());
                 //关流
                 raf.close();
             }
         }
       #+END_SRC
    2. Properties：
       1. Properties是一个可持久化（持久化是一种特殊的序列化，将数据序列化到磁盘上就称之为持久化）的映射，继承了Hashtable
       2. Properties中的键和值默认是String
       3. Properties要求文件的后缀必须是.properties
       #+BEGIN_SRC java
       package cn.commandoptionesc.other;

       import java.io.FileOutputStream;
       import java.io.IOException;
       import java.util.Properties;

       public class PropertiesDemo {
           public static void main(String[] args) throws IOException {
               Properties prop = new Properties();
               //添加元素
               prop.setProperty("name","Helen");
               prop.setProperty("gender","female");
               //序列化
               //Properties提供了store方法来直接序列号华
               FileOutputStream out = new FileOutputStream("../Other/io/ex.txt");
               //第二个参数实际上是在文件中添加注释
               prop.store(out,null);
           }
       }
       #+END_SRC
       #+BEGIN_SRC java
       package cn.commandoptionesc.other;

       import java.io.FileInputStream;
       import java.io.IOException;
       import java.util.Properties;

       public class PropertiesDemo2 {
           public static void main(String[] args) throws IOException {
               Properties prop = new Properties();
               //反序列化
               FileInputStream in = new FileInputStream("../Other/io/ex.txt");
               prop.load(in);
               in.close();

               //System.out.println(prop.getProperty("name"));
               //遍历Properties
               prop.list(System.out);
           }
       }
       #+END_SRC
** 线程
1. 进程和线程
   - 进程是计算机在执行的任务
   - 线程是轻量化的进程。线程可以认为是进程的子任务。如果进程中只有一个任务，那么这个进程就可以看做是线程了。一个进程中至少包含一个线程，可以包含多个线程 - 线程实际上也是计算机在执行的任务
2. 多线程：计算机执行多个任务
3. 定义线程
   - 继承Thread类，然后覆盖run方法，将线程要执行的逻辑写到方法中，然后调用start方法来启动线程
     #+BEGIN_SRC java
       package cn.commandoptionesc.thread;

       public class ThreadDemo {
           public static void main(String[] args) {

               //创建线程对象
               TDemo t = new TDemo();
               //启动线程，启动之后自动调用run方法来执行逻辑
               t.start();

               for(int i = 0;i < 5;i++){
                   System.out.println("main");
               }
           }
       }

       //继承Thread
       class TDemo extends Thread{

           //线程的执行逻辑卸载这个方法中
           @Override
           public void run() {
               for(int i = 0;i < 10;i++){
                   System.out.println("TDemo");
               }
           }
       }
     #+END_SRC
   - 实现Runnable接口，然后覆盖run方法，在启动之前需要将Runnable对象传递到Thread中，然后利用Thread调用start方法来启动执行 - 现阶段要求掌握
     #+BEGIN_SRC java
       package cn.commandoptionesc.thread;

       public class RunnableDemo {
           public static void main(String[] args) {

               RDemo r = new RDemo();
               //将Runnable对象构建成Thread对象启动
               Thread t = new Thread(r);
               t.start();
           }
       }

       //实现Runnable
       class RDemo implements Runnable{
           @Override
           public void run() {
               for(int i = 0;i < 5;i++){
                   System.out.println("RDemo");
               }
           }
       }
     #+END_SRC
   - 实现Callable接口，覆盖call方法，需要利用执行器服务来启动 - 先阶段仅做了接，后续课程中会讲解
     #+BEGIN_SRC java
       package cn.commandoptionesc.thread;

       import java.util.concurrent.*;

       public class CallableDemo {
           public static void main(String[] args) throws ExecutionException,InterruptedException {

               ExecutorService es = Executors.newCachedThreadPool();
               Future<String> f = es.submit(new CDemo());
               System.out.println(f.get());
               es.shutdown();
           }
       }

       class CDemo implements Callable<String> {
           @Override
           public String call() throws Exception {
               return "Success";
           }
       }
     #+END_SRC
4. 多线程的并发安全问题：多个线程同时执行的时候，这多个线程之间是相互抢占执行，并且抢占会发生在线程执行的每一个步骤中。由于线程之间的抢占导致出现不合理的数据的现象称之为多线程的并发安全
   [[./Img/6.png]]
5. 并发：多个线程同时执行，这种方式称之为并发
6. synchronized：利用一个锁将一段代码锁起来，一个线程使用期间不允许其他线程使用 - 需要确定一个锁对象，锁对象要求能被所有的线程都认识：共享资源、方法区中的资源（类的字节码、字符串等）、this
7. 被synchronized括起来的这段代码称之为同步代码块
8. 同步和异步
   - 同步：如果一段代码在一个时间段内只能被一个线程使用
   - 异步：如果一段代码在一个时间段内能够被多个线程抢占使用
9. 线程安全和线程不安全
   - 线程安全：多个线程同时执行的时候，结果是正常的
   - 线程不安全：多个线程同时执行的说会后，结果不符合常理
   #+BEGIN_SRC java
     package cn.commandoptionesc.thread;

     //总票数为100，四个人共卖100张票
     public class SellTicketDemo1 {
         public static void main(String[] args) {

             Ticket t = new Ticket();
             t.setCount(100);
             new Thread(new Seller(t),"A").start();
             new Thread(new Seller(t),"B").start();
             new Thread(new Seller(t),"C").start();
             new Thread(new Seller(t),"D").start();
         }
     }

     class Seller implements Runnable{

         private Ticket t;
         public Seller(Ticket t) {
             this.t = t;
         }

         @Override
         public  void run(){
             while(true){
                 //synchronized(t) {
                 synchronized(Seller.class) {
                     if (t.getCount() <= 0)
                         break;
                     try {
                         //参数表示沉睡时间，单位是毫秒
                         //sleep不影响执行结果，只是将执行时间拉长
                         Thread.sleep(5);
                     } catch (InterruptedException e) {
                         e.printStackTrace();
                     }
                     //卖了一张票
                     t.setCount(t.getCount() - 1);
                     //获取线程名字
                     String name = Thread.currentThread().getName();
                     System.out.println(name + "卖出了一张票，剩余" + t.getCount());
                 }
             }
         }
     }

     class Ticket{

         private int count;

         public int getCount() {
             return count;
         }

         public void setCount(int count) {
             this.count = count;
         }
     }
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.thread;

     public class SellTicketDemo2 {
         public static void main(String[] args) {
             Ticket t = new Ticket();
             t.setCount(100);
             SellSystem ss = new SellSystem(t);
             //用四个线程表示售票员
             //这4个售票员应该使用的是同一个售票系统
             new Thread(ss,"A").start();
             new Thread(ss,"B").start();
             new Thread(ss,"C").start();
             new Thread(ss,"D").start();
         }
     }

     //售票系统
     class SellSystem implements Runnable{

         private Ticket t;
         public SellSystem(Ticket t){
             this.t = t;
         }

         @Override
         public void run() {
             while(true){
                 synchronized (this){
                     if(t.getCount() <= 0) {
                         break;
                     }
                     t.setCount(t.getCount() - 1);
                     System.out.println(Thread.currentThread().getName() + "卖了一张票，剩余" + t.getCount());
                 }
             }
         }
     }
   #+END_SRC

10. 死锁：锁之间相互嵌套导致代码无法继续向下执行。死锁形成条件：锁形成嵌套，现成之间还需要相互的锁。死锁不是逻辑错误或者代码错误，所以思索一旦出现无法处理。实际过程中，一般会尽量避免死锁，那么这个时候就会根据业务要求检测死锁，如果产生死锁，会考虑打破一个锁来释放其他的锁。
    #+BEGIN_SRC java
      package cn.commandoptionesc.thread;

      public class Demo {
          private static Printer p = new Printer();
          private static Scanner s = new Scanner();

          public static void main(String[] args) {
              //第一个员工
              new Thread(new Runnable(){
                  @Override
                  public void run() {
                      try {
                          synchronized (p) {
                              p.print();
                              Thread.sleep(100);
                              synchronized (s){
                                  s.scan();
                              }
                          }
                      }catch(InterruptedException e){
                          e.printStackTrace();
                      }
                  }
              }).start();
              //第二个员工
              new Thread(new Runnable(){
                  @Override
                  public void run() {
                      try{
                          synchronized (s){
                              s.scan();
                              Thread.sleep(100);
                              synchronized (p){
                                  p.print();
                              }
                          }

                      }catch(Exception e){
                          e.printStackTrace();
                      }
                  }
              }).start();

          }
      }

      //打印机
      class Printer{
          public void print(){
              System.out.println("这台打印机在哼哧哼哧的打印~~~");
          }
      }

      class Scanner{
          public void scan(){
              System.out.println("这部扫描仪在吱呦吱呦的扫描~~~");
          }
      }

    #+END_SRC

11. 虽然锁可以有效的避免多线程并发产生的安全问题，但是实际过程中尽量减少使用锁机制。锁机制如果滥用会导致死锁的产生，会导致程序执行效率的降低。如果实在需要使用锁，那么只有将有危险的片段锁起来就可以，不需要将整个类或者整个方法锁起来
12. 等待唤醒机制：wait/notify/notifyAll通过现成等待让线程不再执行而是让其他线程执行，通过这种方法调节了线程之间的执行顺序。注意，在notify的时候，是随机唤醒一个线程。
    #+BEGIN_SRC java
      package cn.commandoptionesc.thread;

      //生产消费模型
      //生产者 消费者 商品
      public class WaitNotifyDemo {
          public static void main(String[] args) {
              Product p = new Product();
              new Thread((new Producer(p))).start();
              new Thread((new Consumer(p))).start();
          }
      }

      //商品
      class Product{
          private int count;
          //标记位
          //规定：true就让生产者生产，如果为false让消费者消费
          boolean flag = true;

          public int getCount(){
              return count;
          }
          public void setCount(int count){
              this.count = count;
          }
      }

      //生产者
      class Producer implements Runnable{

          private Product p;
          public Producer(Product p){
              this.p = p;
          }

          @Override
          public void run() {
              while(true){
                  synchronized (p){
                      try {
                          //生产者生产了一次，如果再次抢到执行权不能执行，而是需要放开执行权等待
                          if(p.flag == false)
                              p.wait();
                          //模拟生产的商品数量
                          //表示每一次商品的数量都不相等
                          int count = (int) (Math.random() * 1000);
                          p.setCount(count);
                          System.out.println("生产者生产了：" + count);
                          p.flag = false;
                          p.notify();
                      }catch (InterruptedException e){
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
      //消费者
      class Consumer implements Runnable{
          private Product p;
          public Consumer(Product p){
              this.p = p;
          }

          @Override
          public void run() {
              while(true){
                  synchronized (p){
                      try{
                          //消费者消费完成之后，需要让生产者生产
                          if(p.flag == true)
                              p.wait();
                          System.out.println("消费者消费了：" + p.getCount());
                          p.setCount(0);
                          //唤醒在等待的线程
                          p.flag = true;
                          p.notify();
                      }catch(InterruptedException e){
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
    #+END_SRC
13. wait和sleep区别
    - sleep：在使用的时候需要指定睡眠时间，到了指定时间之后会自动醒过来；如果没有锁，那么线程在沉睡期间释放执行权；如果有锁，那么线程在沉睡期间不会释放执行权。sleep是被设计在Thread类上，本身还是一个静态方法。
    - wait：在使用的时候可以指定等待时间也可以不指定，如果不指定等待时间那么需要唤醒。wait必须结合锁来使用，线程在wait期间会释放执行权。wait是设计在了Object类上。
14. 线程的状态
      [[./Img/7.png]]
    - 线程在运行之前一定是先就绪
    - 运行状态有可能转化为阻塞或者就绪状态
    - wait、sleep等方法是将线程转化为阻塞状态
15. 线程创建的场景：
    - 用户主动创建 - 打开微信，实际上就是主动申请创建微信运行的这个线程
    - 系统自动启动 - 例如开机的时候，操作系统中会自己来运行一些系统的线程
    - 关联启动
16. 线程销毁的场景：
    - 线程自然结束 - “寿终正寝”
    - 被其他线程给强制关闭 - “他杀”
    - 线程在执行过程中出现意外而结束 - “意外死亡”
17. 线程的优先性
    - 在线程中，有优先级的区分，优先级用数字1 - 10表示
    - 数字越大优先级越高，理论上能抢占到资源的概率就会越大，但是注意在实际生产过程中，优先级的差别并不明显。至少要差到5个优先级以上，区别才能稍微明显一点点
    - 如果没有设置优先级，那么线程的优先级默认为5
18. 守护线程
    - 守护线程用于守护其他线程的，当被守护的线程结束，那么守护线程无论执行完成与否，都会随之结束
    - 一个线程要么是守护线程要么是非守护线程
    - 如果存在多个线程，那么只要这个线程不是守护线程，那么这个线程就是被守护。例如一共有10个线程，其中有7个守护线程，其他3个就是被守护的线程。如果存在多个被守护线程，那么守护线程要以最后一个被守护的线程的结束作为结束信号。
#+BEGIN_SRC java
  package cn.commandoptionesc;

  public class PriorityDemo {
      public static void main(String[] args) {

          Thread t1 = new Thread(new PDemo(),"A");
          Thread t2 = new Thread(new PDemo(),"B");

          t1.setPriority(4);
          t2.setPriority(5);

          t1.start();
          t2.start();
      }
  }

  class PDemo implements Runnable{
      @Override
      public void run() {

          //获取线程的名字
          String name = Thread.currentThread().getName();
          for(int i = 0;i < 9;i++){
              System.out.println(name + ":" + i);
          }
      }
  }

#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc;

  public class DaemonDemo {
      public static void main(String[] args) throws InterruptedException {
          Thread t1 = new Thread(new Monster(),"A");
          Thread t2 = new Thread(new Monster(),"B");
          Thread t3 = new Thread(new Monster(),"C");
          Thread t4 = new Thread(new Monster(),"D");

          //设置守护线程
          t1.setDaemon(true);
          t2.setDaemon(true);
          t3.setDaemon(true);
          t4.setDaemon(true);

          t1.start();
          t2.start();
          t3.start();
          t4.start();

          for(int i = 10; i > 0;i--){
              System.out.println("Boss掉了一滴血，剩余" + i);
              Thread.sleep(500);
          }
      }
  }

  class Monster implements Runnable{
      @Override
      public void run() {
          String name = Thread.currentThread().getName();
          for(int i = 1000;i > 0;i--){
              System.out.println(name + "掉了一地血，剩余" + i);
              try{
                  Thread.sleep(50);
              }catch(InterruptedException e){
                  e.printStackTrace();
              }
          }
      }
  }
#+END_SRC
** 网络编程
1. 网络编程实际上是一套基于网络进行数据传输的流
2. 网络模型：物理层、数据链条层、网络层、传输层、会话层、表示层、应用层
3. 在这七层中，提供了不同的传输协议，例如：http、FTP、POP3等这些协议都属于后三层的协议，UDP、TCP等协议都是传输层的协议，而Java中的网络编程也是要考虑传输层的协议
4. IP地址：在网络中用于标记主机的，在传输数据的时候需要制定IP。IP协议存在IPv4和IPv6.目前国内最常使用的是IPv4，现在国内也开始推行IPv6.IPv4是用了4组数字表示一个IP地址，例如10.35.62.189。这四组数字中的每一组数字的范围U能超过255，也就意味着IPv4的地址范围是0.0.0.0~255.255.255.255，但是这个范围的一部分IP是有特殊含义的
5. 端口：是主机和外界进行信息交互的媒介 - 如果一台电脑需要和外界进行信息的交互，那么必须通过端口来进行交互。一台主机包含了好多的端口，对端口进行编号，编号的范围是0~65535.在信息交互的时候，需要制定端口的。但是注意，实际开发中，0~1024这个范围的大部分端口被计算机内部占用，往往是从1025号端口开始使用
6. 域名：为了方便人们记忆网站地址，设计了这么一串字符串。这串字符串在网络底层要映射为IP。例如：www.baidu.com - 在实际使用过程中，域名是分级的。一级域名往往是标记域名的类型，例如com表示商业类型，org表示的机构或者组织，edu表示的教育类型；二级域名往往是公司的商标或者品牌，例如baidu.com表示百度，164.com表示网易等；三级域名往往是应用类型，例如news.baidu.com表示百度新闻，163.com表示的网易邮箱。在实际使用过程中，域名一般不超过三级。
7. DNS解析服务器：就是将域名和IP进行映射。在万维网上存在一个最大的DNS服务器。当在浏览器地址栏指定域名之后，在底层，DNS服务器就会将这个域名解析为IP，然后才会去访问对应的IP地址。如果当前DNS服务器无法解析这个域名，向高一层的DNS服务器来请求解析域名
8. localhost或者127.0.0.1表示本机，255.255.255.255表示的是一个广播地址（只要在这个局域网范围内的主机都会接收到这个数据）
9. InetSocketAddress：是Java提供一个用于表示IP和端口和类
   #+BEGIN_SRC java
     package cn.commandoptionesc.net;

     import java.net.InetSocketAddress;

     public class InetSocketAffressDemo {
         public static void main(String[] args) {

             //表示创建了InetSocketAddress，指向了www.baidu.com这个地址
             InetSocketAddress isa = new InetSocketAddress("www.baidu.com",8090);
             //获取端口号
             System.out.println(isa.getPort());
             //获取主机名 - 在网络中，主机名往往是域名；如果是单台主机名，主机名指的就是计算机名
             System.out.println(isa.getHostName());
         }
     }

   #+END_SRC
10. UDP：
    - 特点：
      + 基于网络进行数据传输的流
      + 无连接的流，不可靠（无论有没有接收，都会发送出去，所以可能会产生数据丢失）但是传输速度快
      + 适用于对传输速度依赖性较高但是对可靠性依赖相对低一些的场景，例如直播、视频聊天、语音电话等
    - 发送端：
      + 创建UDP发送端对象
      + 将数据封包，并且还需要制定接收地址和端口号
      + 发送数据包
      + 关流
        #+BEGIN_SRC java
          package cn.commandoptionesc.udp;

          import java.io.IOException;
          import java.net.DatagramPacket;
          import java.net.DatagramSocket;
          import java.net.InetSocketAddress;

          //发送端
          public class Sender {
              public static void main(String[] args) throws IOException {
                 //创建发送端对象
                 DatagramSocket ds = new DatagramSocket();
                 //对数据进行封包
                  //第一个参数表示数据
                  //第二个参数表示是数据的大小
                  //第三个参数表示的接收的地址和端口号
                  byte[] data = "hello receiver".getBytes();
                  DatagramPacket dp = new DatagramPacket(
                    data,data.length,new InetSocketAddress("localhost",8090)
                  );
                  //发送数据
                  ds.send(dp);
                  //关流
                  ds.close();
              }
          }

        #+END_SRC
    - 接收端：
      + 创建UDP接收端对象，绑定监听的端口号
      + 准备数据包
      + 接收数据
      + 解析数据
        #+BEGIN_SRC java
          package cn.commandoptionesc.udp;

          import java.io.IOException;
          import java.net.DatagramPacket;
          import java.net.DatagramSocket;

          //接收端
          public class Receiver {
              public static void main(String[] args) throws IOException {

                  //创建接收端对象，绑定监听的端口
                  DatagramSocket ds = new DatagramSocket(8090);
                  //准备数据包接收数据
                  DatagramPacket dp = new DatagramPacket(new byte[1024],1024);
                  //接收数据
                  ds.receive(dp);
                  //关流
                  ds.close();
                  //解析数据
                  byte[] data = dp.getData();
                  //获取数据的实际长度
                  int len = dp.getLength();
                  System.out.println(new String(data,0,len));
              }
          }

        #+END_SRC
    - 案例：担任聊天室
      #+BEGIN_SRC java
        package cn.commandoptionesc.udp;

        import java.io.IOException;
        import java.net.DatagramPacket;
        import java.net.DatagramSocket;
        import java.net.InetSocketAddress;
        import java.util.Scanner;

        public class ChatDemo {
            public static void main(String[] args) {
                new Thread(new MessageSender()).start();
                new Thread(new MessageReceiver()).start();
            }
        }

        //消息发送端
        class MessageSender implements Runnable{
            @Override
            public void run() {

                try {
                    //创建发送端对象
                    DatagramSocket ds = new DatagramSocket();
                    //创建Scanner对象
                    Scanner s = new Scanner(System.in);
                    while(true){
                        //从控制台来接收数据
                        String message = s.nextLine();
                        //就需要将接收到的数据进行封包
                        DatagramPacket dp = new DatagramPacket(
                                message.getBytes(),message.getBytes().length,
                                new InetSocketAddress("localhost",8070)
                        );
                        //发送数据
                        ds.send(dp);
                        //如果输入的数据是over~，表示结束聊天
                        if(message.equals("over~"))
                            break;
                    }
                    //关流
                    ds.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        //消息接收端
        class MessageReceiver implements Runnable {
            @Override
            public void run() {
                try {
                    //创建接收端对象，绑定监听的端口号
                    DatagramSocket ds = new DatagramSocket(8070);
                    //准备数据包
                    DatagramPacket dp = new DatagramPacket(new byte[1024], 1024);
                    while (true) {
                        //接收数据
                        ds.receive(dp);
                        //解析数据
                        //获取底层的字节数组
                        byte[] data = dp.getData();
                        //获取数据长度
                        int length = dp.getLength();
                        String message = new String(data, 0, length);
                        //如果收到对方的over~表示对方结束了聊天
                        if(message.equals("over~")){
                            System.out.println("对方结束了聊天");
                            break;
                        }
                        System.out.println(message);
                    }
                    //关流
                    ds.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
      #+END_SRC
11. TCP：
    - 特点：
      + 基于网络进行数据传输的流
      + 有链接，经理三次握手（三次确认），可靠（一定是在建立连接之后才会发送数据，三次确认过程中只要任何一次失败都不会发送数据，所以不会产生数据的丢失），传输速比较慢
        [[./Img/8.png]]
      + 适用于对可靠性依赖比较高但是对传输速度依赖相对低一些的场景，例如文件上传下载
    - 在现在的开发中，往往是TCP和UDP混用：在网络条件好的情况下，尽量选用TCP；如果网络条件产生变化，切换为UDP
    - 客户端：
      + 创建客户端套接字对象 - Socket
      + 发送链接，绑定链接地址和端口号
      + 获取输出流，写出数据
      + 通知服务器端数据已经写完
      + 关流
        #+BEGIN_SRC java
          package cn.commandoptionesc.tcp;

          import java.io.IOException;
          import java.io.OutputStream;
          import java.net.InetSocketAddress;
          import java.net.Socket;

          public class Client {
              public static void main(String[] args) throws IOException {

                  //创建客户端套接子对象
                  Socket s = new Socket();
                  //发起连接，绑定连接地址和端口号
                  s.connect(new InetSocketAddress("localhost",8090));
                  //连接之后，获取自带输出流
                  OutputStream out = s.getOutputStream();
                  //写出数据
                  out.write("hello server".getBytes());
                  //通知服务器端，数据已经写出完毕
                  //输出流一旦关闭不能启动
                  s.shutdownOutput();
                  //关流
                  s.close();
              }
          }

        #+END_SRC
    - 服务器端
      + 创建服务器端套接字对象 - ServerSocket
      + 绑定监听的端口号
      + 接收连接
      + 获取输入流，读取数据
      + 通知客户端数据已经读完
      + 关流
        #+BEGIN_SRC java
          package cn.commandoptionesc.tcp;

          import java.io.IOException;
          import java.io.InputStream;
          import java.net.InetSocketAddress;
          import java.net.ServerSocket;
          import java.net.Socket;

          public class Server {
              public static void main(String[] args) throws IOException {

                  //创建服务器端套接字对象
                  ServerSocket ss = new ServerSocket();
                  //绑定监听的端口号
                  ss.bind(new InetSocketAddress(8090));
                  //接收连接
                  Socket s = ss.accept();
                  //获取输入流
                  InputStream in = s.getInputStream();
                  //读取数据
                  byte[] data = new byte[1024];
                  int len;
                  while((len = in.read(data)) != -1){
                      System.out.println(new String(data,0,len));
                  }
                  //读取完成之后，需要通知客户端数据一定读完
                  //输入流一旦关闭不能开启
                  s.shutdownInput();
                  //关流
                  ss.close();
              }
          }

        #+END_SRC
    - 案例：文件上传
      #+BEGIN_SRC java
        package cn.commandoptionesc.tcp;

        import java.io.FileInputStream;
        import java.io.IOException;
        import java.io.OutputStream;
        import java.net.InetSocketAddress;
        import java.net.Socket;

        //文件上传客户端
        public class FileUploadClient {
            public static void main(String[] args) throws IOException {

                //创建客户端的套接字对象
                Socket s = new Socket();
                //发起连接
                s.connect(new InetSocketAddress("localhost",8090));
                //获取输入流来读取文件
                FileInputStream in = new FileInputStream("../Other/tcp/b.txt");
                //获取输出流
                OutputStream out = s.getOutputStream();
                //读取文件
                byte[] data = new byte[1024];
                int len;
                while((len = in.read(data)) != -1){
                    //将读取到的数据写出
                    out.write(data,0,len);
                }
                //通知服务器端数据已经写完
                s.shutdownOutput();
                //关流
                in.close();
                s.close();
            }
        }
      #+END_SRC
      #+BEGIN_SRC java
        package cn.commandoptionesc.tcp;

        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.io.InputStream;
        import java.net.InetSocketAddress;
        import java.net.ServerSocket;
        import java.net.Socket;

        //文件上传服务器
        public class FileUploadServer {
            public static void main(String[] args) throws IOException {

                //创建服务器端套接字对象
                ServerSocket ss = new ServerSocket();
                //绑定坚挺的端口号
                ss.bind(new InetSocketAddress(8090));
                //接收连接
                Socket s = ss.accept();
                //创建输出流将数据写出
                FileOutputStream out = new FileOutputStream("../Other/tcp/a.txt");
                //获取输入流
                InputStream in = s.getInputStream();
                //读取数据
                byte[] data = new byte[1024];
                int len;
                while((len = in.read(data)) !=-1){
                    //将读取到的数据写到文件中
                    out.write(data,0,len);
                }
                //通知客户端数据已经读取完毕
                s.shutdownInput();
                //关流
                out.close();
                ss.close();
            }
        }

      #+END_SRC
12. 反射
    1. 反射是去剖析一个类，获取这个类的字节码对象以及实例对象
    2. 如果将字节码看做对象，对这一类对象进行总结，总结出代表字节码的类 - Class
    3. 基本类：
       - Class - 代表字节码的类 - 代表类的类
       - Field - 代表方法的类
       - Method - 代表方法的类
       - Constructor - 代表构造方法的类
       - Package - 代表包的类
       - Annotation - 代表注解的类
    4. 反射在实际开发中，可以结合多态来实现解耦。如果两个或者多个模块之间产生了死死的绑定，称之为耦合。
       [[./Img/9.png]]
    5. 获取Class对象：
       - 通过类名.class方式来获取指定类的字节码对象
       - 通过对象.getClass()方式来获取对象对应的实际类型的字节码对象
       - 通过Class.forName("全路径名")方式来获取指定类型的字节码
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.util.List;
           import java.util.Scanner;

           public class ClassDemo1 {
               public static void main(String[] args) throws ClassNotFoundException {

                   //获取Class对象
                   //方式一：通过类型.class的方式获取
                   //c1z1表示String类对应的字节码
                   Class<String> c1z1 = String.class;
                   System.out.println(c1z1);
                   //c1z2表示List接口对应的字节码
                   Class<List> c1z2 = List.class;
                   System.out.println(c1z1);
                   //c1z3表示double基本类型对应的字节码
                   Class c1z3 = double.class;
                   System.out.println(c1z3);

                   //方式二：通过对象.getClass(）来获取
                   Object o = "abc";
                   Class<String> c1z4 = (Class<String>) o.getClass();
                   System.out.println(c1z4);

                   //方式三：Class.forName
                   //表示获取Scanner类型对应的字节码
                   Class<Scanner> c1z5 = (Class< Scanner>) Class.forName("java.util.Scanner");
                   System.out.println(c1z5);
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.Constructor;
           import java.lang.reflect.InvocationTargetException;

           public class ClassDemo2 {
               public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

                   //c1z1表示String类的字节码
                   Class<String> c1z1 = String.class;
                   //创建对象
                   //等价于：String str = new String();
                   //要求这个类中必须提供无参构造
                   String str = c1z1.newInstance();
                   System.out.println(str);

                   //c1z2表示Integer类的字节码
                   Class<Integer> c1z2 = Integer.class;
                   //Integer in = c1z2.newInstance();
                   //System.out.println(in);
                   //如果需要利用含参构造来创建对象，那么需要先获取对应的构造函数
                   Constructor<Integer> c = c1z2.getDeclaredConstructor(int.class);
                   //执行这个构造函数来创建对象
                   //等价于：Integer in = new Integer(5);
                   Integer in = c.newInstance(5);
                   System.out.println(c);
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.InvocationTargetException;
           import java.lang.reflect.Method;

           public class ClassDemo3 {
               public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {

                   Class<String> c1z = String.class;
                   String str = "abcdefg";

                   ////获取String中charAt方法
                   //Method m = c1z.getDeclaredMethod("charAt",int.class);
                   ////执行charAt方法
                   ////等价于：char c = str.charAt(3);
                   //char c = (char) m.invoke(str,3);
                   //System.out.println(c);

                   //m代表getChars(char[],int)方法
                   Method m = c1z.getDeclaredMethod("getChars", char[].class, int.class);
                   //暴力破解 - 可以打破权限修饰符的范围
                   m.setAccessible(true);
                   char[] cs = new char[10];
                   //等价于：str.getChars(cs,0);
                   m.invoke(str,cs,0);
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.Field;

           public class ClassDemo4 {
               public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {

                   Class<String> c1z = String.class;
                   String str = "hello";
                   //f代表了String类中的hash属性
                   Field f = c1z.getDeclaredField("hash");
                   f.setAccessible(true);
                   //改变属性的值
                   //等价于：str.hash = 135;
                   f.set(str,135);
                   System.out.println(f.get(str));
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.Constructor;

           public class ClassDemo5 {
               public static void main(String[] args) throws NoSuchMethodException {

                   Class<String> c1z = String.class;
                   ////获取String类中所有的构造方法
                   //Constructor<String>[] cs = (Constructor<String>[]) c1z.getDeclaredConstructors();
                   //for(Constructor<String> c:cs){
                   //    System.out.println(c);
                   //}

                   //获取String类实现的接口
                   Class<?>[] is = c1z.getInterfaces();
                   for(Class<?> i:is){
                       System.out.println(i);
                   }

                   //获取类的修饰符
                   int m = c1z.getModifiers();
                   System.out.println(m);

                   //获取类的全路径名
                   System.out.println(c1z.getName());
                   //获取类名
                   System.out.println(c1z.getSimpleName());

                   //获取包
                   System.out.println(c1z.getPackage());

                   //获取父类
                   System.out.println(c1z.getSuperclass());
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           public class ClassDemo6 {
               public static void main(String[] args) {

                   Class<String> c1z = String.class;

                   //判断是否是一个注解
                   System.out.println(c1z.isAnnotation());

                   //判断是否是一个匿名内部类
                   System.out.println(c1z.isAnonymousClass());
                   //判断是否是一个方法内部类/局部内部类
                   System.out.println(c1z.isLocalClass());
                   //判断是否是一个成员内部类
                   System.out.println(c1z.isMemberClass());
                   //判断是否是一个基本类型
                   System.out.println(c1z.isPrimitive());

                   Object str = "hello";
                   //str是否是一个String对象
                   System.out.println(c1z.isInstance(str));
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           public class ClassDemo7 {
               public static void main(String[] args) {

                   Class<String> c1z1 = String.class;
                   Class<Object> c1z2 = Object.class;
                   Class<Comparable> c1z3 = Comparable.class;
                   //判断String类是否继承了Object类
                   System.out.println(c1z2.isAssignableFrom(c1z1));
                   //判断String类是否实现了Comparable接口
                   System.out.println(c1z3.isAssignableFrom(c1z1));
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.Method;

           public class MethodDemo {
               public static void main(String[] args) throws NoSuchMethodException {

                   Class<String> c1z = String.class;

                   //获取String中charAt(int)方法
                   Method m = c1z.getDeclaredMethod("charAt",int.class);

                   //获取String中getByte(String)方法
                   Method n = c1z.getDeclaredMethod("getBytes",String.class);

                   //获取这个方法锁对应的类
                   System.out.println(m.getDeclaringClass());
                   System.out.println(n.getDeclaringClass());

                   //获取这个方法抛出的异常
                   Class<Exception>[] es = (Class<Exception>[]) m.getExceptionTypes();
                   for(Class<Exception> e:es){
                       System.out.println(e);
                   }

                   //
                   Class<?>[] ps = m.getParameterTypes();
                   for(Class<?> p:ps){
                       System.out.println(p);
                   }

                   //获取方法的返回值类型
                   Class<?> r = m.getReturnType();
                   System.out.println(r);
               }
           }

         #+END_SRC
         #+BEGIN_SRC java
           package cn.commandoptionesc.reflect;

           import java.lang.reflect.Field;

           public class FieldDemo {
               public static void main(String[] args) throws NoSuchFieldException {

                   Class<String> c1z = String.class;
                   Field f = c1z.getDeclaredField("hash");

                   //获取属性所在的类的类型
                   System.out.println(f.getDeclaringClass());

                   //获取属性的声明类型
                   System.out.println(f.getType());
               }
           }

         #+END_SRC
    6. 修饰符
       |--------------+--------+------------|
       | 修饰符       | 十进制 |   十六进制 |
       | public       |      1 | 0x00000001 |
       | private      |      2 | 0x00000002 |
       | protected    |      4 | 0x00000004 |
       | static       |      8 | 0x00000008 |
       | final        |     16 | 0x00000010 |
       | synchronized |     32 | 0x00000020 |
       | volatile     |     64 | 0x00000040 |
       | transient    |    128 | 0x00000080 |
       | native       |    256 | 0x00000100 |
       | interface    |    512 | 0x00000200 |
       | abstract     |   1024 | 0x00000400 |
       | strictfp     |   2048 | 0x00000800 |
       |--------------+--------+------------|

    7. 案例：模拟一个clone方法 - 可以在不知道对象的类型的情况下就创建这个对象并且可以对属性进行赋值
       #+BEGIN_SRC java
         package cn.commandoptionesc.reflect;

         import java.lang.reflect.Constructor;
         import java.lang.reflect.Field;
         import java.lang.reflect.InvocationTargetException;
         import java.lang.reflect.Modifier;

         public class ReflectDemo {
             public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException {

                 Student s1 = new Student();
                 s1.setAge(17);
                 s1.setName("Alex");
                 s1.setGender("male");

                 Car c1 = new Car();
                 c1.setColor("red");
                 c1.setPrice(100000);

                 Driver d1 = new Driver("Helen",25,"G23434");

                 Student s2 = (Student) clone(s1);
                 System.out.println(s2);
                 Car c2 = (Car) clone(c1);
                 System.out.println(c2);
                 Driver d2 = (Driver) clone(d1);
                 System.out.println(d2);
             }
             //参数类型不确定的情况下，创建一个一模一样的对象
             public static Object clone(Object o) throws IllegalAccessException, InvocationTargetException, InstantiationException {

                 //获取参数类型
                 Class c1z = o.getClass();
                 //获取构造函数
                 Constructor c = c1z.getDeclaredConstructors()[0];
                 c.setAccessible(true);
                 //获取构造函数中参数的类型
                 Class[] ps = c.getParameterTypes();
                 //存储构造函数的参数
                 Object[] os = new Object[ps.length];
                 for(int i = 0;i < ps.length;i++){
                     if(ps[i] == boolean.class) {
                         os[i] = false;
                     }else if(ps[i] == char.class) {
                         os[i] = '\u0000';
                     }else if(ps[i].isPrimitive()){
                         os[i] = (byte)  0;
                     }else{
                         os[i] = null;
                     }
                 }

                 //构造对象
                 Object newObj = c.newInstance(os);
                 //获取对象所有的属性
                 Field[] fs = c1z.getDeclaredFields();
                 for(Field f:fs){
                     //暴力破解
                     f.setAccessible(true);
                     //判断属性是否是final修饰
                     if((f.getModifiers() & Modifier.FINAL) == Modifier.FINAL)
                         continue;
                     //从传入的对象中将属性值获取出来
                     Object value = f.get(o);
                     //赋值给新创建的对象
                     f.set(newObj,value);
                 }
                 return newObj;
             }
         }

         class Driver{
             private String name;
             private int age;
             private String no;

             public Driver(String name, int age, String no) {
                 this.name = name;
                 this.age = age;
                 this.no = no;
             }

             @Override
             public String toString() {
                 return "Driver{" +
                         "name='" + name + '\'' +
                         ", age=" + age +
                         ", no='" + no + '\'' +
                         '}';
             }
         }

         class Student{

             private String name;
             private int age;
             private String gender;

             public String getName() {
                 return name;
             }

             public void setName(String name) {
                 this.name = name;
             }

             public int getAge() {
                 return age;
             }

             public void setAge(int age) {
                 this.age = age;
             }

             public String getGender() {
                 return gender;
             }

             public void setGender(String gender) {
                 this.gender = gender;
             }

             @Override
             public String toString() {
                 return "Student{" +
                         "name='" + name + '\'' +
                         ", age=" + age +
                         ", gender='" + gender + '\'' +
                         '}';
             }
         }
         class Car{
             private String color;
             private double price;

             public String getColor() {
                 return color;
             }

             public void setColor(String color) {
                 this.color = color;
             }

             public double getPrice() {
                 return price;
             }

             public void setPrice(double price) {
                 this.price = price;
             }

             @Override
             public String toString() {
                 return "Car{" +
                         "color='" + color + '\'' +
                         ", price=" + price +
                         '}';
             }
         }

       #+END_SRC
    8. 在后续学习过程中，会大量的应用反射，例如数据库的JDBC操作等 - 也正是因为有反射的存在，所以才能够更好的实现解耦过程，并且能够更好的分工工作
    9. 在试驾开发过程中，强调"高内聚低耦合" - 高内聚就是尽量提高自己的东西的利用率，低耦合就是尽量减少使用别人的东西
** JDK1.5的特性
1. JDK1.5提供或者增强的主要特性：自动封箱拆箱、增强for循环、反省、静态导入、可变参数、枚举、反射（进行了增强）、动态代理、内省、注解等
2. 静态导入：
   - 在使用一个类中的静态方法的时候，可以在导入语句中单独导入这一个方法而不是导入整个类，这样可以一定程度上提高加载效率
   - 实际过程中这种方式很少使用，这种方式容易和已有的方法产生冲突，同事降低了可读性
     #+BEGIN_SRC java
       package cn.commandoptionesc.jdk5;

       //import java.util.Arrays;
       import java.util.Scanner;
       import static java.util.Arrays.sort;

       public class StaticImportDemo {
           public static void main(String[] args) {

               Scanner s = new Scanner(System.in);
               int len = s.nextInt();

               int[] arr = new int[len];
               for(int i = 0;i < arr.length;i++){
                   arr[i] = s.nextInt();
               }
               //数组排序
               sort(arr);
               //System.out.println(toString(arr));
           }
       }
     #+END_SRC
3. 可变参数：
   - 在调用方法的时候可以传入任意多个参数（可以传入0个参数，可以传入一个参数，也可以传入多个参数），也可以传入一个数组
   - 可变参数本质上就是一个数组，所以可以通过操作数组的方式来操作可变参数
   - 可变在使用的时候只能定义一个，并且必须放在参数列表的末尾
   #+BEGIN_SRC java
     package cn.commandoptionesc.jdk5;

     public class VarArgsDemo {
         public static void main(String[] args) {

             System.out.println(sum());
             System.out.println(sum(3,6));
             System.out.println(sum(3,4,8));
             System.out.println(sum(3,4,5,6,6,3));
             int[] arr = {3,7,9,4};
             System.out.println(sum(arr));
         }

         //用 ... 定义可一个可变参数
         public static int sum(int... arr){
             int sum = 0;
             for(int i = 0;i < arr.length;i++){
                 sum += arr[i];
             }
             return sum;
         }
     }

   #+END_SRC
4. 枚举：
   - 用于表示选项固定并且能够一一列举的场景，例如季节、等级、星期、月份等
   - 枚举中，构造函数默认是私有的而且不许是私有的
   - 枚举常量必须定义在枚举类的首行
   - 在枚举类中可以顶一个任何的属性和方法
   - 在Java中，枚举的顶级父类是java.lang.Enum
   #+BEGIN_SRC java
     package cn.commandoptionesc.jdk5;

     public class Enumdemo {
         public static void main(String[] args) {
             Season s = Season.Spring;
             //Season.Spring = Season.Autumn;
         }
     }

     //特殊的类 - 枚举
     enum Season{
         //枚举常量
         //枚举常量必须放在枚举类的首行
         Spring,Summer,Autumn,Winter;
     }

     ////定义一个类表示季节
     ////因为一年就只有4个季节，所以season类智能对外提供4个对象
     //class Season{
     //
     //    //这个类的构造方法不能对外提供
     //    private Season(){
     //
     //    }
     //    public static final Season Spring = new Season();
     //    public static final Season Summer = new Season();
     //    public static final Season Autumn = new Season();
     //    public static final Season Winter = new Season();

     //}
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.jdk5;

     public class EnumDemo2 {
         public static void main(String[] args) {

         }
     }
     enum Level{

         //public static final Level A = new Level();
         //public static final Level B = new Level(80);

         A,B(80),C,D,E;

         //默认是私有的
         Level(){

         }

         private Level(int score){
             this.score = score;
         }

         private int score;

         public int getScore(){
             return score;
         }

         public void setScore(int score){
             this.score = score;
         }
     }
   #+END_SRC
5. 注解：
   - 注解乐意理解为给机器看的解释说明性的文字
   - 在Java中，注解的顶级父类是Annotation
   - 通过@interface来定义注解
   - 在注解中，通过定义方法的形式来定义属性，属性的类型只能是基本类型、String、枚举、Class、其他注解类型以及它们的一堆数组形式
   - 如果属性是数组，那么且调用的时候数组中只有一个值，那么在调用的时候可以省略{}
   - 通过default来给属性定义默认值
   - 如果一个注解中只有一个属性，并且这唯一的一个属性的名字是value，那么在调用这个属性的时候可以省略属性名不写
   - 元注解：在之前接触过的绝大部分注解都是作用在类、方法、或者属性上，但是元注解是作用在注解上的 - 元注解是对注解进行注解
     + @Target：用于限制注解的使用范围
     + @Retention：用于限制注解的生命周期的
     + @Document：表示生成在文档中
     + @Inherited：表示当前注解要作用在子类上
   #+BEGIN_SRC java
     package cn.commandoptionesc.jdk5;

     import java.lang.annotation.ElementType;
     import java.lang.annotation.Retention;
     import java.lang.annotation.RetentionPolicy;
     import java.lang.annotation.Target;

     //@FirstAnnotation(i = 3,d = 4.6,arr = 'e')
     @SecondAnnotation("demo")
     public class AnnotationDemo {

         @FirstAnnotation(i = 3,d = 4.6,arr = {'e','a'})
         int i = 5;
         public static void main(String[] args) {

         }
     }

     @Target(ElementType.FIELD)
     @Retention(RetentionPolicy.RUNTIME)
     @interface FirstAnnotation{

         //表示给i这个属性一个默认值
         int i() default 5;

         double d();

         char[] arr();
     }

     @interface SecondAnnotation{
         String value();
     }
   #+END_SRC
** 其他
1. Debug模式/断点调试：允许通过断点来一行行调试代码
2. 单元测试/Junit测试：
   - 要求测试方法必须在公共类
   - 需要选中要测试的方法的方法名，如果不选中方法名，则测试的时候会将所有的方法都进行测试
   - 要求被测试的方法必须没有参数，没有返回值以及是一个非静态方法
     #+BEGIN_SRC java
       package cn.commandoptionesc.jdk5;

       import org.junit.After;
       import org.junit.Before;
       import org.junit.Test;

       import java.io.FileWriter;
       import java.io.IOException;

       public class JunitDemo {

           FileWriter writer;
           @Before
           public void init() throws IOException {
               writer = new FileWriter("../Other/d.txt",true);
           }

           @Test
           public void write1() throws IOException{
               System.out.println("测试方法1");
               writer.write("abc");

           }

           @Test
           public void write2() throws IOException{
               System.out.println("测试方法2");
               writer.write("def");
           }

           @After
           public void close() throws IOException{
               System.out.println("关流");
               writer.close();
           }
       }
     #+END_SRC
