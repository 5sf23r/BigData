* 面向对象
** 面向对象简介
*** 面向对象与面向过程的比较
*** 类与对象的关系
*** 对象的内存处理
** 基本概念
*** 成员变量和局部变量
成员变量又叫属性

|--------------+------------------------------+------------------------------------|
| 区别         | 成员变量                     | 局部变量                           |
| 定义位置     | 定义在类中方法外             | 定义在方法或者语句中               |
| 作用范围     | 整个类中                     | 对应的方法或者语句中               |
| 内存位置     | 存储在堆内存中               | 存储在占内存中                     |
|              | 并且在堆内存中被赋予了默认值 | 而且没有默认值需要手动给定数据     |
| 生命周期     | 在对象创建的时候创建         | 在方法或者语句执行的时候创建       |
|              | 在对象被笑会的时候销毁       | 方法或者语句执行完成之后销毁       |
| ------------ | --------------------------   | ---------------------------------- |
*** 匿名对象
匿名对象就是指没有名字的对象
- 注意事项
  1. 因为匿名对象没有名字，所以只能在创建的时候使用一次
  2. 匿名对象可以作为参数进行传递
  3. 匿名对象如果没有作为参数传递，那么在栈内存中是没有引用的
#+BEGIN_SRC java
package cn.commandoptionesc;

public class StudentDemo{
    public static void main(String[] args){

        //创建乐意个Student对象
        //注意：像这种没有名字的对象称之为匿名对象
        new Student().play();

        //new几次，就会创建几个对象，几个对象的地址是不一样的
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());
        System.out.println(new Student());

        //匿名对象可以作为参数进行传递
        printName(new Student());
    }

    public static void printName(Student s){
        System.out.println(s.name);
    }
}


//定义一个类表示学生
class Student{
    //姓名、年两、性别、班级、学号
    //属性：成员变量
    String name;
    int age;
    byte gender;
    String grade;
    String no;

    //定义方法表示“学习”行为
    //定义在方法中的变量成为局部变量
    public void study(String subject){

        System.out.println(name + "在学习" + subject);
    }

    //定义方法表示"吃"行为
    public void eat(String food){

        System.out.println(name + "再吃" + food);
    }

    //定义方法表示"玩耍"行为
    public void play(){

        System.out.println(name + "在玩耍");
    }
}
#+END_SRC
*** 构造方法
1. 类中存在的方法名与类名一致而没有返回值类型的方法
2. 作用
   - 构造方法最主要的作用是用于创建对象

   - 可以在构造方法中对属性进行初始化，或者执行其他一些初始化的操作
3. 如果在类中没有手动给定狗仔方法，那么在编译的时候会自动添加一个默认的无参构造
4. 如果一个类中手动添加了构造方法，那么在编译的时候就不会再添加无参的构造方法
5. 构造方法虽然没有返回值类型，但是可以有return语句，其作用是避免一些不合常理的数据被赋值给属性
6. 构造方法可以进行重载
   #+BEGIN_SRC java
   public class DriverDemo{
       //创建Driver
       //构造方法、构造函数
       //这个类目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
       Driver d = new Driver("Amy",19.(byte)0);
       //当提供了无参构造，那么意味着可以利用无参构造创建对象
       Driver d2 = new Driver();
   }
   class Driver{
       String name;
       int age;
       byte gender;
       //驾照号
       String no;

       //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
       //与类同名，但是没有返回值类型
       //利用new关键字来调用构造方法，利用构造方法来创建对象
       public Driver(){
       }

       //定义一个含参构造
       //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
       public Driver(String n,int a,byte g){
           name = n;
           age = a;
           gender = g;
       }
   }
   #+END_SRC
#+BEGIN_SRC java
package cn.commandoptionesc;

public class DriverDemo{
    public static void main(String[] args){
    //创建Driver
    //构造方法、构造函数
    //这个类目目前只提供了含参构造，所以只能调用含参构造来创建对象，而无法调用无参构造
    Driver d = new Driver("Amy",15,(byte)0);
    //当提供了无参构造，那么意味着可以利用无参构造创建对象
    Driver d2 = new Driver();
    }
}

class Driver{
    String name;
    int age;
    //驾照号
    String no;

    //当一个类中没有手动定义构造函数的时候，那么这个类在编译完成之后自动添加一个无参构造函数
    //与类同名，但是没有返回值类型
    //利用new关键字来调用构造方法，利用构造方法来创建对象
    public Driver(){
    }

    //定义一个含参构造
    //一个类中如果手动定义了构造方法，那么这个类在编译的时候就不会自动添加构造方法
    public (Driver(String n,int a,byte g)){
        if(a<18){
            System.out.println("年龄不合法，死机的最小年龄应该是18");
            //可以利用利用return来规避不合理的值，结构构造方法
            return;
        }
        name = n;
        age = a;
        gender = g;
    }
}
#+END_SRC
*** this关键字
1. 因为在java中所有的非静态的方法和属性都是通过对象来调用的，而在本类中如果想调用本类中的方法和属性，并没有本类的对象，所以要用到this来代表当前类的对象，来调用属性和方法
2. this代表本类在活动的对象的引用，可以认为是一个虚拟对象，用于在类内调用本类中的非静态方法和被静态属性
3. this()语句表示在本类的构造方法中调用本类其他形式的构造方法。需要注意的是，this语句必须放在构造方法的第一行
#+BEGIN_SRC java
package cn.commandoptionesc.thisx;

public class ThisDemo{

    //static修饰的属性或者方法就是静态的
    public static void main(Stringp[] args){


        //活跃的对象是s1，所以this代表s1
       Student s1 = new Student("Bob");
       System.out.println(s1.name);
       //此时，活跃的对象是s2，所以this代表s2
       Student s2 = new Student("Alex");
       //活跃的对象又变成s1，所以this代表s1
       s1.age = 15;
    }
}
class Student{
    //姓名
    String name;
    //年龄
    ing age;
    //性别
    byte gender;
    //学号
    String no;

    //在Java中，当出现变量名一致的时候，采取就近原则来使用
    //在Java中，所有的非静态属性哈非静态方法都是通过对象来调用的
    //在类中用this代替当前活跃的对象来调用属性或者方法
    public Student(String name){
        this,name = name;
    }
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    public Student(String name,int age,byte gender){
        //this.name = name;
        //this.age = age;
        //表示滴啊用Student(String,int)
        this(name,age);
        this.gender = gender;
    }
    public Student(String name,int age,byte gender,String no){
        //this.name = name;
        //this.age = age;
        //this.gender = gender;

        //this语句
        //会自动调用本类中符合形式的构造方法
        //this(String,int,byte)--自动找--->Student(name,age,byte);
        //this语句必须在构造方法的第一行
        this(name,age,gender);
        this.no = no;
    }
}
#+END_SRC
*** 构造代码块
**** 构造代码块
1. 所谓构造代码块是指定义在类内用{}包起来的代码，也称之为是初始化代码块
2. 无论调用哪个构造方法，构造代码块都会执行
3. 构造代码块是在创建对象的时候先与构造方法执行
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class ConstructorCodedemo{
    public static void main(String[] args){
        new Baby();
        new Baby("helen");
    }
}

//定义一个类表示婴儿
class Baby{
    String name;
    //在类中用{}括起来的代码称之为构造代码快或者叫初始化代码块
    //无论调用哪个构造方法，这个代码块都会执行
    //构造代码块是先于构造方法执行的
    {
        this.cry();
        this.eat();
    }

    public Baby(){
    }

    public Baby(String name){
        System.out.println("~~~~~~~");
        this.name = name;
    }

    public void cry(){
        System.out.println("这个婴儿在哭");
    }

    public void eat(){
        System.out.println("这婴儿再吃");
    }
}
#+END_SRC
**** 局部代码块
1. 所谓局部代码块，是指定义在方法中用{}包起来的代码
2. 作用是限制变量的生命周期从而提高栈内存的利用率
#+BEGIN_SRC java
package cn.commandoptionesc.code;

public class LocalCodeDemo{
    public static void main(String[] args){

        //在方法中用{}括起来的代码称之为局部代码块
        {
            //限制了变量的使用范围，缩短了变量的生命周期
            //提高了栈内存的利用率
            int j = 5;
            int i = 7;
            System.out.println(i+j);
        }
        System.out.println("running");
    }
}
#+END_SRC
*** 权限修饰符
1. 使用范围
   |-----------+--------+----------------+----------+----------|
   | 关键字    | 本类中 | 子类中         | 同包类中 | 其他类中 |
   |-----------+--------+----------------+----------+----------|
   | public    | 可以   | 可以           | 可意     | 可以     |
   | protected | 可以   | 可意           | 可以     | 不可以   |
   | 默认      | 可以   | 同包子类中可以 | 可意     | 不可以   |
   | private   | 可以   | 不可以         | 不可以   | 不可以   |
   |-----------+--------+----------------+----------+----------|
   #+BEGIN_SRC java
   package cn.commandoptionesc.object;

   public class PrivateDemo {
       public static void main(String[] args) {
           Person p = new Person();
           p.setName("amy");
           p.setAge(17);
           System.out.println(p.getAge());
           System.out.println(p.getName());
       }
   }

   //定义一个代表人的类
   class Person{

       private String name;
       //私有
       private int age;

       //提供一个方法，将要赋值的属性作为参数
       public void setAge(int age){
           if(age < 0 || age >= 150)
               return;
           this.age = age;
       }

       public int getAge(){
           return this.age;
       }

       public void setName(String name){
           this.name = name;
       }

       public String getName(){
           return this.name;
       }
   }
   #+END_SRC
2. 注意事项
   - 限制修饰符的范围是public > protected > 默认 > private

   - 需要注意的是，默认的权限修饰符只能在本类中以及同包类中使用，同包子类本质上也是同包类

   - protected在子类中使用指的是在对应的子类中使用，跨子类是不能使用的
** 基本概念2
*** static
1. static本身是一个修饰符，可以修饰变量、方法、内部类、代码块
2. 静态是从类的层面来看的，已经超越了对象
**** 静态变量：
用static修饰变量那么这个变量我们就称之为静态变量，有称之为成员变量或者类变量
1. 静态变量随着类的加载而加载到了方法区中的静态区，并且静态区中自动赋予一个默认值。静态变量优先于对象而存在，所以静态变量可以通过类名来调用，也可以通过对象来调用。该类产生的所有的对象实际上存的是该静态变量在静态区中的地址，静态变量是被所有对象所共享的
2. 静态内存流程
   [[./Img/1.png]]
**** 静态方法：
用static修饰的方法就叫做静态方法，也叫类方法
1. 在类加载的时候加载到了方法区中的静态区，只是存储在静态区，在方法被调用的时候到栈内存中执行。静态区中的元素不归属于某一个对象而是归属于类。静态方法优先于对象而存在的，所以静态方法可以通过类名来调用，也可以通过对象来调用
2. 静态变量不可以定义到静态方法中。静态方法在静态区中只存储不执行，当被调用的时候才在栈中执行。而静态变量是根据类的加载而加载，上来就要进行初始化 --- 所有的鼎泰元素都是定义在类中
3. 静态方法中不可以直接调用本类中的非静态方法。在Java中所有非静态方法和非静态属性都是通过对象来调用的，静态方法是优先于对象存在的，也就意味着静态方法执行的时候可以没有对象。也因此在静态方法中不可以使用this和super。super与this都是和对象是想关联的，而静态优先于对象而存在。
4. 静态方法可以重载。重载对修饰符没有要求的，对返回值也没有要求
5. 静态方法不可以重写（方法的覆盖）
   静态方法可以存在方法签名完全一致的静态方法，这不是重写，称之为隐藏。但是也适用于重写的那套规则。
6. 注意：
   如果父子类中存在方法签名相同的方法要么都是普通的方法，要么都是静态方法
**** 静态代码块
1. 在类中用static修饰用{}括起来的代码块
2. 静态代码块针对的是类，所以也可以叫做类代码块
3. 实际上静态代码块是随着类的加载而加载到方法区，在类创建对象或者执行方法之前执行一次，终其一生只执行一次
4. 执行顺序：
   在这个类第一次被真正使用（第一次创建对象/调用方法）的时候执行一次。如果一个类包含多个静态代码块，则按照书写顺序执行。由于类只在第一次使用的时候加载，所以静态代码块也只执行一次。
5. 代码块执行顺序：
   先父类后子类，先静态后动态。（先父子类的静态，后子类的动态）静态优先，父类优先
6. 代码是从上到下，从左到右一次编译执行：
   创建子类对象的时候需要先：创建父类对象 ---> 加载父类 ---> 执行父类静态代码块 ---> 执行子静态代码块 ---> 父类构造函数 ---> 子类构造代码块 ---> 子类构造函数
   #+BEGIN_SRC java
   public class ex4{
       public static void main(String[] args){

       }
   }
   class A{
       //静态代码块
       static{
           System.out.println("A 1");
       }

       {
           System.out.println("A 2");
       }

       public A(){
           System.out.println("A 3");
       }
   }
   class B extends A{
       static{
           System.out.println("B 1");
       }
       {
           System.out.println("B 2");
       }
       public B(){
           System.out.println("B 3");
       }
   }
   #+END_SRC

   new B();
   试图B类，但是准备加载B类的时候发现B有父类A，所以先加载A类，执行A中的静态代码块，A类加载完成之后在加载B类，执行B中的静态代码快。试图创建B对象的时候，会先利用super语句创建一个A类对象，然后在创建B类对象

*** final
1. 常量
   当final修饰数据（基本类型和引用类型）的时候，表示这个变量的值不可变，称之为常亮。终其一生只能赋值一次。在Java中所说的常量往往是指静态常量。因为实质上只有静态常量才是独有的一个。
   - 特点：
     + 常量在定义好之后不可改变，final固定的是栈内存中的数值
     + 常量可以作为参数传递，传递之后是否还是一个常量要看接收的方法中是否定义为一个常量
     + 对引用类型而言，final固定的是其在栈中的地址不可变。例如：数组在栈内存中存储的是地址，用final修饰，是不能改变数组的地址，但数组的值可以改变。对于对象而言，对象的引用不能改变，但是应用的属性值是可以进行改变的。
     + 成员常量只要是在对象创建完之前（构造方法/函数执行结束之前）赋初始值即可
     + 静态成员变量（static final）只要在类加载完成之前给值即可，而且只能在静态代码块中赋值
2. 最终方法
   - final修饰方法的时候，这个方法就是最终方法
   - 特点：
     + 最终方法不可以被重写也不能被隐藏，可以重载，可以被继承
     + 静态方法可以被final修饰
3. 最终类
   - final修饰的类称之为最终类
   - 特点：
     + 最终类不可以被继承，也不能有匿名内部类形式。
     + 由于最终类不能被继承，一次重写也是不可以的。
*** abstract
1. 抽象类
   - 将一些名称一致但是细节不同的行为提取到父类中定义为抽象方法，抽象方法所在的类就是抽象类，用abstract来修饰的类
   - 抽象类中，不一定含有抽象方法，但是抽象方法所在的类一定是抽象类
   - 抽象类不可以在Java中创建/实例化。即使没有抽象方法也无法创建对象，可以创建匿名内部类
   - 抽象类被子类继承之后，必须重写其中的抽象方法，除非子类也是抽象类
   - 抽象类中可以没有抽象方法
   - 抽象类中可以定义一切的属性和方法
   - 抽象类不能用final修饰。最终类不可以是抽象类
2. 抽象方法：
   - 如果所有的子类中存在了一些名称一致而细节不同的方法的时候，这个时候可以在父子类中声明该行为，此时声明行为的时候不需要添加方法体，所以此时该方法就形成了抽象方法，使用abstract修饰
* 面向对象的特征
** 封装
1. 封装是面向对象方法的重要原则，就是把对象的属性和方法（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。封装是一种信息隐藏技术。
2. 形式
   a. 方法，其实是封装的一种常见的形式，通过将某段常用的逻辑进行提取从而形成一种新的形式。
   b. 属性的私有化，在类中定义了属性之后，如果允许在类外直接操作属性会导致用户直接给属性赋予一些不合常理的数据。将属性私有化，将属性用private修饰，然后提供对外的访问（getXXX）和设置（setXXX）的方法，在方法中进行限定，使属性值更加符合的场景要求。
   c. 内部类，内部类作为封装的一种形式，是为了让代码的结构更加的紧凑
3. 作用
   a. 提高了复用性（降低了代码的冗余度）、安全性、使代码结构更加紧密
   b. 使属性私有化 - 隐藏信息，实现细节
   c. 使属性值更符合要求 - 可以对成员进行更精准的控制
   d. 提高了代码的安全性 - 类内部的结构可以自由修改
   e. 良好的封装能够减少耦合
#+BEGIN_SRC java
package cn.commandoptionesc.object;

public class PrivateDemo {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("amy");
        p.setAge(17);
        System.out.println(p.getAge());
        System.out.println(p.getName());
    }
}

//定义一个代表人的类
class Person{

    private String name;
    //私有
    private int age;

    //提供一个方法，将要赋值的属性作为参数
    public void setAge(int age){
        if(age < 0 || age >= 150)
            return;
        this.age = age;
    }

    public int getAge(){
        return this.age;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }
}
#+END_SRC
** 继承
1. 如果一些类中的属性和方法是相同的，那么可以把这些类中相同的属性和方法提取到一个新的类中，然后利用extends关键字让原来的类和行的类产生练习，这种练习称之为继承。而这个时候原来的类称之为是子类，新的类称之为父类
2. 注意事项
   - Java中支持的是类和类之间的'单继承'，即一个子类只能有一个父类，但是一个父类可以有多个子类。
   - 通过继承，子类可以继承父类全部的数据域，但是只有一部分数据域对子类可见，所以子类也只能使用这一部分可见的数据域
3. 单继承与多继承的比较
   - 多继承在代码的复用性上要优于单继承，但是存在方法调用的混乱
     #+BEGIN_SRC java
     public class ex3{
         public static void main(String[] args){
         }
     }
     class A{
         public void m(){
             System.out.println("A");
         }
     }
     class B{
         public void m(){
             System.out.println("B");
         }
     }
     class C extends A,B{

     }
     C c = new C();
     c.m();
     #+END_SRC
   - 单继承也可以提高代码的复用性，可以避免方法调用的混乱，提高了方法调用的安全性
4. 特征
   - 继承关系是传递的
   - 继承简化了人们对事物的认识和描述，能清晰的体现相关类间的层次结构关系
   - 继承提高了代码的复用性
   - 继承通过增强一致性来减少模块间的接口和界面，大大增加了程序的易维护性
5. 优点
   - 提高复用性
   - 提高安全性，避免方法调用产生混乱
   - 统一结构
6. 方法的重写
   - 子类里存在了方法签名（方法名+参数列表）完全一致的非静态方法，就构成了方法的重写（覆盖）
   - 子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要曹勇方法的重写，方法重写又称方法覆盖
   - 遵循原则：方法的重写需要遵循“两等两小一大”的原则：
     + 方法签名要求完全一致
     + 如果父类里的返回值是基本数据类型/void/最终类，那么子类里重写的返回值类型必须一致（如果父类的方法是private的话，子类是无法被继承的，即使子类重新定义这个方法，也不算重写）
     + 如果父类方法的返回值类型是一个引用类型，子类方法的返回值类型是父类方法的返回值类型的子类
        #+BEGIN_SRC java
        public class ex{
            public static void main(String[] args){
            }
        }
        class Pet{}
        class Dog extends Pet{}

        class A{
            public Pet m(){}
        }
        class B extends A{
            //public Pet m(){}
            public Dog m(){}
        }
        #+END_SRC
     + 子类方法的权限修饰符的范围要大于等于父类方法权限修饰符的范围，需要注意的是，对于8种基本数据类型之间没有继承关系的，它们是同级关系
        #+BEGIN_SRC java
        public ex2{
            public static void main(String[] args){}
        }
        class A{
            protected void m(){}
        }
        class B extends A{
            //protected void m(){}
            public void m(){}
        }
        #+END_SRC
7. super关键字
   - super表示在子类中对父类对象的引用，可以看做是一个虚拟对象
   - 在子类中可以通过super调用父类中的非讲台方法或者非静态属性
   - 在子类的构造方法中看，可以通过super关键字调用父类中的对应形式的构造方法，如果不指定，默认调用父类的无参构造
   - 如果父类中值提供了含参的构造方法，那么子类的构造方法中必须手动定义super语句来调用父类中的含参构造
   - super语句必须放在狗仔方法的第一行，所以super语句不能同时出现
** 多态
1. 多态是指允许不同类的对象对同意消息做出相应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态主要针对对象的行为及方法，而不是对象的属性。
2. 体现形式：
   - 编译时多态
     在编译时期就要进行动态绑定的行为，主要体现为方法的重载
   - 运行时多态
     + 在运行时期才能确定绑定的运行过程，主要体现形式是向上造型、方法的重写
     + 需要注意的是运行时多态的前提需要产生了继承关系或者实现关系
3. 向上造型
   指的是用父类声明对象而用子类创建对象的行为方式，利用向上造型创建的对象所能使用的属性或者方法需要看的是声明类，而具体怎么执行所调用的方法看的是实现类
4. 作用
   统一结构，实现解耦
#+BEGIN_SRC java
package cn.commandoptionesc.method;

public class ObjectDemo {
    public static void main(String[] args) {

        //用父类Pet生命对象，用子类创建对象 ---> 向上造型
        //向上造型创建对象，在编译的时候，并不会去检查具体子类
        //在编译的时候，首先发现Pet p所以确定这个对象是一个Pet对象
        //继续往后编译会检查后边要使用的类和前面生命的类是否有继承关系
        //Cat和Pet有继承关系，那么久编译通过，而此时并没有去检查具体是哪一个子类
        //编译的时候没有确定子类，也就不知道子类中具体有哪些方法
        //所以在使用的时候，就不允许调用子类中独有的方法
        //此时只允许调用父类中声明的方法
        Pet p = new Cat();
        //向上造型创建的喜爱那个在调用方法的时候调用的是子类中的方法
        p.eat();

        //向上造型创建的对象不能调用子类中独有的的方法
        //p.catchMouse();
    }
}

//定义一个类表示宠物
class Pet{
    public void eat(){
        System.out.println("在吃东西");
    }

}

//定义一个类表示猫
class Cat extends Pet{
    @Override
    public void eat() {
        System.out.println("这只猫在吃鱼");
    }

    public void catchMouse(){
        System.out.println("这只猫抓到了一直老鼠");
    }
}

//定义一个类表示狗
class Dog extends Pet{
    @Override
    public void eat() {
        System.out.println("这只狗再吃骨头");
    }

    public void bark(){
        System.out.println("这是狗在汪汪叫");
    }
}

#+END_SRC
