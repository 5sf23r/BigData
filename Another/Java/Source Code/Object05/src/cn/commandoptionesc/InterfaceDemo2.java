package cn.commandoptionesc;

public class InterfaceDemo2 {
    public static void main(String[] args) {

        //在Java中，支持的是类和类之间的单继承，所以可以形成一颗继承结构树
        //在继承结构树中，可以比较容易的确定两个类之间是否有继承关系
        //因此在编译的时候会检查声明类和实现类（强转的类型）之间是否有继承关系
        /*
        A a = new B1();
        //a的声明类型是A，要转化的类是B1，B1继承了A类，所以A和B1之间有继承关系
        //因为有继承关系，所以在编译期间允许转换，在编译期间仅仅是检查是否有继承关系
        //而不去检查到底是要转化为哪一个子类
        //到了运行的时候，才会去检查这个对象到底能不能转换
        //到了运行的时候，a的实际类型是B1，要强转的类型也是B1，可以转换
        //编译可以，运行也可以
        B1 b1 = (B1)a;
        */

        /*
        //ClassCastException - 类型转换异常
        A a = new B1();
        //a的声明类型是A，要转化的类型是B2，A和B2之间有继承关系，所以编译通过
        //但是到了实际运行的时候，a的实际类型是B1，要强转的类型是B2，类型不一致，所以运行失败
        //编译可以，运行失败
        B2 b2 = (B2)a;
        */

        /*
        A a = new B1();
        //a的声明类型是A，要转化的类型是C，A和C之间没有继承关系，所以编译失败
        C c = (C)a;
        */

        //ClassCastException - 类型转换异常
        //在Java中，类和接口之间是多实现，接口和接口之间是多继承的
        //在一个网状结构中，想要确定连个结点之间是否有联系是一件比较麻烦的操作
        //所以Java为了减少编译花费的时间，那么在编译阶段放弃检查
        //也就意味着用接口声明对象的时候不检查结构关系，所以用任何一个接口都可以进行强转
        //但是到了运行的时候回检查是否有关系
        //到了运行的时候，要转化的类型是D，实际类型是B1，B1和D之间没有关系，所以运行失败
        A a = new B1();
        D d = (D)a;

    }
}

class A{

}

class B1 extends A{}
class B2 extends A{}
class C{

}

interface D{

}
