* 目录                                                                          :TOC_5:QUOTE:
#+BEGIN_QUOTE
- [[#web概述][Web概述]]
  - [[#bs][B/S]]
  - [[#cs][C/S]]
  - [[#web概述-1][web概述]]
- [[#html][HTML]]
  - [[#1-html是什么][1. HTML是什么]]
  - [[#2-html的结构][2. HTML的结构]]
  - [[#3-html语法][3. HTML语法]]
  - [[#4-font标签][4. font标签]]
  - [[#5-标题标签][5. 标题标签]]
  - [[#6-列表标签][6. 列表标签]]
    - [[#无序列表][无序列表]]
    - [[#有序列表][有序列表]]
  - [[#7-img标签----图像标签][7. img标签 -- 图像标签]]
  - [[#8-超链接----a锚][8. 超链接 -- <a>锚]]
  - [[#9-表格标签----table][9. 表格标签 -- <table>]]
- [[#表单][表单]]
  - [[#1-表单][1. 表单]]
  - [[#2-表单中的项][2. 表单中的项]]
- [[#注册表单练习][注册表单练习]]
- [[#注册表单联系2][注册表单联系2]]
- [[#css][CSS]]
  - [[#1-网页组织的两种常用方式][1. 网页组织的两种常用方式]]
  - [[#2-容器标签][2. 容器标签]]
  - [[#3-css的概念][3. CSS的概念]]
  - [[#4-css的四种引入方式][4. CSS的四种引入方式]]
  - [[#5-css引入顺序][5. CSS引入顺序]]
  - [[#6-css选择器的分类][6. CSS选择器的分类]]
    - [[#1-基本选择器][1. 基本选择器]]
    - [[#2-扩展选择器][2. 扩展选择器]]
  - [[#8-拓展css中的常用属性简介][8. 拓展：CSS中的常用属性简介]]
- [[#javascript][JavaScript]]
  - [[#1-js概述][1. js概述]]
  - [[#2-javascript不得不说的历史][2. JavaScript不得不说的历史]]
  - [[#3-js和html的结合][3. js和html的结合]]
  - [[#4-js输出方式][4. js输出方式]]
  - [[#5-js的语法-数据类型][5. js的语法-数据类型]]
    - [[#1-基本数据类型共六种][1. 基本数据类型：共六种]]
    - [[#2-复杂数据类型][2. 复杂数据类型]]
        - [[#1-js语法--函数][1. js语法--函数]]
        - [[#2-js语法--数组][2. js语法--数组]]
        - [[#3-js语法--对象][3. js语法--对象]]
    - [[#3-数据类型的自动转化][3. 数据类型的自动转化]]
  - [[#6-js语法--运算符][6. Js语法--运算符]]
  - [[#7-定义变量][7. 定义变量]]
  - [[#8-js语法--语句][8. js语法--语句]]
    - [[#1-if语句][1. if语句：]]
    - [[#2-switch-case][2. switch case]]
    - [[#3-whiledowhilefor][3. while、dowhile、for]]
  - [[#9-json][9. JSON]]
- [[#dhtml-动态html][DHTML-动态html]]
  - [[#1-dhtml概述][1. DHTML概述]]
  - [[#2-bom和dom][2. BOM和DOM]]
  - [[#3-bom--浏览器对象模型][3. BOM--浏览器对象模型]]
  - [[#4-dom--文档对象模型][4. DOM--文档对象模型]]
  - [[#5-问题][5. 问题：]]
- [[#jquery][jQuery]]
  - [[#1-jquery概述][1. jQuery概述]]
  - [[#2-jquery的优势][2. jQuery的优势]]
  - [[#3-jquery版本支持][3. jQuery版本支持]]
  - [[#4-jquery引入][4. jQuery引入]]
  - [[#5-jquery的使用方式][5. jQuery的使用方式]]
  - [[#6-js对象和jquery对象的相互转换][6. js对象和jQuery对象的相互转换]]
  - [[#7-jquery主要用法][7. jQuery主要用法：]]
  - [[#8-jquery选择器][8. jQuery选择器]]
  - [[#-1-基本选择器selector案例一][* 1. 基本选择器(selector案例一)]]
    - [[#2-层级选择器selector案例二][2. 层级选择器(selector案例二)]]
    - [[#3-基本过滤选择器selector案例三][3. 基本过滤选择器(selector案例三)]]
    - [[#4-内容选择器selector案例四][4. 内容选择器(selector案例四)]]
    - [[#5-属性选择器selector案例五][5. 属性选择器(selector案例五)]]
    - [[#6-表单选择器selector案例六][6. 表单选择器(selector案例六)]]
    - [[#更多操作][更多操作]]
- [[#git][Git]]
- [[#mysql][MySQL]]
  - [[#1-数据库概述][1. 数据库概述]]
  - [[#2-sql语句---库表操作][2. SQL语句---库、表操作]]
  - [[#3-数据库的crud][3. 数据库的CRUD]]
  - [[#4-备份回复数据库][4. 备份、回复数据库]]
  - [[#5-多表设计][5. 多表设计]]
  - [[#6-外键约束][6. 外键约束]]
  - [[#7-多表查询][7. 多表查询]]
  - [[#8-扩展][8. 扩展]]
- [[#jdbc][JDBC]]
  - [[#jdbc概述][JDBC概述]]
  - [[#详解jdbc六步][详解JDBC六步]]
  - [[#jdbcutils工具类][JDBCUtils工具类]]
- [[#登陆功能实现][登陆功能实现]]
- [[#tomcat][Tomcat]]
  - [[#课堂笔记][课堂笔记]]
    - [[#1-服务器概述][1. 服务器概述]]
    - [[#2-tomcat服务器的下载与安装][2. tomcat服务器的下载与安装]]
      - [[#21-下载本地资源][2.1 下载本地资源]]
      - [[#22-官方网站下载资源][2.2 官方网站下载资源]]
      - [[#23-tomcat的运行环境][2.3 tomcat的运行环境]]
      - [[#24-tomcat与jdk对应的版本][2.4 tomcat与jdk对应的版本]]
      - [[#25-端口号被占用问题][2.5 端口号被占用问题]]
      - [[#26-修改端口号][2.6 修改端口号]]
      - [[#27-tomcat的目录结构][2.7 tomcat的目录结构：]]
    - [[#3-tomcat的基本概念][3. tomcat的基本概念]]
    - [[#4-web应用配置虚拟路径映射的三种方式][4. web应用配置虚拟路径映射的三种方式]]
      - [[#方式一][方式一：]]
      - [[#方式二-直接部署不需要重新启动tomcat][方式二： 直接部署，不需要重新启动tomcat]]
      - [[#方式三][方式三：]]
    - [[#5-配置一个虚拟主机][5. 配置一个虚拟主机]]
    - [[#6-综合练习][6. 综合练习]]
- [[#sql注入攻击][SQL注入攻击]]
- [[#批处理][批处理]]
- [[#数据库连接池][数据库连接池]]
  - [[#1-c3p0连接池][1. C3P0连接池]]
  - [[#2-实现][2. 实现：]]
  - [[#3-手写mypool连接池][3. 手写MyPool连接池：]]
  - [[#4-开源连接池][4. 开源连接池]]
- [[#servletrequestresponse][Servlet、Request、Response]]
  - [[#servlet][Servlet]]
    - [[#1-servlet概述][1. Servlet概述]]
    - [[#2-手写servlet][2. 手写Servlet]]
    - [[#3-配置servlet映射][3. 配置servlet映射]]
    - [[#4-servlet调用过程和生命周期][4. Servlet调用过程和生命周期]]
    - [[#1-servlet继承结构][1. Servlet继承结构]]
    - [[#2-图片如何被加载][2. 图片如何被加载？]]
    - [[#3-拓展request对象和response对象][3. 拓展：request对象和response对象]]
    - [[#5-servlet细节讨论][5. Servlet细节讨论]]
  - [[#request][Request]]
    - [[#1-request概述与功能一-----api操作][1. request概述与功能一 --- API操作]]
    - [[#2-http请求][2. HTTP请求]]
      - [[#1-继承结构][1. 继承结构]]
      - [[#2-http请求的组成][2. HTTP请求的组成]]
    - [[#3-request当中的api操作][3. Request当中的API操作：]]
      - [[#1-获取客户端相关的信息][1. 获取客户端相关的信息]]
      - [[#2-获取请求头信息][2. 获取请求头信息]]
      - [[#3-获取请求参数][3. 获取请求参数]]
      - [[#4-中文乱码问题][4. 中文乱码问题：]]
    - [[#4-request功能二-----请求转发][4. request功能二 --- 请求转发]]
      - [[#1-什么是请求转发][1. 什么是请求转发：]]
      - [[#2-请求转发的特点][2. 请求转发的特点：]]
      - [[#3-请求转发实现][3. 请求转发实现：]]
      - [[#4-注意请求转发是web应用内部的资源跳转不可以在web应用之间跳转][4. 注意：请求转发是web应用内部的资源跳转，不可以在web应用之间跳转]]
    - [[#5-request功能三-----作为域对象使用][5. request功能三 --- 作为域对象使用]]
      - [[#1-域对象概述][1. 域对象概述]]
      - [[#2-域对象的时候用方式][2. 域对象的时候用方式：]]
      - [[#3-request域对象的特点][3. request域对象的特点]]
      - [[#4-案例从servlet向首页输出数据][4. 案例：从servlet向首页输出数据]]
    - [[#6-request功能四-----请求包含][6. request功能四 --- 请求包含]]
      - [[#1-请求包含概念][1. 请求包含概念]]
      - [[#2-请求包含的特点][2. 请求包含的特点]]
      - [[#3-请求包含实现][3. 请求包含实现:]]
  - [[#response][Response]]
    - [[#1-response对象][1. response对象]]
    - [[#2-response参数乱码处理][2. response参数乱码处理]]
    - [[#3-response功能一-----请求重定向][3. response功能一 --- 请求重定向]]
    - [[#4-response功能二-----定时刷新][4. response功能二 --- 定时刷新]]
    - [[#5-response功能三-----控制浏览器缓存][5. response功能三 --- 控制浏览器缓存]]
  - [[#课堂笔记-1][课堂笔记]]
    - [[#1-概述][1. 概述]]
      - [[#1-servlet是什么][1. servlet是什么？？？]]
      - [[#2-servlet的主要作用][2. servlet的主要作用]]
      - [[#3-servlet的api][3. servlet的API]]
      - [[#4-编写一个servlet的程序入门案例][4. 编写一个servlet的程序：入门案例]]
    - [[#2-servlet的genericservlet详解][2. servlet的GenericServlet详解]]
      - [[#1-servlet是一个接口内部只有方法签名没有方法体][1. servlet是一个接口，内部只有方法签名，没有方法体]]
      - [[#2-servlet的一个实现类genericservlet类][2. servlet的一个实现类：GenericServlet类]]
      - [[#3-浏览器发送http请求的方式7种][3. 浏览器发送HTTP请求的方式：7种]]
    - [[#3-servlet的httpservlet详解][3. servlet的HttpServlet详解]]
      - [[#1httpservlet的继承关系][1.HttpServlet的继承关系]]
      - [[#2httpservlet的方法详解][2.HttpServlet的方法详解]]
      - [[#3-httpservlet的方法service方法][3. HttpServlet的方法：service()方法]]
      - [[#4-模拟一个场景用户的一个注册提交的场景][4. 模拟一个场景：用户的一个注册提交的场景]]
    - [[#4-servlet的httpservletrequest详解][4. servlet的HttpServletRequest详解]]
      - [[#1-request的继承结构][1. Request的继承结构]]
      - [[#2-httpservletrequest的常用方法][2. HttpServletRequest的常用方法]]
        - [[#1-获取客户端相关信息][1. 获取客户端相关信息]]
        - [[#2-获取请求头信息-1][2. 获取请求头信息]]
        - [[#3-获取请求参数-1][3. 获取请求参数]]
- [[#easymall注册功能][EasyMall注册功能]]
  - [[#课堂笔记-2][课堂笔记]]
    - [[#中文乱码][中文乱码]]
    - [[#请求转发][请求转发]]
- [[#servletconfigservletcontext][ServletConfig、ServletContext]]
  - [[#servletconfig][ServletConfig]]
  - [[#servletcontext][ServletContext]]
- [[#ajax][AJAX]]
- [[#修改easymall][修改EasyMall]]
- [[#会话技术----cookie][会话技术 -- cookie]]
- [[#会话技术----session][会话技术 -- session]]
  - [[#cookie和session特点][cookie和session特点：]]
- [[#jsp][JSP]]
  - [[#1-概述与原理][1. 概述与原理]]
  - [[#2-jsp语法][2. JSP语法]]
  - [[#3-九大隐式对象][3. 九大隐式对象]]
  - [[#4-pagecontext详解][4. PageContext详解]]
  - [[#5-四大作用域][5. 四大作用域]]
  - [[#6-示例][6. 示例]]
  - [[#7-jsp标签技术][7. JSP标签技术]]
- [[#el表达式][EL表达式]]
- [[#jstl标签库][JSTL标签库]]
  - [[#1-概述-1][1. 概述]]
  - [[#2-在页面中引入jstl标签库][2. 在页面中引入JSTL标签库]]
- [[#javaee开发模式][javaEE开发模式]]
- [[#重构easymall项目][重构EasyMall项目]]
- [[#修改easymall页面][修改EasyMall页面]]
#+END_QUOTE

* Web概述
** B/S
Browser - Server
- 浏览器服务器模型 WEBQQ 网页游戏
     1. 优点：
        不需要下载客户端程序，使用浏览器可以直接访问，程序的升级操作是在服务器端进行的，浏览器只需要刷新页面就可以看到升级后的效果，不需要停机更新
     2. 缺点：
       画面不精美， 浏览器具有一定的局限性，页面的展示能力仍然是很差，所有的页面数据都需要从服务器实时的获取，所以对网速的依赖很高
** C/S
Client - Server
- 客户端服务器模型 QQ LOL
  1. 优点：
     画面精美，客户端可以任意的设计，页面的展示能力就可以很强，由于大量的资源都已经保存在了客户端，和服务器交互的仅仅是一些变化的数据，所以对网速的依赖很低
  2. 缺点：
     第一次使用时需要下载客户端程序，一旦程序需要升级操作，所有的客户端程序都需要升级，在有些场景中是不能被接受
** web概述
[[./Img/1.png]]
* HTML
[[./Img/HTML.png]]
** 1. HTML是什么
   - HTML（Hyper Text Mark-up Language）超文本标记语言，最基础的网页语言 W3C
   - HTML 不是一门编程语言，而是一门标记语言
   - HTML 是用标记（标签/元素）来描述网页内容的
   - HTML 是文档的一种
** 2. HTML的结构
   #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content-type" content="text/html"; charset="UTF-8" />
         <title></title>
       </HEAD>
       <BODY>
         体标签：存储组成页面的标签
       </BODY>
     </HTML>
   #+END_SRC
   | <!DOCTYPE HTML>                                                     | 用来指定当前页面所遵循的html的版本                    |
   | *<head></head>                                                      | 头部文件用来存放html页面的基本属性信息，优先被加载    |
   | *<body></body>                                                      | 体部分用来存放页面数据，是可见的页面内容              |
   | *<tittle></tittle>                                                  | 指定网页的标题                                        |
   | <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/> | 其中的charset的值用来指定浏览器用什么编码解析当前页面 |
   + 页面中的标签自上而下的加载。head中的内容会在body之前加载。
** 3. HTML语法
   - HTML标签分为开始标签和结束标签，如果标签内没有修饰的内容，开始标签和结束标签可以合并为一个自闭标签。如：<br/>换行；<hr/>在当前行画一条线
   - 标签通常都可以具有属性，属性与属性值用"="连接，属性的值可以用双引号、单引号引起来或者不用引号，一般会用双引号引起来。
     + 如果不生效查看页面代码使用的是否为英文双引号
   - HTML中对页面中代码需要做注释：<!--html的注释-->
   - HTML中多个连续的空白字符（制表符，空格，换行）默认会合并为一个空格来显示。
     + 如果非要输入空格，可以用转义字符来替换&nbsp;
     + 如果非要输入换行，可以用<br/>来代替
     + 转义字符
       |------+----------|
       |      | 转义字符 |
       | <    | &lt;     |
       | >    | &gt;     |
       | "    | &quot;   |
       | '    | &apos;   |
       | 空格 | &nbsp;   |
       |------+----------|
   #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content-Type" content="text/heml"; charset="UTF-8" />
         <title>我是第一个网页</title>
         头信息标签：存储优先加载的内容，比如HTML的配置信息
       </HEAD>
       <BODY>
         体标签：存储组成页面的标签
         <!-- HTML注释 -->
         <br/>
         我是一个换行标签
         <br/>
         我是一个换行标签
         <br/>
         我是一个空              格
         我是一个空&nbsp;&nbsp;&nbsp;格
         <br/>
         &lt;hr/&gt;是在页面中换一条线
         <hr/>
         双引号&quot;
         <br/>
         单引号&apos;
       </BODY>
     </HTML>
   #+END_SRC
   [[./Source Code/1.html]]
** 4. font标签
   用来指定文本的字体/大小/颜色
   + color：指定字体的颜色
     1. 值可以指定为颜色名，如：red
     2. 或十六进制的颜色，如：#000000
     3. 或rgb三原色值，如：rgb(255,255,255)；ie适用
   + 例：<font size=5 color=red>字体标签示例</font>

     #+BEGIN_SRC html
       <!DOCTYPE HTML>
       <HTML>
         <HEAD>
           <meta http-equiv="Content=text/html"; charset="UTF-8" />
           <title></title>
         </HEAD>
         <BODY>
           <!-- HTML标签属性 -->
           <font color='red' size=7>我是一个font</font>
         </BODY>
       </HTML>
     #+END_SRC
     [[./Source Code/3.html]]
** 5. 标题标签
   指定特定样式字体的一组标签
   + 属性
     align：指定文本的排列
     |---------+--------|
     | left    | 靠左   |
     | center  | 居中   |
     | right   | 靠右   |
     | justify | 自适应 |
     |---------+--------|
     #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content=text/html"; charset="UTF-8" />
         <title></title>
       </HEAD>
       <BODY>
         <!-- HTML标签属性 -->
         <font color='red' size=7>我是一个font</font>
         <hr/>
         <h1 align="center">一级标签</h1>
         <h2 align="right">二级标签</h2>
         <h3>三级标签</h3>
         <h4>四级标签</h4>
       </BODY>
     </HTML>
     #+END_SRC
     [[./Source Code/4.html]]
** 6. 列表标签
*** 无序列表
+ <ul>定义一个无序列表
+ <li>定义列表中的项
+ 属性
  type：定义项目符号的类型。disc(实心圆)、square(实心方块)、circle(空心圆)

#+BEGIN_SRC html
    <!DOCTYPE HTML>
    <HTML>
      <HEAD>
        <meta http-equiv="Content=text/html"; charset="UTF-8" />
        <title></title>
      </HEAD>
      <BODY>
        <!-- HTML标签属性 -->
        <font color='red' size=7>我是一个font</font>
        <hr/>
        <h1>列表标签</h1>
        <h2>无序列表</h2>
        <ul type="square">
          <li>spring</li>
          <li>summer</li>
          <li>auto</li>
          <li>winter</li>
        </ul>
      </BODY>
    </HTML>
#+END_SRC
[[./Source Code/5.html]]

*** 有序列表
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <HTML>
    <HEAD>
      <meta http-equiv="Content=text/html"; charset="UTF-8" />
      <title></title>
    </HEAD>
    <BODY>
      <!-- HTML标签属性 -->
      <font color='red' size=7>我是一个font</font>
      <hr/>
      <h1>列表标签</h1>
      <h2>有序列表</h2>
      <ol>
        <li>阿一</li>
        <li>阿二</li>
        <li>毛毛</li>
      </ol>
    </BODY>
  </HTML>
#+END_SRC
[[./Source Code/6.html]]
** 7. img标签 -- 图像标签
   - 必选属性：
     1. src:图片的路径
     2. alt:代替图像显示的文本
   - 可选属性
     1. width:宽度px%
     2. height:高度px%
     3. border:边框的宽度px
   #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content=text/html"; charset="UTF-8" />
         <title></title>
       </HEAD>
       <BODY>
         <!-- HTML标签属性 -->
         <h1>图片标签</h1>
         <img src="../image/5.jpg" alt="此处是一个美女" width="50px" height="50px"/>
       </BODY>
     </HTML>
   #+END_SRC
   [[./Source Code/7.html]]
** 8. 超链接 -- <a>锚
   #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content=text/html"; charset="UTF-8" />
         <title>锚标签 -- 文档内部跳转</title>
       </HEAD>
       <BODY>
         <a name="tag"></a>
         <h1>兰刚传</h1>
         <p>
           初出茅庐，什么都不会
         </p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>
         <p>开始修炼</p>

         <p>都学会了，刀枪剑戟斧钺钩叉</p>
         <a href="#tag">返回上层</a>
       </BODY>
     </HTML>
   #+END_SRC
   [[./Source Code/8.html]]
   #+BEGIN_SRC html
     <!DOCTYPE HTML>
     <HTML>
       <HEAD>
         <meta http-equiv="Content=text/html"; charset="UTF-8" />
         <title></title>
       </HEAD>
       <BODY>
         <h1>锚标签</h1>
         <a href="http://www.baidu.com" target="_blank">跳转到baidu</a>
       </BODY>
     </HTML>

   #+END_SRC
   [[./Source Code/9.html]]
   - 用于指向当前位置以外的资源
     1. 用于创建指向另外一个文档的超链接
     2. 用于在当前页面的不同位置之间进行跳转，利用id或name属性进行跳转
        一般在本页面中使用，当网页内容过长，定位标记会比拖动滚动条方便快捷。
        + 注：定位标记要和超链接结合使用才有效
        + 注：使用定位标记时一定在href值的开始加入#标记名
   - 重要属性
     + href：所指向资源的URL
     + name：指定锚的名字
     + target：指定浏览器打开目标URL的方式
       |--------+-------------------------|
       | _blank | 在新窗口中打开目标url   |
       | _self  | 在当前窗口中打开目标url |
       |--------+-------------------------|
** 9. 表格标签 -- <table>
   |---------+--------------------|
   | <table> | 定义一个HTML的表格 |
   | <tr>    | 定义表格中的行     |
   | <td>    | 定义表格中的单元格 |
   | <th>    | 定义表格中的表头   |
   |---------+--------------------|
   - table的重要属性
     |-------------+----------------------------|
     | border      | 边框宽度                   |
     | cellspacing | 单元格之间的空白举例       |
     | cellpadding | 边框与单元格内容之间的举例 |
     | bgcolor     | 背景颜色                   |
     | bordercolor | 边框颜色                   |
     | width       | 宽度                       |
     | align       | 对齐方式                   |
     |-------------+----------------------------|
   - tr的重要性
     |---------+----------|
     | align   | 对齐方式 |
     | bgcolor | 背景颜色 |
     |---------+----------|
   - th/td重要属性
     |-----------+----------------|
     | align     | 对齐方式       |
     | bgcolor   | 背景颜色       |
     | width     | 宽度           |
     | height    | 高度           |
     | colspan   | 可横跨的列数   |
     | rowspan   | 可竖跨的行数   |
     | <caption> | 定义表格的标题 |
     |-----------+----------------|

     #+BEGIN_SRC html
       <!DOCTYPE HTML>
       <HTML>
         <HEAD>
           <meta http-equiv="Content=text/html"; charset="UTF-8" />
           <title>表格标签</title>
         </HEAD>
         <BODY>
           <table border="2" cellspacing="0" cellpadding="5px" bgcolor="red" bordercolor="yellow" width="400px" align="center">
             <caption align="bottom">大数据</caption>
             <tr bgcolor="pink">
               <th>大数据</th>
               <th>UI</th>
               <th>Java</th>
             </tr>
             <tr>
               <td align="right" bgcolor="brown">1</td>
               <td align="center">2</td>
               <td >3</td>
             </tr>
             <tr>
               <td width="50px" height="500px">4</td>
               <td colspan="2">5</td>
               <td rowspan="2">6</td>
             </tr>
           </table>
         </BODY>
       </HTML>

     #+END_SRC
     [[./Source Code/10.html]]

* 表单
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <HTML>
    <HEAD>
      <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML";CHARSET="UTF-8" />
      <TITLE>表单标签</TITLE>
    </HEAD>
    <BODY>
      <FORM ACTION="HTTP://WWW.BAIDU.COM" METHOD="GET">
        姓名：<INPUT TYPE="TEXT" NAME="USERNAME" />
        密码：<INPUT TYPE="PASSWORD" NAME="PASSWORD"/>
        确认密码：<INPUT TYPE="PASSWORD" NAME="REPASSWORD"/>
        性别：<INPUT TYPE="RADIO" NAME="GENDER" VALUE="MALE"/>男
        <INPUT TYPE="RADIO" NAME="GENDER" VALUE="FEMALE"/>女
        爱好：<INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="EAT"/>吃
        </BR>
        <INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="DRINK"/>喝
        <INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="SLEEP"/>睡
        头像：<INPUT TYPE="FILE" NAME="HEAD" />
        <INPUT TYPE="BUTTON" VALUE="点击爆炸" ONCLICK=""/>
        <INPUT TYPE="SUBMIT" />
        <input type="reset" />

        <input type="image" src="../image/5.jpg" />
        <input type="hidden" value="123" />
      </form>
    </BODY>
  </HTML>
#+END_SRC
** 1. 表单
   - 浏览器向服务器发送数据的方式，有两种：
     1. 利用超链接向服务器发送数据 -- 请求参数
        在超链接的后面拼接上要发送的请求参数，链接和请求参数之间用?分割，参数名和参数值用=连接，多个参数之间用&分割，可以存在多个同名的参数
     2. 利用表单向服务器发送数据
        利用HTML中的<form>标签以及一些表单项标签，用户可以输入数据，通过提交表单发送数据给服务器
   - form标签
     1. 必须存在的属性
        action：指定表单发送的目标URL地址
     2. 可选的属性：
        method：指定以何钟方式发送表单
     3. http协议指定了7种提交方式，其中5种使用的极少，多数只用GET提交和POST提交
     4. 只有使用表单并且明确的指定提交方式为post时（也就是设置method="post""）才是POST提交，其他提交都是GET提交
     5. Get提交和POST提交的区别
        主要区别体现在数据传输方式的不相同
        + GET提交：请求参数会赋在地址栏后进行传输，这种方式发送的数据量有限，最大不超过1kb（或4kb），数据显示在地址栏，安全性差
        + POST提交：请求参数在底层流中传输，这种方式发送的数据量无限制，地址栏上看不到数据，比较安全
     6. 提交方式一共有7种：
        常用的有两种get和post
** 2. 表单中的项
#+BEGIN_SRC html
  <HTML>
    <HEAD>
      <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML";CHARSET="UTF-8" />
      <TITLE>表单标签</TITLE>
    </HEAD>
    <BODY>
      <FORM ACTION="HTTP://WWW.BAIDU.COM" METHOD="GET">
        姓名：<INPUT TYPE="TEXT" NAME="USERNAME" />
        密码：<INPUT TYPE="PASSWORD" NAME="PASSWORD"/>
        确认密码：<INPUT TYPE="PASSWORD" NAME="REPASSWORD"/>
        性别：<INPUT TYPE="RADIO" NAME="GENDER" VALUE="MALE"/>男
        <INPUT TYPE="RADIO" NAME="GENDER" VALUE="FEMALE"/>女
        爱好：<INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="EAT"/>吃
             </BR>
             <INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="DRINK"/>喝
             <INPUT TYPE="CHECKBOX" NAME="LIKE" VALUE="SLEEP"/>睡
             头像：<INPUT TYPE="FILE" NAME="HEAD" />
             <INPUT TYPE="BUTTON" VALUE="点击爆炸" ONCLICK=""/>
             <INPUT TYPE="SUBMIT" />
             <input type="reset" />

             <input type="image" src="../image/5.jpg" />
             <input type="hidden" value="123" />

             <select name="city">
               <option>---请选择---</option>
               <option>北京</option>
               <option>上海</option>
               <option>深圳</option>
               <option selected="selected" value="wuhan">武汉</option>
             </select>
             <textarea name="test" rows="10" cols="10">我是一个textarea</textarea>
      </form>
    </BODY>
  </HTML>


#+END_SRC
[[./SourceCode/12.html]]
表单中可以有多个输入项，输入项必须有name属性才可以被提交，如果输入项没有name属性，则表单在提交时会忽略它
1. <input>输入框
   1. 重要属性
      1. type属性
         | 文本框text     | 输入的文本信息直接显示在框中                                 |
         | 密码框password | 输入的文本以圆点或者星号的形式显示                           |
         | 单选框radio    | 进行单项的选择如性别选择，多个radio的name属性相同会被当作一  |
         |                | 来使用，必须yongcalue为选项指定提交的值                      |
         | 复选框checkbox | 进行多项选择，爱好的选择。多个checkbox具有相同的name属性时   |
         |                | 会被当作一组类使用必须用value为选项指定提交的值              |
         | 隐藏字段hidden | 如果有一些信息，不希望用户看见，又希望表单能够提交，就可以用 |
         |                | 隐藏字段隐含在表单中                                         |
         | 提交按钮submit | 实现表单提交操作的按钮，可以通过value属性指定按钮显示的文字  |
         | 重置按钮reset  | 重置表单到初始状态                                           |
         | 按钮button     | 普通按钮，没有任何功能，需要配合JavaScript为按钮指定具体的   |
         |                | 行为。可以用value属性指定按钮显示的文字                      |
         | 文件上传项file | 提供选择文件进行上传的功能                                   |
         | 图像image      | 利用一张图片替代提交按钮的功能，不常用                       |
      2. name属性
         表单中可以有多个输入项，输入项必须有name属性才可以被提交，如果输入项没有name属性，则表单在提交时会忽略它，另外name属性的值是可以重复的
      3. value属性：
         可以给input输入框设置一个初始值
      4. readonly属性：
         使当前输入项变为只读，不能修改，但是提交时仍会被提交
      5. disabled：
         使当前输入项不可用，不能修改值，也不会被提交
      6. size属性：
         指定当前输入框的宽度
      7. checked属性；
         指定单选框/复选框被选中
2. <textarea>文本域
   | 属性     |                          |
   | raws     | 指定文本域的行数（高度） |
   | cols     | 指定文本域的列数（宽度） |
   | readonly | 只读                     |
   | disabled | 禁用                     |
3. <select><option>
   | 属性   |                                                                               |
   | select | 提供下拉选择功能                                                              |
   | option | 下拉选框中的选项可以用value属性指定提交的值，如果不指定，将会提交标签内的文本 |

   | 重要属性 |                |
   | name     | 下拉列表的名称 |
   | disabled | 禁用下拉选框   |

   | 其他属性            |                                                                    |
   | size                | 设置下拉选项中可见选项的个数                                       |
   | multiple            | 是否支持多选                                                       |
   | selected="selected" | 下拉框默认选中                                                     |
   | value="wuhan"       | option中传递参数的值如果不设置value,则默认传递option标签中间的内容 |
* 注册表单练习
[[./image/img/zy.png]]
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <html>
    <head>
      <meta http-equiv="content-type" content="text/heml";charset="GBK">
      <title>注册表单练习</title>
    </head>
    <body>
      <form action="http://localhost:8090" method="post">
        <table align="center" border="1px" cellpadding="7px" cellspacing="0px" borderColor="#FF1493" bgcolor="#F5DEB3">
          <caption>
            <h1><font color="#FF1493">注册表单</font></h1>
          </caption>
          <tr>
            <td>用户名:</td>
            <td><input type="text" name="username" /></td>
          </tr>
          <tr>
            <td>密码:</td>
            <td><input type="password" name="password1 /"></td>
          </tr>
          <tr>
            <td>确认密码:</td>
            <td><input type="password" name="password2" /></td>
          </tr>
          <tr>
            <td>昵称:</td>
            <td><input type="text" name="nickname" /></td>
          </tr>
          <tr>
            <td>邮箱:</td>
            <td><input type="text" name="email" /></td>
          </tr>
          <tr>
            <td>头像:</td>
            <td><input type="file" name="fx" /></td>
          </tr>
          <tr>
            <td>性别:</td>
            <td>
              <input type="radio" name="gender" value="male" />男
              <input type="radio" name="gender" value="female" />女
            </td>
          </tr>
          <tr>
            <td>爱好:</td>
            <td>
              <input type="checkbox" name="like" value="eat" />吃饭
              <input type="checkbox" name="like" value="sleep" />睡觉
              <input type="checkbox" name="like" value="beat" />打豆豆
            </td>
          </tr>
          <tr>
            <td>
              <select name="city">
                <option value="bj">北京</option>
                <option value="sh">上海</option>
                <option value="gz">广州</option>
                <option value="sz">深圳</option>
                <option value="tl" selected="selected">铁岭</option>
              </select>
            </td>
          </tr>
          <tr>
            <td>自我介绍:</td>
            <td>
              <textarea name="desc" rows="5" cols="45">请描述个人描述!</textarea>
            </td>
          </tr>
          <tr>
            <td>验证码:</td>
            <td>
              <input type="text" name="valistr" />
              <img src="../image/img/2.gif" width="80px" height="18px" />
              <input type="button" value="点我换一张"/>
            </td>
          </tr>
          <tr>
            <td colspan="2" align="center">
              <input type="submit" value="提交"/>
              <input type="reset" value="重置"/>
            </td>
          </tr>
        </table>
      </form>
    </body>
  </html>
#+END_SRC
[[./SourceCode/13.html]]
* 注册表单联系2
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
        #center{
        width: 40%;
        height: 750px;
        /*border: 2px solid #FF1493;*//*边框*/
        margin: 0 auto;/*外边距，上下距离0px 左右距离自动居中*/
        text-align: center;/*文本居中*/
        }
        h1{
        color: #FF1493;
        }
        #register{
        width: 100%;/*相对于上一级div来说的*/
        height: 660px;
        border: 2px solid #FF1493;
        border-bottom: 0px;/*为了解决底部线条重合问题*/
        background-color: #F5DEB3;/*注册表单的背景色*/
        }
        .rows{
        width: 100%;
        height: 53px;/*每一个行的高度*/
        border-bottom: 2px solid #FF1493;/*每一行的底边显示*/
        line-height: 53px;/*行高垂直居中*/
        }
        .cols1{
        width: 30%;
        height: 53px;
        border-right: 2px solid #FF1493;
        float: left;/*div飘逸到左边*/
        }
        .cols2{
        width: 68%;
        height: 53px;
        /*border: 2px solid black;*//*做测试使用*/
        float: right;/*div飘逸到右边*/
        }
        textarea{
        resize: none;/*进制拖拽文本域的大小*/
        }
      </style>
    </head>
    <body>
      <div id="center">
        <h1>注册表单</h1>
        <div id="register">
          <form>
            <div class="rows">
              <div class="cols1">
                用户名:
              </div>
              <div class="cols2">
                <input type="text" name="username" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                密码:
              </div>
              <div class="cols2">
                <input type="password" name="password" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                确认密码:
              </div>
              <div class="cols2">
                <input type="password" name="password1" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                昵称:
              </div>
              <div class="cols2">
                <input type="text" name="name" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                邮箱:
              </div>
              <div class="cols2">
                <input type="text" name="email" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                上传头像:
              </div>
              <div class="cols2">
                <input type="file" name="file" />
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                性别:
              </div>
              <div class="cols2">
                <input type="radio" name="gender" value="male" />男
                <input type="radio" name="gender" value="female" />女
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                爱好:
              </div>
              <div class="cols2">
                <input type="checkbox" name="hobby" value="eat" />吃饭
                <input type="checkbox" name="hobby" value="sleep" />睡觉
                <input type="checkbox" name="hobby" value="play" />打豆豆
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                所在城市:
              </div>
              <div class="cols2">
                <select>
                  <option> 上海</option>
                  <option> 北京</option>
                  <option> 广州</option>
                </select>
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                自我介绍:
              </div>
              <div class="cols2">
                <textarea maxlength="50" cols="33" rows="3">最多写50个字符</textarea>
              </div>
            </div>
            <div class="rows">
              <div class="cols1">
                验证码:
              </div>
              <div class="cols2">
                <input type="text" name="check" />
                <img src="" alt="" />
                <input type="button" value="点我" />
              </div>
            </div>
            <div class="rows">
              <div class="cols3">
                <input type="submit" />
                <input type="reset" />
              </div>
            </div>
          </form>
        </div>
      </div>
    </body>
  </html>
#+END_SRC
[[./SourceCode/70.html]]
* CSS
[[./Img/CSS.png]]
** 1. 网页组织的两种常用方式
1. 表格套表格定义网页结构 -- 目前不只是主流，只在一些结构简单的页面中有所使用
2. DIV+CSS方式定义网页结构 -- 目前主流的网页开发方法，可以非常灵活的定义网页
** 2. 容器标签
本身没有任何特殊的能力，最主要的功能是用来包含其他标签组成一个整体
|----------------+----------+----------------------------------------------|
| 常用的容器标签 |          |                                              |
| <div>          | 块级元素 | 内容自动的开始一个新行                       |
| <span>         | 行内元素 | 多个行内元素不会要求独占一行                 |
| <p>            | 块级元素 | 声明一个段落，会在当前段落前后多出额外的空行 |
|----------------+----------+----------------------------------------------|
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta http="equiv=Content-type" content="text/html" charset="UTF-8" />
      <title>div盒子模型</title>
    </head>
    <body>
      <div>我是div</div>
      <div>我是div</div>
      <p>我是一个p标签</p>
      <p>我是一个p标签</p>
      <span>我是一个span</span>
      <span>我是一个span</span>
      <span>我是一个span</span>
    </body>
  </html>
#+END_SRC
** 3. CSS的概念
层叠样式表：实现了网页中数据和样式的分离，是网页结构更加明晰，解决了样式重复定义的问题，提高了开发效率和后期代码的可维护性，另外还增强了网页的没画能力。
** 4. CSS的四种引入方式
1. 方式一：通过style属性指定元素的样式
     #+BEGIN_SRC html
       <p style="background-color:#FF0000; color:#FFFFFF">
         p标签段落内容
       </p>
     #+END_SRC
2. 方式二：通过<style>定义样式，可以在html的<hesd>标签中定义<style>标签，在其中为当前页面设定样式
     #+BEGIN_SRC html
       <!DOCtype html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
           <title>div盒子模型+css层叠样式表</title>
           <style type="text/css">
             div{
             color:#DDAA11;
             background:#FFAADD;
             }
           </style>
         </head>
         <body>
           <div>我是第一个div</div>
           <div>我是第二个div</div>
         </body>
       </html>
     #+END_SRC
     [[./SourceCode/14.html]]
3. 方式三：引入外部样式文件，可以在html的<head>标签中定义<link>标签，引入外部的css文件来修饰当前页面
     #+BEGIN_SRC html
       <!DOCtype html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
           <title>div盒子模型+css层叠样式表</title>
           <!--<style type="text/css">
               div{
               color:#DDAA11;
               background:#FFAADD;
               }
               </style>-->
           <link href="./14.css" rel="stylesheet" />
         </head>
         <body>
           <div>我是第一个div</div>
           <div>我是第二个div</div>
         </body>
       </html>
     #+END_SRC
     [[./SourceCode/15.html]]
     #+BEGIN_SRC css
       div{
           color:#DDAA11;
           background:#FFAADD;
       }
     #+END_SRC
4. 方式四：可以通过@import url(xxx.css)在css的内部引入一个css文件钟定一的css样式片段。可以实现css代码的引入从而实现css代码的复用
     #+BEGIN_SRC html
       <!DOCtype html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
           <title>div盒子模型+css层叠样式表</title>
           <style type="text/css">
             @import url('./16.css');
           </style>
         </head>
         <body>
           <div>我是第一个div</div>
           <div>我是第二个div</div>
         </body>
       </html>
     #+END_SRC
     [[./SourceCode/16.html]]
     #+BEGIN_SRC css
       div{
           color:#DDAA11;
           background:#FFAADD;
       }
     #+END_SRC
** 5. CSS引入顺序
1. 样式引入的位置距离标签越近，就优先生效
2. 样式修改选择器书写越具体，越优先生效
** 6. CSS选择器的分类
*** 1. 基本选择器
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>css01-css选择器</title>
      <style>/*内嵌样式表*/

        /* 1.元素选择器：根据标签名，选择同一类型呃标签 */
        /* 语法格式：  标签名{}   */
        div{
        color:pink;
        background-color:yellow;
        }

        /* 2.id选择器：每一个html标签都一个id属性，id是标签的唯一表示 */
        /*  语法格式: #id属性的值{}  */
        #d1{
        color:while;
        background-color:black;
        }

        /* 3.class选择器:类选择器，根据标签中的class属性选择，可选多个 */
        /* 语法格式： .class属性的值{}  */
        .c1{
        color:red;
        }
      </style>
    </head>
    <body>
      <!--容器标签-->
      <div>我是一个块级元素，测试元素选择器</div>
      <div>我是一个块级元素，测试元素选择器</div>
      <div id="d1">我是一个块级元素，测试元素选择器</div>
      <div>我是一个块级元素，测试元素选择器</div>
      <div class="c1">我是一个块级元素，测试元素选择器</div>
      <div class="c1">我是一个块级元素，测试元素选择器</div>
      <div class="c1">我是一个块级元素，测试元素选择器</div>
    </body>
  </html>
#+END_SRC
1. 标签选择器(内嵌样式表)
   通过html标签的名字来选择标签的选择器；标签名{}
   #+BEGIN_SRC css
     div{
         color:red;
         }
         ,*{
         color:red;
         }
   #+END_SRC
2. 类选择器
   html的所有标签都具有一个通用的属性叫做class,通过它可以为标签指定类名，通过类选择器可以选择指定类名的元素；.类名{}
   #+BEGIN_SRC html
     <!DOCtype html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
         <title>div盒子模型+css层叠样式表</title>
         <style type="text/css">
           #div1{
           color:#ABC123;
           background:#123ABC;
           }
           .class1{
           color:#DDC123;
           background:#12FFBC;
           }
         </style>
       </head>
       <body>
         <div id="div1">我是第一个div</div>
         <div id="div2" class="class1">我是第二个div</div>
         <div>我是一个div</div>
         <span class="class1">我是一个span</span>
         <span>我是一个span</span>
         <span>我是一个span</span>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/18.html]]
3. id选择器
   html的所有标签都具有一个通用的属性叫做id，通过它可以为标签指定id，id必须在整个html中唯一，通过id选择器可以选择出指定id的元素；#id{}
   #+BEGIN_SRC html
     <!DOCtype html>
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
            <title>div盒子模型+css层叠样式表</title>
            <style type="text/css">
              @import url('./17.css');
              #div1{
              color:#ABC123;
              background:#123ABC;
              }
              #div2{
              color:#CDA124;
              background:#124CDA;
              }
            </style>
          </head>
          <body>
            <div id="div1">我是第一个div</div>
            <div id="div2">我是第二个div</div>
            <div>我是一个div</div>
          </body>
        </html>
   #+END_SRC
   [[./SourceCode/17.html]]
*** 2. 扩展选择器
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>css01-css选择器</title>
      <style>/*内嵌样式表*/
        /* 1.后代选择器：html标签由多层嵌套关系，不止有子节点，还有孙子节点等等 */
        div span{
        color:blue;
        }

        /* 2.子元素选择器：选择特定的标签的子节点，不包含孙子节点 */
        /* 语法格式： 父节点
        #d2>p{
        color:red;
        }

        /* 6.分组选择器：可以同时选择多个不同的标签，分成一组设置样式 */
        span,p{
        color:green;
        }

        /* 7.属性选择器 */
        /* 包含所有属性type的标签 */
        ,*[type]{
        background-color:yellow;
        }

        /* 可以选择指定标签的某个属性 */
        input[value]{
        background-color:green;
        }

        /* 可以选择指定标签的某个 属性='值'的形式 */
        input[name='password']{
        background-color:pink;
        }

        /* 可以选择指定标签的 多个 属性键值对 的形式 */
        input[type][name][value]{
        background-color:black;

        /* 8.伪元素选择器："伪" 指的是html已经为我们提供好的选择器*/
        a:link{
        /*未被点击的状态*/
        background-color:brown;
        }
        a:visited{
        /*被点击过的状态 */
        background-color:yellow;
        }
        a:hover{
        /* 鼠标停留的状态 */
        background-color:green;
        }
        a:active{
        /* 鼠标正在点击的状态 */
        bakcground-color:red;
        }
      </style>
    </head>
    <body>
      <!--页面的布局是嵌套的形式-->
      <div id="d2">
        测试后代选择器
        <div>这是子节点div
          <span>这是孙子节点span</span>
          <p>这是孙子子节点</p>
        </div>
        <span>这是子节点span</span>
        <p>这是子节点P</p>
      </div>
      <input type="text" name="username" value="测试"/>
      <input type="text" name="password" />
      <input type="text" name="email" />
      <a href="#">测试伪元素选择器</a>
    </body>
  </html>
#+END_SRC
1. 后代选择器
   选择父元素中的后代元素；父元素选择器 后代元素选择器{}
   #+BEGIN_SRC html
       <!DOCtype html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
           <title>div盒子模型+css层叠样式表</title>
           <style type="text/css">
             div span{
             color:#DDAA11;
             background:#FFAADD;
             }
           </style>
         </head>
         <body>
           <div id="div1">我是父级div
             <span class="test">我是div儿子span1</span>
             <span class="test">我是div儿子span2</span>
             <p>
               <span class="test">我是p儿子span3</span>
             </p>
           </div>
         </body>
       </html>
   #+END_SRC
   [[./SourceCode/19.html]]
2. 子元素选择器
   选择父元素中的子元素；父元素选择器>子元素的选择器{}
   #+BEGIN_SRC html
     <!DOCtype html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
         <title>div盒子模型+css层叠样式表</title>
         <style type="text/css">
           div>span{
           color:#DDAA11;
           background:#FFAADD;
           }
         </style>
       </head>
       <body>
         <div id="div1">我是父级div
           <span class="test">我是div儿子span1</span>
           <span class="test">我是div儿子span2</span>
           <p>
             <span class="test">我是p儿子span3</span>
           </p>
         </div>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/20.html]]
3. 相邻兄弟选择器
   选择选择器选择到的元素的相邻的兄弟元素;选择器+兄弟元素名{}
   #+BEGIN_SRC html
     <!DOCtype html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
         <title>div盒子模型+css层叠样式表</title>
         <style type="text/css">
           div+span{
           color:#DDAA11;
           background:#FFAADD;
           }
         </style>
       </head>
       <body>
         <div id="div1">我是父级div
           <div id="test" class="test">
             我是儿子div
           </div>
           <span class="test">我是div儿子span1</span>
           <span class="test">我是div儿子span2</span>
           <p>
             <span class="test">我是p儿子span3</span>
           </p>
         </div>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/21.html]]
4. 属性选择器
   选择具有指定属性，或指定属性的值等于指定值的选择器；
   1. 选择器[属性名]{}
      div[name]{}
      #+BEGIN_SRC html
        <!DOCtype html>
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
            <title>div盒子模型+css层叠样式表</title>
            <style type="text/css">
              div[name]{
              color:#DDAA11;
              background:#FFAADD;
              }
            </style>
          </head>
          <body>
            <div id="div1">我是父级div
              <div id="test" class="test" name="ll">
                我是儿子div
              </div>
              <span class="test">我是div儿子span1</span>
              <span class="test">我是div儿子span2</span>
              <p>
                <span class="test">我是p儿子span3</span>
              </p>
            </div>
            <div idi="test" class="test" name="ll">
              单独div
            </div>
          </body>
        </html>
      #+END_SRC
      [[./SourceCode/22.html]]
   2. 选择器[属性名='属性值']{}
      div[name='ll']{}
      #+BEGIN_SRC html
        <!DOCtype html>
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
            <title>div盒子模型+css层叠样式表</title>
            <style type="text/css">
              div[name='ll']{
              color:#DDAA11;
              background:#FFAADD;
              }
            </style>
          </head>
          <body>
            <div id="div1">我是父级div
              <div id="test" class="test" name="ll">
                我是儿子div
              </div>
              <span class="test">我是div儿子span1</span>
              <span class="test">我是div儿子span2</span>
              <p>
                <span class="test">我是p儿子span3</span>
              </p>
            </div>
            <div idi="test" class="test" name="ll">
              单独div
            </div>
          </body>
        </html>
      #+END_SRC
      [[./SourceCode/23.html]]
     如果希望把包含属性(tittile)的所有元素变为红色，可以写作：
     #+BEGIN_SRC html
       ,*[tittle]{color:red;}
     #+END_SRC
     与上面类似，可以只对有href属性的锚（a元素）应用样式：
     #+BEGIN_SRC html
       a[href][tittle]{color:red;}
     #+END_SRC
     为了将同时有href和title属性的HTML超链接的文本设置为红色，可以这样写：
     #+BEGIN_SRC html
       a[href][title]{color:red;}
     #+END_SRC
     假设只希望选择moons属性值为1的那些planet元素：
     #+BEGIN_SRC html
       planet[moons="1"]{color:red;}
     #+END_SRC
     上面的代码会把一下标记中的第二个元素编程红色，但第一个和第三个元素不受影响：
     #+BEGIN_SRC html
       <planet>Venus</planet>
       <planet moons="1">Earth</planet>
       <planet moons="2">Mars</planet>
     #+END_SRC
5. 分组选择器
   将多个选择器的选择结果进行一个或的操作;选择器1，选择器2...{}
   #+BEGIN_SRC html
     p,div{color:#FF0000;}
     <p>P标签显示段落</p>
     <div>DIV标签显示段落</div>
   #+END_SRC
   + 注：读个不同选择器要用都好分隔开
6. 伪元素选择器
   其实就在html中预先定义好的一些选择器，成为伪元素。是因为CSS的术语
   |----------+------------------------------------------|
   | :link    | 未点击的状态                             |
   | :visited | 被点击的状态                             |
   | :hover   | 鼠标移动到元素之上，但是仍然未点击的状态 |
   | :active  | 被鼠标点击着的状态                       |
   |----------+------------------------------------------|
   + 注：在不设置visited状态时active生效，否则会出现visited覆盖active效果
   #+BEGIN_SRC html
     <!DOCtype html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html" charset="UTF-8" />
         <title>div盒子模型+css层叠样式表</title>
         <style type="text/css">
           a:link{
           color:#DDAA11;
           background:#FFAADD;
           }
           a:visited{
           color:#AABB21;
           background:#FDFADD;
           }
           a:hover{
           color:#AFFB21;
           background:#AAFADD;
           }
           a:active{
           color:#BBFF21;
           background:#BBFADD;
           }
           div:hover{
           color:#AFFB21;
           background:#AAFADD;
           }
         </style>
       </head>
       <body>
         <div id="div1">我是父级div
           <div id="test" class="test" name="ll">
             我是儿子div
           </div>
           <span class="test">我是div儿子span1</span>
           <span class="test">我是div儿子span2</span>
           <p>
             <span class="test">我是p儿子span3</span>
           </p>
         </div>
         <div idi="test" class="test" name="ll">
           单独div
         </div>
         <a href="#">点击跳转</a>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/24.html]]
** 8. 拓展：CSS中的常用属性简介
[[./Img/day03js.png]]
* JavaScript
[[./Img/JS.png]]
** 1. js概述
#+BEGIN_SRC
  - 基于对象的一门语言
  - 一门独立的语言
  - 脚本语言，没有编译过程，解释运行
  - 主要应用在客户端，在服务器也有应用（node.js）
#+END_SRC
1. 特点：
   - 脚本语言没有编译过程
   - 基于对象
   - 弱类型
2. 特性
   - 交互性
   - 安全性
   - 跨平台性
** 2. JavaScript不得不说的历史
   - 和java的关系：语法十分相似，但毫无关系
   - 1995年5月，Netscape，LiveScript
   - 1995年12月，改名为JavaScript
   - 1996年8月，微软，Jscript
   - 1997-1999年，ECMA，ECMAScript，基于已有的JavaScript和Jscript，提出了标准的Script语法规则，JavaScript和Jscript都遵循这套标准
** 3. js和html的结合
1. 将javascript书写在head标签当中，书写格式如下：
2. 单独写一个js文件，然后导入
3. 写在页面的底部
- 浏览器中内置一个js解析器，会对浏览器加载到的js语句逐行执行，如果当前js语句没有添加分号，则js解析器会自动拼接上一个分号。注意：在这里建议大家手动添加分号，避免以后js语言和java语言相互切换使用的时候出现一些不必要的错误
- 浏览器中内置的js解析器会逐行执行js代码，如果代码中书写有错误，则会导致js代码失效，可能全部的js代码效果无法正常执行
- script标签必须要书写成一个标签对，不可以写成一个自闭标签。如果写成一个自闭标签则会导致标签中的js代码无法正常执行
** 4. js输出方式
#+BEGIN_SRC html
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="utf-8">
         <title>js02-输出语句</title>
         <!--四种输出写法-->
         <script>
           /* 1.弹窗打印 */
           alert(1);
           /* 2.浏览器的控制台打印：主要为了打桩测试 */
           console.log("hahaha");
           /* 3.向浏览器的body中输出信息 */
           document.write("您好，JavaScript");
         </script>
       </head>
       <body>
         <p id="p1">测试段落</p>
       </body>
       <script>
         /* 4.对html页面的某一个标签做修改 */
         document.getElementById("p1").innerText="这是新的内容";
       </script>
     </html>
#+END_SRC
** 5. js的语法-数据类型
JS中的数据类型分为基本数据类型和复杂数据类型
*** 1. 基本数据类型：共六种
数值类型（Number）、字符串（String）、布尔类型（Boolean）、undefined、null、Symbol
[[./SourceCode/71.html]]
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>js04-基本数据类型</title>
      <script>
        /* 1.Number类型：表示数值类型，并为数值之间的转换提供方法 */
        //1.1 常用的属性
        console.log(Number.MAX_VALUE);//最大值1.7976931348623157e+308
        console.log(Number.MIN_VALUE);//最小值5e-324
        console.log(Number.POSITIVE_INFINITY);//超出最大值是无穷大
        console.log(Number.NEGATIVE_INFINITY);//无穷小
        console.log(Number.NaN);//非数字

        //1.2 Number的精度问题
        var a = 0.9;
        var b = 0.999999999999;
        console.log(a);
        console.log(b);
        var a1 = 0.1;
        var a2 = 0.2;
        console.log(a1+a2);

        //1.3 Number类型的数值：底层默认都是浮点型
        var a3 = 10;
        var a4 = 10.0;
        console.log(typeof a3);
        console.log(typeof a4);

        //1.4 Number类型的八进制与十六进制
        var n1 = 0o377;//前缀是0或者0o
        var n2 = 0xddd;//十六进制前缀 0x

        //1.5 判断一个数值是否为数字
        console.log(isNaN(123));//false就是表示非数字，true表示数字
      </script>
      <script>
        /* 2.String类型：字符串 */
        //2.1 String的属性：length长度
        var s1 = "这是一个字符串";
        console.log(s1.length);
        //2.2 String的常用方法:indexOf
        console.log(s1.indexOf("个"));
        //2.2 字符串的索引:s1[],返回结果是下标对应的某一个字符
        console.log(s1[3]);
        //2.3 字符串的匹配：s1.match()
        // 返回结果如果匹配上返回匹配的结果对象
        // 如果没有匹配上返回匹配的结果null
        var s2 = s1.match("一");
        console.log(s2);
        //2.4 字符串的拆分,返回结果是一个数组
        console.log(s1.split(""));
        //2.5 字符串的大小写转化
        var s3 = "asdfgsafSDSDFSFF";
        console.log(s3.toLowerCase());//转为小写
        console.log(s3.toUpperCase());//转为大写

        /* 3.Boolean布尔类型：true、false */
        var b1 = true;
        var b2 = false;
        console.log(b1 && b2);//并且，结果false
        console.log(b1 || b2);//或者，结果true
        console.log(b1 | b2);//结果 1 表示就是true
        console.log(b1 & b2);//结果 0 表示就是false
      </script>
      <script>
        /* 4.Null:空类型，什么都没有 */
        var x1 = null;
        console.log(x1);
        /* 这里的方法IsNull是官方文档中提供的，如果位null返回true，如果不为null返回false */
        console.log(isNull(x1));
      </script>
      <script>
        /* 5.Undefined：未定义，声明变量时没有直接初始化 */
        var x2;
        console.log(x2);
      </script>
      <script>
        /* 6.Symbol类型：唯一性，数值不相等 */
        var m1 = Symbol(1);
        var m2 = Symbol(1);
        console.log(m1 === m2);//结果false
      </script>
    </head>
    <body>
    </body>
  </html>
#+END_SRC
1. Number数值型
   不仅是一个数据类型，还是js的一个包装对象
   - 数值类型中有如下几个特殊值
     + Infinity无穷大
     - Infinity负无穷大
   - NaN非数字，非数字非常特殊，和任何职都不相等，包括自身，即NaN==NaN的值为false。可以通过isNaN()判断某值是否为数字，true彪啊是确实为非数字的值，false表示为数字的值
   - 数值类型是基本数据类型，但JS本身提供了对应的包装对象Number，具有和数值处理相关的属性和方法
          - Number提供的属性
            + Number.MAX_VALUE可表示最大数字
            + Number.MIN_VALUE可表示的最小数字
            + Number.NaN非数字值
            + Number.POSITIVE_INFINITY正无穷大
            + Number.NEGATIVE_INFINITY负无穷大
   - 方法：查阅API文档
2. String字符串类型
   String表示的数据必须使用双引号包含，这样才表示当前值为一个字符串
   - Js中的字符串是基本数据类型，字符串常量必须用双引号引起来。
   - Js中提供了字符串的包装对象String，提供了字符串处理相关的属性和方法
     + String对象提供的属性
       length：字符串中字符数
     + String独享提供的方法：
       参考JS文档
   - 方法：查阅API文档
3. Boolean
   Boolean类型只有两个值，true、false。Js中提供布尔类型的包装对象Boolean，提供了布尔类型处理的相关属性和方法
4. Undefined
   Undefined类型只有一个值就是undefined，表示变量未定义，当一个变量未初始化时，值为undefined
5. Null
   类型中值包含null一个值，这个值表示一个不存在值。常用作返回值使用。
6. Symbol
   唯一，不与任何其他的值相等
*** 2. 复杂数据类型
对象、数组、函数
***** 1. js语法--函数
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js05-函数</title>
      <script>

          /*js中的复杂数据类型：function*/
          /*1.定义函数的语法格式：三种 ,第一种和第三种必须掌握！！！！第二种了解 */
          //1.1 普通定义方式
          function f1() {
              console.log("无参的函数");
          }
          function f2(a,b,x){
              console.log(x);
              return a-b;
          }
          //1.2 动态的定义一个函数
          /*小括号中可以有N个参数，但是前N-1个是形参，最后一个是方法体  */
          var f3 = new Function("a","b","return a-b");
          console.log(f3);
          //1.3 匿名函数的定义方式
          var f4 = function(a,b){
              return a-b;
          }

          /*2.函数的调用*/
          f1();
          console.log(f2(1,2,3));
          console.log(f3(4,5));
          console.log(f4(6,7));
          /*3.函数的调用：扩展*/
          f1(1,2,3,4);/*参数列表可以随意定义长度，参数的个数不确定*/
          f2(1,2);/*参数列表如果参数较少时，其他参数是undefined未定义的*/
          console.log(typeof f4);//打印函数的类型

      </script>
  </head>
  <body>

  </body>
  </html>
#+END_SRC
1. js中的函数是一堆可执行代码的合集。在需要的时候可以通过函数的名字调用其中的代码。函数可以理解为一种特殊的对象，其实本质上就是一段可执行的字符串
2.  在函数中哟一个隐藏的属性arguments，其中保存的是用户输入的全部参数，可以通过arguments.length获取用户输入参数的长度。如果用户输入的参数数量大于函数现有的参数长度，多余的参数没有被抛弃，利用arguments依然可以获取用户输入全部参数。如果用户的输入参数数量小于函数现有的参数长度，则缺少的参数会使用undefined来赋值，通过arguments也可以获取用户传入的参数。
3. 在js的函数中可以认为函数是一个特殊的变量，这个变量可以作为参数使用，可以作为方法使用。作为参数使用时，直接书写方法名即可，这时书写的方法名就是代表当前方法的变量。作为方法使用，则需要在方法名之后添加上一对小括号，这时这个函数就会执行函数中的函数体。
4. 函数的定义
   + 方法一：普通方法定义函数
     #+BEGIN_SRC js
       function fun1(参数列表){
         函数体
       }
     #+END_SRC
     #+BEGIN_SRC html
       <!DOCTYPE html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
           <title>js语句</title>
           <script type="text/javascript">
             function mx(a,b){
                 //return a+b;
                 for(var i=0;i<arguments.length;i++){
                     console.log(arguments[i]);
                 }
             }

             /*console.log(mx(1,2));
             //在参数列表输入比定义函数时更多的参数，函数依然可以正常执行
             console.log(mx(1,2,3));
             console.log(mx(1));*/
             mx(1,2);
           </script>
         </head>
         <body>
         </body>
       </html>
     #+END_SRC
   + 方法二：动态函数
     动态函数定义方式，参数列表中先书写全部参数，最后一个参数需要书写方法体。（动态函数最后一个参数位置是填写方法体的位置）
     #+BEGIN_SRC js
       var fun2 = nuew Function("a","b","方法体");
       fun2("x","y")
       var fun2x = fun1();
       fun2x("t","u");
     #+END_SRC
     #+BEGIN_SRC html
       <!DOCTYPE html>
       <html>
         <head>
           <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
           <title>js语句</title>
           <script type="text/javascript">
             var mx = new Function("a","b","return a+b");
             console.log(mx(2,3));
           </script>
         </head>
         <body>
         </body>
       </html>
     #+END_SRC
     [[./SourceCode/37.html]]
   + 方法三：匿名函数定义
     #+BEGIN_SRC js
         var fun3 = function(参数列表){
           方法体
         }
         fun3();
         #+END_SRC
     #+BEGIN_SRC html
         <!DOCTYPE html>
         <html>
           <head>
             <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
             <title>js语句</title>
             <script type="text/javascript">
               var mx = function(a,b){
               return a+b;
               }
               console.log(mx(3,4));
             </script>
           </head>
           <body>
           </body>
         </html>

         #+END_SRC
     [[./SourceCode/38.html]]
5. 案例
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js函数</title>
         <script type="text/javascript">
           function eat(food){
               if("羊肉串"==food){
                   return "烤"+food;
               }else if("煎饼"==food){
                   return "摊"+food;
               }
           }
           console.log(eat("煎饼"));
         </script>
       </head>
       <body>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/39.html]]
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js函数</title>
         <script type="text/javascript">
           function meau(e,food){
             food = e(food);
             return "吃"+food;
           }
           function eat(food){
               if("羊肉串"==food){
                   return "烤"+food;
               }else if("煎饼"==food){
                   return "摊"+food;
               }
           }
           console.log(meau(eat,"羊肉串"));
         </script>
       </head>
       <body>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/40.html]]
***** 2. js语法--数组
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js04-数组</title>
      <script>
          /*js中的复杂数据类型：数组*/
          /*1.数组的定义：4种方式*/
          var a1 = new Array();//定义一个空的数组
          var a2 = new Array(3);//定义长度为3的数组
          var a3 = new Array("123",true,3.14);//数组的初始化赋值
          var a4 = [1,2,true,"qwer"];//直接量定义数组
          /*2.数组的存取操作*/
          a2[0]="1";
          a2[1]="2";
          a2[300]="3";/*js的数组是自动的扩容的，扩容时不会出现数组越界*/
          console.log(a2);
          console.log(a2[300]);/*数组取数时，根据下标取值*/
          console.log(a2[400]);/*当下标超出长度时，不会报错，但是返回值是undefined未定义*/
          /*3.数组的push方法：添加元素*/
          a4.push("测试");
          console.log(a4);
          /*4.数组的删除元素的方法： pop()  shift() */
          console.log(a4.pop());//删除并返回数组的最后一个元素
          console.log(a4);
          console.log(a4.shift());//删除并返回数组的第一个元素
          console.log(a4);
          /*5.数组的排序：sort()方法*/
          var a5 = [1,2,3,10,100,33,22];
          console.log(a5.sort());//默认按照字符的字典顺序从小到大排列
          var a6 = a5.sort(function (a,b) { //内部是一个冒泡算法
              return a-b; // a-b的一个结果：如果是负数，a与b不交换
                          //如果是正数，a与b交换
          });
          console.log(a6);
      </script>
  </head>
  <body>

  </body>
  </html>
#+END_SRC
js中的数组，本质上就是一个用中括号括起来用逗号分割内容的字符串
#+BEGIN_SRC js
  var arr = new Array();//定义一个长度为0的空数组
  var arr = new Array(3);//定义一个长度为3的数组
  var arr = new Array(1,2,4,6,8);//定义具有指定初始值的数组
  var arr = [2,3,5,7];//数组直接量定义数组
#+END_SRC
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
      <title>js数组</title>
      <script type="text/javascript">
        var arr = new Array();
        arr[0] = 1;
        arr[0] = 1;
        arr[1] = 2;
        arr[999] = 3;
        console.log(arr);
      </script>
    </head>
    <body>
    </body>
  </html>
    #+END_SRC
[[./SourceCode/41.html]]
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
      <title>js数组</title>
      <script type="text/javascript">
        var arr = new Array(3);
        arr[0]=1;
        arr[1]=2;
        arr[2]="aaa";
        arr[999]=true;
        console.log(arr);
      </script>
    </head>
    <body>
    </body>
  </html>
    #+END_SRC
[[./SourceCode/42.html]]
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
      <title>js数组</title>
      <script type="text/javascript">
        var arr = new Array(1,"a",true,new Object());
        console.log(arr);
        arr[4]="b";
        console.log(arr);
      </script>
    </head>
    <body>
    </body>
  </html>
    #+END_SRC
[[./SourceCode/43.html]]
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
      <title>js数组</title>
      <script type="text/javascript">
        var arr = [2,"c",true,false,new Object()];
        console.log(arr);
        arr[999]=0;
        console.log(arr);
        arr.push(2);
        console.log(arr);
        var r = arr.pop();
        console.log(r);
        console.log(arr);
        var s = arr.shift();
        console.log(s);
        console.log(arr);
        for(var i=0;i<arr.length;i++){
          console.log(arr[i]);
        }
      </script>
    </head>
    <body>
    </body>
  </html>
    #+END_SRC
1. 特点：
   1. 数组存储的元素类型是任意的
   2. 长度可以是任意的
2. 案例：
   1. 添加元素push()
   2. 删除最后一个元素pop()
   3. 删除第一个元素shift()
   4. 遍历打印数组
***** 3. js语法--对象
****** 1. js的内置对象
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js06-内置对象</title>
      <script>
          /*内置对象：js已经为我们提供好的对象  */
          /*已经学过的：String  Number  Boolean
          ,*             Array  Function */
          /*需要了解的常用的四种：Math对象  Global全局对象
                                  Date日期对象   RegExp正则对象  */
          /*1.Math对象：常用属性和方法，其他方法参考JS的API文档*/
          console.log(Math.PI);
          console.log(Math.E);
          console.log(Math.round(3.14));//四舍五入
          console.log(Math.pow(2,4));//2的4次方
          console.log(Math.random());//随机数[0,1)
          /*2.Global全局对象：主要是提供全局方法，直接使用即可  */
          console.log(isNaN(123));
          console.log(parseFloat("3.154"));//把字符串转为浮点数
          console.log(parseInt("123"));//把字符串转为整数的十进制
          /*3.Date日期对象*/
          var d1 = new Date();//日期的创建
          var d2 = new Date("2010/01/01");//把字符串转为日期
          //注意：字符串的类型 不能随意定义，一般: 2010-01-01  2010/01/01
          console.log(d1.getDate());//返回月份的第几天
          console.log(d1.getDay())//星期的第几天
          console.log(d1.getFullYear());//返回本地时间的年份
          /*4.RegExp 正则表达式：作用匹配 特定格式的 字符串  */
          //比如：邮箱地址：123SAFD@qq.com.cn
          var r1 = /^\w+@\w+(\.\w+)+$/;
          console.log(r1.test("123SAFD@qq.com.cn"));
      </script>
  </head>
  <body>
  </body>
  </html>
#+END_SRC

#+BEGIN_SRC html
        <!DOCTYPE html>
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
            <title>js对象</title>
            <script type="text/javascript">
              console.log(Math.random()*10);
              console.log(Math.floor(3.4));
              console.log(Math.ceil(3.4));
              console.log(Math.round(3.4));
              var date = new Date();
              console.log(date.toLocaleString());
              console.log(parseInt("123"));
              //解释执行js语句
              eval(alert("aaa"));
              //RegExp正则对象
              var reg = /^\w+@\w+(\.\w+)+$/;
              var reg1 = new RegExp("\\w+@\\w+(\\.\\w+)+");
              var email = "lishuai@tedu.cn";
              console.log(reg.test(email));
              console.log(reg1.test(email));
            </script>
          </head>
          <body>
          </body>
        </html>
      #+END_SRC
[[./SourceCode/45.html]]
1. String--基本数据类型，字符串类型的包装对象
2. Boolean--基本数据类型，布尔类型的包装对象
3. Number--基本数据类型，数值类型的包装对象
4. Array--数组类型的包装对象
5. Math--数据对象，封装了很多数学常量和数学方法
6. Date--日期时间对象，封装了很多和日期实现相关的方法
7. Global--全局对象，js中有一些方法和属性经常使用，但归到哪个对象上都不合适，所以js中有一个Global对象整合了这些方法和属性。Global中定义的方法和属性特点是属于全局，可以直接使用
   + 思考：parseInt("123abc123");打印结果
8. RegExp--正则对象，保存有关正则表达式模式匹配信息的固有全局对象。Partten邮箱正则
****** 2. 自定义对象
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js07-自定义对象</title>
      <script>
          /* 创建自定义对象基本步骤：
             1.创建一个构造函数
             2.添加属性和方法
             3.使用new关键字创建对象
          ,* */
          /*1.构造函数就是一个普通定义的function*/
          //1.1 无参构造，没有属性和方法
          function Person(){

          }
          //创建对象
          var p = new Person();
          console.log(p);
          //添加属性
          p.name="小明";
          p.age=19;
          //添加方法
          p.say = function(){
              alert("您好");
          }
          //调用属性和方法
          console.log(p.age);
          console.log(p["name"]);//特别注意：["key"]
          p.say();

          //2.有参构造函数
          function Person(name,age) {
              this.age = age;
              this.name = name;
              this.say = function(){
                  alert("大家好");
              }
          }
          var p = new Person("翠花",18);
          console.log(p.name);
          console.log(p["age"]);
          p.say();
          //3.直接量定义对象
          console.log(p);
          //语法格式：{key1:value1,key2:value2,key3:value3......}
          var p = {
              name:"小黄",
              age:19,
              say:function () {
                  alert("我是小黄");
              }
          };
          console.log(p);
      </script>
  </head>
  <body>

  </body>
  </html>
#+END_SRC
js中对象的本质就是一个大括号，其中包含任意多个键值对，键值对直接使用逗号隔开，这种形式组成的字符串就是对象。所以对象的本质也是一个字符串
构造函数模拟了Java中类的功能，js中的对象可以动态增加/删除属性和函数。--js对象的本质就是用大括号起来的键值的集合，本质是一段字符串，有点类似于java中的map。
1. 方法一：构造函数创建对象1
        #+BEGIN_SRC js
          function Person(){}
          var p = new Person();
          p.name = "zhangfei";
          p.age = 19;
          p.say = function(){alert(this.name+"say...")};
          alert(p.name);
          alert(p["age"]);
          p.say();
          //删除一个属性
          delete p.name
          console.log(p);
          //删除一个函数
          delete p.say
          console.log(p);
        #+END_SRC
        #+BEGIN_SRC html
          <!DOCTYPE html>
          <html>
            <head>
              <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
              <title>js对象</title>
              <script type="text/javascript">
                function Person(){
                }
                var p = new Person();
                p.name="ls";
                p.age=18;
                p.gender="male";
                p.say = function(){
                  return this.name+"say...";
                }
                console.log(p);
                console.log(p.say());
                delete p.name;
                console.log(p);
              </script>
            </head>
            <body>
            </body>
          </html>
        #+END_SRC
        [[./SourceCode/46.html]]
2. 方法二：构造函数构造对象2
        #+BEGIN_SRC js
          function Person(name,age){
            this.name = name;
            this.age = age;
            this.say = function(){alert(this.name+"say....")}
          }
          var p = new Person("guanyu",20);
          alert(p.name);
          alert(p["age"]);
          p.say();
        #+END_SRC

        #+BEGIN_SRC html
          <!DOCTYPE html>
          <html>
            <head>
              <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
              <title>js对象</title>
              <script type="text/javascript">
                function Person(name,age){
                  this.name=name;
                  this.age=age;
                }
                var p = new Person("ls",18);
                p.addr="bj";
                delete p.name;
                console.log(p);
              </script>
            </head>
            <body>
            </body>
          </html>
        #+END_SRC
        [[./SourceCode/47.html]]
3. 方法三：对象直接量定义对象
        #+BEGIN_SRC js
          var p = {name:"liubei",age:19,sleep:function(){alert(this.name+"sleep....")}};
          alert(p.name);
          alert(p["name"]);
          p.sleep();

        #+END_SRC

        #+BEGIN_SRC html
          <!DOCTYPE html>
          <html>
            <head>
              <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
              <title>js对象</title>
              <script type="text/javascript">
                function Person(name,age){
                  this.name=name;
                  this.age=age;
                }
                var p = new Person("ls",18);
                p.addr="bj";
                delete p.name;
                console.log(p);
              </script>
            </head>
            <body>
            </body>
          </html>
        #+END_SRC
        [[./SourceCode/48.html]]

        #+BEGIN_SRC html
          <!DOCTYPE html>
          <html>
            <head>
              <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
              <title>js对象</title>
              <script type="text/javascript">
                var data = {
                  name:"pq",
                  age:18,
                  addr:"bj",
                  girlfriends:[
                    {name:"dc",age:16,job:"sbd"},
                    {name:"xs",age:18,job:"sdfg"}
                  ]
                }
                console.log(data["girlfriends"][1]["job"]);
              </script>
            </head>
            <body>
            </body>
          </html>
        #+END_SRC
        [[./SourceCode/49.html]]
4. 对象操作
   1. with语句：with语句定义了某个对象的作用域，在该域中可以直接调用该对象的成员
         #+BEGIN_SRC js
           var p = {name:"liubei",age:19,sleep:function(){alert(this.name+"sleep....")}};
           with(p){
             alert(name);
             alert(age);
             sleep();
           }
         #+END_SRC
   2. for...in语句：用来遍历对象的所有属性的名称
         #+BEGIN_SRC js
           var p = {name:"liubei",age:19,sleep:function(){alert(this.name+"sleep....")}};
           for(var x in p){
             alert(x);
           }
         #+END_SRC
   3. delete语句：删除对象的属性
         #+BEGIN_SRC js
           var p = {name:"liubei",age:19}
           p.addr = "peixian";
           alert(p.addr);
           delete p.addr;
           alert(p.addr);
         #+END_SRC
*** 3. 数据类型的自动转化
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <script>
        /*问题：小括号中的参数如何自动转换的*/
        /*答案：js内部的函数在执行时，
        会根据函数的参数以及函数的定义，
        自动的尝试去转换为我们期望的类型 */
        console.log(isNaN(1));//false 是数字
        console.log(isNaN("1"));//false -->证明自动转换了
        console.log(isNaN("123sfd")); // true --> 自动转换失败
        console.log(isNaN(" "));//空格 --> 自动转为0  再判断是否为NaN
        console.log(isNaN(null));//null --> 自动转为0  再判断是否为NaN
        console.log(isNaN(true));//true --> 1

        /*通过js的函数进行强制类型转换*/
        /*1.将数字转换为非数字*/
        var a1 = 10;
        console.log(String(a1));
        console.log(a1.toString());
        /*2.将非数字转换为数字：主要使用Number() */
        var a2 = "          ";/*多个空格转为数字时，都成了0*/
        var a3 = "123qweqwe";/*如果是一个非数字的字符串，会编程NaN，表示非数字*/
        var a4 = false;/*true --> 1   false --> 0*/
        var a5 = new Date();/* 结果1575339572824 ：日期的毫秒数  */
        console.log(Number(a2));
        console.log(Number(a3));
        console.log(Number(a4));
        console.log(Number(a5));
      </script>
    </head>
    <body>
    </body>
  </html>
#+END_SRC
[[./Img/3.png]]
js在需要时会自动对类型进行转换，转换的规则：
1. 数字：
   可以在需要时转换为对应的字符串形式，0会转换为false，其他数字会转换为true，在需要对象时可以自动转换为Number对象
2. 字符串：
   可以在需要时转换为对应的数值，需要注意当数值和字符串进行加法运算时，会处理为字符串的拼接，所以需要通过parseInt或parseFolat将字符串强制转换为数值类型参与运算，非空字符串转换为true，空字符串转换为false，需要对象时自动转换为String对象
3. 布尔类型：
   true转换为1，false转换为0，转换为字符串的true和false转换为boolean对象
4. 对象类型：
   如果位null则转成字符串null，如果为null转换为false
** 6. Js语法--运算符
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js06-运算符</title>
      <script>
          /*1.算术运算符： + - * /  %  -- ++   */
          /*2.逻辑运算符： ||  &&  !   */
          /*3.位运算符： |  &   */
          /*4.关系运算符：>  <  == ===  <=  >=  */
          var a = 10;
          /* if(a=20)  先进行赋值操作，那么a变成了20*/
          /* if (a=20)  相当于  if (20)    */
          /*原因  js中如果判断的值是 0或者null，代表的就是false
          ,*           如果是 非0 或者  非null，代表的就是true */
          if (a = 20) {
              console.log(a);
          } else {
              console.log("不相等");
          }
          /*5.赋值运算符：+= -= *= /=  %=    */
          /*6.三目运算符*/
          var y = 10>20? "大":"小";
          console.log(y);
      </script>
  </head>
  <body>
  </body>
  </html>
#+END_SRC
JavaScript中的运算符和Java大致相同,只是运算过程中需要注意几点：
#+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js语法运算符</title>
         <script type="text/javascript">
           console.log(1+2);
           console.log(2-1);//1
           console.log(21-"1");
           console.log(3/2);//1.5
           console.log(3/2*1000);//1500
           //console.log(2.3+1.3);//3.599999999999996
           var x = 3;
           var y = "123";
           var z = false;
           typeof(x);//number
           typeof(y);//string
           typeof(z);//boolean
         </script>
       </head>
       <body>
       </body>
     </html>
#+END_SRC
[[./SourceCode/32.html]]
- 加好对于字符串是连接符
- &&||是逻辑运算符&|是位运算符
- 也支持三元运算符?:
  2+3>5?console.log("aaa"):console.log("bbb")
- 特殊运算符typeof:返回一个操作表达式的数据类型的字符串
** 7. 定义变量
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js05-变量的定义和使用</title>
      <script>
          var a = 0;
          var b =1,c = 2;
          /* 如果变量没有定义时，直接使用:写代码时不会报错，执行是报错 */
          var x;
          console.log(x);
          /* 如果两个变量重名了，那么js中会：把上一个变量覆盖掉 */
          var a = 1;
          console.log(a);
      </script>
  </head>
  <body>
  </body>
  </html>
#+END_SRC
1. 使用关键字var来定义变量
   使用var定义的变量是没有数据类型的,Js中有数据类型，但是Js的引用不区分类型的，所以称JS为弱类型，即一个引用可以先指向数字类型，后在指向对象类型，如下的代码是没有问题的
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js语句</title>
         <script type="text/javascript">
           var a = 1;
           a = "abc";
           a = true;
           a = new Object();
           console.log(a);
         </script>
       </head>
       <body>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/34.html]]
2. 局部变量和全局变量
   JS中定义对象的时候可以不使用var来定义，这样定义的变量将成为全局变量，在任何一个位置都可以使用
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js语句</title>
         <script type="text/javascript">
           function mx(){
           x = 4;
           }
           mx();
           console.log(x);
         </script>
       </head>
       <body>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/35.html]]
   + 全局变量
     x = 4;
   + 局部变量
     var x = 4;
** 8. js语法--语句
如果在if判断中只有一个等号，则，执行的操作为，先赋值，再运算的操作。操作过程为：先将x赋值为4，再判断if(x)，也就是if(4),即if(true),所以只会打印为true的部分代码。
*** 1. if语句：
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>js01-分支结构</title>
      <script>
        /*分支结构的语法 与  java里面的完全一样*/
        var a = 10;
        if (a>10) {
        alert("大于10");
        } else if (a==10) {
        alert("等于10");
        } else {
        alert("小于10");
        }
        var b = "周一";
        switch (b) {
        case "周一":
        console.log("1");
        break;
        default:console.log("默认");
        }
      </script>
    </head>
    <body>
    </body>
  </html>
#+END_SRC
var x = 3;
+ 情况一：if(x==4)//可以进行比较运算
+ 情况二：if(x=4)//可以进行赋值运算，而且可以同样进行判断，不报错
  原因；因为在js中0或者null就是false，非0或者非null就是true。if(x=4)是先将x赋值为4，然后对值为4的x进行判断，4会被认为是true，所以结果是true。
  + 可以通过if(4==y)来解决该问题，因为4=y不会进行判断，而是会报错
*** 2. switch case
  与java 中使用方式一致
*** 3. while、dowhile、for
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js02-循环结构</title>
      <script>
          /*1.for循环*/
          for (var i = 0;i<10;i++) {
              console.log(i);
          }
          /*2.while循环*/
          var a = 1;
          while(a < 10){
              a++;
          }
          /*3.do..while循环*/
          do {
              a++;
          } while(a <20);
          /*4.for/in循环：与java的foreach完全不同   */
          /*因为js是弱类型的，所以数组定义时也是弱类型，其中的元素也是弱类型的*/
          var arr = [1,"2",true,false,3.4,null];//js的数组使用中括号
          for (var i in arr) {
              /*特别注意，输出的i是 数组中的index下标*/
              console.log(i);
          }
      </script>
  </head>
  <body>
  </body>
  </html>
#+END_SRC
不支持增强for循环，与java中使用方式一致
** 9. JSON
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>js08-json对象</title>
      <script>
          /*1.json本质上就是一段字符串，解析时特别方便  {}的形式  */
          /*2.json格式的数据：是目前web数据传输格式的最流行的方式*/
          var data = {
              name:"李白",
              age:10,
              wife:[ //数组中每一个元素都是一个对象
                  {name:"张飞1",age:10,job:["打架1","喝酒1"]},
                  {name:"张飞2",age:11,job:["打架2","喝酒2"]},
                  {name:"张飞3",age:12,job:["打架3","喝酒3"]}
              ]
          };
          //调用json对象，输出其中的某个字段
          console.log(data["wife"][1]["job"][0]);
      </script>
  </head>
  <body>

  </body>
  </html>
#+END_SRC
JSON本质上就是一段字符串，能够保存较复杂关系的数据，具有良好的数据保存格式，又极为轻量，加之多种代码平台都支持对字符串的处理，所以我们可以使用JSON字符串进行数据的传入，甚至跨平台传输
#+BEGIN_SRC js
      data = {
        name:"zs",
        age:19,
        addr:["bj,sh,gz"],
        wife:[
          {name:"苏权",age:40,job:["教主夫人","大大老婆"]},
          {name:"建宁",age:20,job:["公主","小老婆"]},
        ]
      }
#+END_SRC
查看当前JSON中第二个wife的工作data["wife"][1]["job"];
* DHTML-动态html
** 1. DHTML概述
- DHTML将浏览器加载html文档中的所有的内容当做js对象来处理，最终就组成了一颗由js对象组成的对象树
- 通过操作代表html元素的js对象来操作html中的元素
- 通过操作js对象组成树来操作html文档的结构。从而实现了html和js的结合，实现了可以通过js来操作html
- DHTML可以分为由BOM(Browser Object Model)和DOM(Document Object Model)两个部分组成
- 可以对节点进行增删改的操作
[[./Img/67.png]]
** 2. BOM和DOM
[[./Img/2.png]]
** 3. BOM--浏览器对象模型
bom--browser object model
1. window：代表一个浏览器窗口的对象
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>window窗口对象</title>
         <script>

             //向div中输出一句话
             document.getElementById("d1").innerText="123";


             /*1.BOM对象模型中，顶级的对象：window对象
             ,* window对象指的是浏览器的窗口！！！*/
             //1.1  window.onload指的是  页面加载完毕后，执行的代码，onload触发的事件
             window.onload = function() {
                 //向div中输出一句话
                 document.getElementById("d1").innerText="123";
             }
             //1.2  window.onblur指的是   鼠标移出页面，window对象失去焦点时触发
             window.onblur = function(){
                 document.getElementById("d1").innerText="页面失去焦点了";
             }
             //1.3 window.onfocus指的是  鼠标进入页面，焦点在当前window窗口中\
             window.onfocus = function(){
                 document.getElementById("d1").innerText="页面获取焦点了";
             }
             //1.4 window的prompt的弹出对话框，带有提示信息和输入框
            /* var password = window.prompt("请输入您的密码");
             alert(password);
             if (password == "123") {
                 alert("登录成功");
             } else {
                 alert("登录失败");
             }*/
             //1.5 window的confirm确认对话框，带有提示信息和确认/取消按钮
             var check = window.confirm("确定要删除吗？");
             if (check) {//true
                 alert("删除成功");
             } else {//false
                 alert("取消删除");
             }
         </script>
     </head>
     <body>
     <div id="d1"></div>
     </body>
     </html>
   #+END_SRC
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>bom02-window子对象</title>
         <script>

             /*1. history历史对象*/
             function demo1(){
                 //前进的方式：forward
                 //window.history.forward();
                 //前进的方法：go
                 window.history.go(1);//1表示前进
             }
             function demo2(){
                 //后退的方法：back
                 //window.history.back();
                 //后退的方法：go
                 window.history.go(-1);
             }

             /*2.location对象：包含当前的URL的信息*/
             /*
             ,* hash 设置或获取 href 属性中在井号“#”后面的分段。
             host 设置或获取 location 或 URL 的 hostname 和 port 号码。
             hostname 设置或获取 location 或 URL 的主机名称部分。
             href 设置或获取整个 URL 为字符串。
             pathname 设置或获取对象指定的文件名或路径。
             port 设置或获取与 URL 关联的端口号码。
             protocol 设置或获取 URL 的协议部分。
             search 设置或获取 href 属性中跟在问号后面的部分。
             ,* */
             console.log(window.location.href);
             console.log(window.location.hostname);

             /*3.navigator对象：包含web浏览器的信息*/
             /*
             ,* appCodeName 获取浏览器的代码名称。
                 appMinorVersion 获取应用程序的次版本值。
                 appName 获取浏览器的名称。
                 appVersion 获取浏览器运行的平台和版本。
                 browserLanguage 获取浏览器的当前语言。
                 cookieEnabled 获取客户端的永久 cookie 是否在浏览器中启用。永久 cookies 是储存在客户端计算机上的。
                 cpuClass 获取指示 CPU 等级的字符串。
                 onLine 获取表明系统是否处于全局脱机模式的值。
                 platform 获取用户的操作系统名称。
                 systemLanguage 获取操作系统适用的默认语言。
                 userAgent 获取等同于 HTTP 用户代理请求头的字符串。
                 userLanguage 获取操作系统的自然语言设置。
             ,* */
             console.log(window.navigator.appVersion);

             /*4.screen 屏幕对象：包含屏幕和渲染能力的对象*/
             console.log(window.screen.width);
             console.log(window.screen.height);

         </script>
     </head>
     <body>
         <input type="button" onclick="demo1()" value="前进按钮" />
         <input type="button" onclick="demo2()" value="后退按钮" />
         <a href="http://www.baidu.com">百度</a>
     </body>
     </html>
   #+END_SRC

   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js对象</title>
         <script type="text/javascript">
           /*window.onblur=function(){
             alert(123);
             }*/
           /*window.onfocus=function(){
             alert(321);
             }*/
           /*window.onload=function(){
             var div = document.getElementById("test");
             div.innerText="bbb";
             }*/
           /*var flag = window.confirm("是否下课？");
           if(flag){
             alert("快点下课");
           }else{
             alert("一会下课");
             }*/
           /*var password=window.prompt("请输入密码");
           if(password="007"){
             alert("密码正确，立即爆炸");
           }else{
             alert("密码错误，哈市爆炸");
             }*/
           //window.clase();
           /*window.setInterval(function(){
             var div = document.getElementById("test");
             var date = new Date();
             var time = date.toLocaleString();
             div.innerText = ;
             },1000);*/
           window.setTimeout(function(){
             var div = document.getElementById("test");
             div.innerText = "time out!";
           },3000);
         </script>
       </head>
       <body>
         <div id="test" class="test">
           waiting...
         </div>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/50.html]]
   + 其中包含的方法：
     1. onblur:失去焦点
     2. onfocus：获得焦点
     3. !!!onload：当前浏览器页面装载完成后触发
     4. !!!alert
     5. !!!confirm
     6. !!!prompt
     7. !!!close(仅限ie浏览器，chrome和firefox需要解决浏览器禁止js关闭非js创建页面的问题)
     8. !!!setInterval
     9. !!!setTimeout
     10. setInterval和setTimeout的不同?
   + 其中包含的对象：（我们可以通过window引出这些对象）
     1. location
     2. screen
     3. history
     4. navigator
     5. document
2. location
   !!!href：获取或设置地址栏上的地址。通过此属性js可以控制浏览器访问一个新的地址
3. navigator
4. history
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>js对象</title>
         <script type="text/javascript">
           /*function back(){
           window.history.back();
           }
           function forward(){
           window.history.forward();
           }*/
           function back(){
           window.history.go(-1);
           }
           function forward(){
           window.history.go(1);
           }
           console.lot(window.history.length);
         </script>
       </head>
       <body>
         <div id="test" class="test">
           waiting...
         </div>
         <input type="button" onclick="back()" value="后退" />
         <input type="button" onclick="forward()" value="前进" />
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/51.html]]
   1. length
   2. back()
   3. forward()
   4. go()
** 4. DOM--文档对象模型
[[./Img/day04DOM.png]]
dom--document object model
1. 获取文档独享的方法
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
       <head>
         <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
         <title>如何通过document获取数据</title>
         <script type="text/javascript">
           function demo1(){
             //根据ID获取username文本中的值
             var username = document.getElementById("username");
             //获取当前对象的value值
             alert(username.value);
           }
           function demo2(){
             //根据name获取input的对象
             var password = document.getElementsByName("password");
             //获取其中的value值
             //因为getElementsByName获取两个对象，这两个对象存储在一个数组中，如果需要取出每一个对象的value值，可以使用for遍历来操作
             for(var i=0;i<password.length;i++){
               alert(password[i].value);
             }
           }
           function demo3(){
             //根据tagname(元素名)获取页面中的元素
             arr_input = document.getElementsByTagName("input");
             //获取元素的value值
             //利用for循环遍历输出每一个input元素的value值
             for(var i=0;i<arr_input.length;i++){
               alert(arr_input[i].value);
             }
           }
           function demo4(){
             //获取页面中的p元素
             var p = document.getElementById("pid");
             //获取p元素中的文本内容
             alert(p.innerText);
             //设置p元素中的文本内容
             //p.innerText = "10点多了";
             p.innerHTML="<font color='red'>10点多了</font>";
           }
         </script>
       </head>
       <body>
         用户名称：<input type="text" name="username" id="username"/><br />
         用户密码：<input type="password" name="password" id="password" /><br />
         用户密码2：<input type="password" name="password" id="password2" /><br />

         <hr />
         <input type="button" value="通过ID获取节点的值" onclick="demo1()"/>
         <input type="button" value="通过NAME获取节点的值"  onclick="demo2()" />
         <input type="button" value="通过TAG获取节点的值" onclick="demo3()" />

         <hr  />
         <p id="pid"><font color="red">获取P标签中的文字</font></p>
         <input type="button" value="获取P中文字" onclick="demo4()" />
       </body>
     </html>
   #+END_SRC
   1. getElementByld("id"):根据id获取一个元素
   2. getElementsByName("name")：根据name获取一组元素
   3. getElementsByTagName("tagname")根据元素名称获取一组元素
   4. innerHTML()：设置或获取位于对象起始和结束标签内的HTML
   5. innerText()：设置或获取位于对象起始或结束标签内的文本
2. 对文档对象进行增删改查的操作
   #+BEGIN_SRC html
       <html>
         <head>
           <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

           <title>节点的增删改查</title>
           <!--加入样式表-->
           <style type="text/css">
             div {
                 border:#0099FF 1px solid;
                 height:60px;
                 width:120px;
                 margin:20px 0px 20px 20px;
                 padding:10px 0px 0px 20px;
             }

             #div_1{
                 background-color:#00FFFF;
             }

             #div_2{
                 background-color:#FF3399;
             }

             #div_3{
                 background-color:#0000FF;
             }

             #div_4{
                 background-color:#FFFF66;
             }
           </style>

           <script type="text/javascript">
             function addNode(){
               /*
               //创建节点
               var new_div=document.createDlement("div");
               //添加节点（挂载）--将新节点挂载到父节点身上
               //1.获取父节点
               var parent = document.getElementByTagName("body")[0];
               //2.挂载
               parentNode.appendChild(new_div);*/

               //将新节点插入到旧节点之前
               //1.获取父节点
               var parent = document.getElementsByTagName("body")[0];
               //2.获取旧节点
               var div_4=document.getElementById("div_4");
               //3.创建新节点
               var new_div = document.createElement("div");
               //4.根据父节点在旧节点之前插入新节点
               parent.insertBefore(new_div,div_4);
             }
             function deleteNode(){
               //1. 获取要删除的节点
               var div_3 = document.getElementById("div_3");
               //2. 获取父节点
               var parent = document.getElementsByTagName("body")[0];
               //3. 将在节点从父节点身上删除
               parent.removeChild(div_3);
             }
             function updateNode(){
               //1. 获取父节点
               var parent = document.getElementsByTagName("body")[0];
               //2. 获取要被替换的旧节点
               var div_2=document.getElementById("div_2");
               //3. 创建一个新的节点
               var new_div=document.createElement("div");
               //4. 替换旧节点
               parent.replaceChild(new_div,div_2);
             }
             function copyNode(){
               //1. 获取一个节点
               var div_4=document.getElementById("div_4");
               //2.克隆
               var new_div=div_4.cloneNode(false);
               //3. 将克隆好的对象添加到js文档树中
               var parent=document.getElementsByTagName("body")[0];
               parent.appendChild(new_div);
             }
           </script>
         </head>
         <body>
           <div id="div_1">

           </div>

           <div id="div_2">
             div区域2
           </div>

           <div id="div_3">
             div区域3
           </div>

           <div id="div_4">
             div区域4
           </div>

           <hr />
           <input type="button" value="创建并添加节点" onclick="addNode()" />
           <input type="button" value="删除节点" onclick="deleteNode()" />
           <input type="button" value="替换节点" onclick="updateNode()" />
           <input type="button" value="克隆节点" onclick="copyNode()" />

         </body>
       </html>
   #+END_SRC
   [[./SourceCode/54.html]]

   #+BEGIN_SRC html
       <html>
         <head>
           <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
           <title>好友列表</title>
           <style type="text/css">
             table {
                 border:#0099FF 1px solid;
                 width:100px;
                 border-collapse:collapse;
             }
             table td{
                 border:#0066FF 1px solid;
                 background-color:#FF9900;
                 text-align:center;
             }
             table td div {
                 background-color:#FFFF99;
                 text-align:left;
             }
             table td a:link, table td a:visited {
                 color:#00ffFF;
                 text-decoration:none;
             }
             table td a:hover {
                 color:#00CC00;
             }

             /*
       使用display属性:如果取值为none就是隐藏标签。
            ,*/
             table td div {
                 display:none;
             }
             .open {
                 display:block;
             }
             .close {
                 display:none;
             }
           </style>
           <script type="text/javascript">
             function openDiv(thisobj){
               //1.点击a变迁展示div
               //找到a标签兄弟标签div
               //调用一个nextSibling获取到的是一个空格，再次调用nextSibling才是div对象
               var div = thisobj.nextSibling.nextSibling;
               //当前点击的div做出display的修改，而其他div全部关闭
               //找到全部的div，判断其中不是点击的div，然后将这些div全部关闭
               var divs = document.getElementsByTagName("div");
               for(var i=0;i<divs.length;i++){
                 //一次判断当前数组中的div是否为选中的div
                 if(divs[i] != div){
                   divs[i].style.display ="none"
                 }
               }
               //修改div对象身上的display样式内容，修改display:block;
               //判断当前div是否打开，如果打开则关闭，如果关闭则打开
               if(div.style.display == "none"){
                 div.style.display ="block"
               }else{
                 div.style.display ="none"
               }
               //div.style.display = div.style.display == "none"?"block":"none";
             }
           </script>
         </head>
         <body>
           <table>
             <tr>
               <td>
                 <a href="javascript:void(0)" onclick="openDiv(this)">君王好友</a>
                 <div>
                   秦始皇<br />
                   刘邦<br />
                   李世民<br />
                   康熙<br />
                 </div>
               </td>
             </tr>
             <tr>
               <td>
                 <a href="javascript:void(0)" onclick="openDiv(this)">三国好友</a>
                 <div>
                   刘备<br />
                   关羽<br />
                   张飞<br />
                   赵云<br />
                 </div>
               </td>
             </tr>
             <tr>
               <td>
                 <a href="javascript:void(0)" onclick="openDiv(this)">美女好友</a>
                 <div>
                   西施<br />
                   貂蝉<br />
                   杨贵妃<br />
                   王昭君<br />
                 </div>
               </td>
             </tr>
             <tr>
               <td>
                 <a href="javascript:void(0)" onclick="openDiv(this)">IT好友</a>
                 <div>
                   马云<br />
                   李开复<br />
                   俞敏洪<br />
                   李彦宏<br />
                 </div>
               </td>
             </tr>
           </table>
         </body>
       </html>
   #+END_SRC
   [[./SourceCode/55.html]]

   #+BEGIN_SRC html
       <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
       <html xmlns="http://www.w3.org/1999/xhtml">
         <head>
           <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
           <title>二级联动菜单</title>
           <script>
             function selectCity(thisobj){
               var cities = {
                 "北京市":["海淀区","朝阳区","丰台区"],
                 "河北省":["石家庄","唐山","秦皇岛"],
                 "辽宁省":["沈阳","大连","鞍山"],
                 "山东省":["青岛","济南","烟台"]
               }
               //1. 用户选中的省市信息
               var province = document.getElementById("province").value;
               //2. 根据省市信息获取对应的城市信息
               var city = cities[province];
               //3. 将获取到的城市添加到第二个下拉框当中
               //3.1 获取第二个下拉框
               var sel = document.getElementById("city");
               //清空第二个下拉框
               //通过设置第二个下拉框的html内容来控制内容清空
               sel.innerHTML = "<option>--请选择--</option>"
               //3.2 循环添加城市信息
               for(var i=0;i<city.length;i++){
                 sel.innerHTML += "<option>"+city[i]+"</option>"
               }
             }
             </script>
         </head>
         <body>
           <select id="province" onchange="selectCity(this)">
             <option>--选择省市--</option>
             <option>北京市</option>
             <option>河北省</option>
             <option>辽宁省</option>
             <option>山东省</option>
           </select>
           <select id="city">
             <option>--选择城市--</option>
           </select>
         </body>
       </html>
   #+END_SRC
   [[./SourceCode/56.html]]
3. 表单的非空校验
   #+BEGIN_SRC html
       <html>
         <head>
           <title>表单页面</title>
           <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
           <script>
             function checkData(){
               var canSub = true;
               //1. 非空校验
               //获取要判断的元素
               canSub = checkNull("username","用户名不能为空！") && canSub;
               canSub = checkNull("password","密码不能为空！") && canSub;
               canSub = checkNull("password2","确认密码不能为空！") && canSub;
               canSub = checkNull("nickname","昵称不能为空！") && canSub;
               canSub = checkNull("email","邮箱不能为空！") && canSub;
               canSub = checkNull("img","头像不能为空！") && canSub;
               canSub = checkNull("valistr","验证码不能为空！") && canSub;
               //2. 单选框的非空校验
               //获取页面中的全部单选框
               var gender = document.getElementsByName("gender");
               //循环判断是否选择任意一个元素
               //判断单选框的选中状态是否相同，如果相同则证明用户没有选中单选框
               var gender_msg = document.getElementById("gender_msg");
               //清空
               gender_msg.innerText = "";
               if(gender[0].checked == gender[1].checked){
                 gender_msg.innerText = "性别不能为空!";
                 canSub = false;
               }

               //3. 复选框的非空校验
               var like = document.getElementsByName("like");
               //遍历爱好，如果用户选中其中任意一个元素，则证明复选框被选中，如果遍历至最后仍然没有元素被选中则证明复选框未被选中
               var flag = false;
               for(var i = 0;i<like.length;i++){
                 if(like[i].checked == true){
                   //证明用户选中复选框
                   flag = true;
                 }
               }
               var like_msg = document.getElementById("like_msg");
               //清空
               like_msg.innerText = "";
               if(!flag){
                 like_msg.innerText = "爱好不能为空！";
                 canSub = false;
               }

               //4. 密码一致性校验
               var password = document.getElementsByName("password")[0].value;
               var password2 = document.getElementsByName("password2")[0].value;
               var password2_msg = document.getElementById("password2_msg");
               if(password != "" && password2 != "" && password != password2){
                 //密码不一致则需要提示用户
                 password2_msg.innerText = "两次密码不一致";
                 canSub = false;
               }

               //5. 邮箱格式校验
               var email = document.getElementsByName("email")[0].value;
               //lishuai@tedu.cn
               var reg = /\w+@\w+(\.\w+)+/;
               var email_msg = document.getElementById("email_msg");
               if(email != "" && !reg.test(email)){
                 email_msg.innerText = "邮箱格式不正确";
                 canSub = false;
               }
               return canSub;
             }
             function checkNull(name,msg){
               var tag = document.getElementsByName(name)[0].value;
               var tag_msg = document.getElementById(name+"_msg");
               //清空消息提示
               tag_msg.innerText = "";
               if(tag == ""){
                 tag_msg.innerText = msg;
                 return false;
               }
               return true;
             }

             function descFocus(thisobj){
               //如果聚焦textarea时文本内容为请输入描述信息~！，则清空textarea
               if(thisobj.value == "请输入描述信息~！"){
                 thisobj.value = "";
               }
             }
             function descBlur(thisobj){
               //如果用户离焦textarea时，没有书写任何内容，则应该将请输入描述信息~！回显
               if(thisobj.value == ""){
                 thisobj.value = "请输入描述信息~！";
               }
             }
           </script>
           <style type="text/css">
             span{
                 color:red;
                 font-size:12px;
             }
           </style>
         </head>
         <body>
           <form action="http://localhost:8080" method="POST" onsubmit="return checkData()">
             <table border="1px" align="center" cellpadding="10px" cellspacing="0px" borderColor="red" bgcolor="pink">
               <caption><font color="red" size="6">注册表单</font></caption>
               <input type="hidden" name="id" value="9527"/>
               <tr>
                 <td>用户名:</td>
                 <td><input type="text" name="username" /> <span id="username_msg"></span></td>
               </tr>
               <tr>
                 <td>密码:</td>
                 <td><input type="password" name="password"/> <span id="password_msg"></span></td>
               </tr>
               <tr>
                 <td>确认密码:</td>
                 <td><input type="password" name="password2"/> <span id="password2_msg"></span></td>
               </tr>
               <tr>
                 <td>性别：</td>
                 <td>
                   <input type="radio" name="gender" value="男"/>男
                   <input type="radio" name="gender" value="女"/>女 <span id="gender_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td>昵称：</td>
                 <td><input type="text" name="nickname"/> <span id="nickname_msg"></span></td>
               </tr>
               <tr>
                 <td>邮箱：</td>
                 <td><input type="text" name="email"/> <span id="email_msg"></span></td>
               </tr>
               <tr>
                 <td>爱好：</td>
                 <td>
                   <input type="checkbox" name="like" value="lq"/>篮球
                   <input type="checkbox" name="like" value="zq"/>足球
                   <input type="checkbox" name="like" value="qq"/>铅球
                   <input type="checkbox" name="like" value="blq"/>玻璃球
                   <span id="like_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td>客户类型：</td>
                 <td>
                   <select name="type">
                     <option value="pm">平民</option>
                     <option value="sxdy">少先队员</option>
                     <option value="gqty">共青团员</option>
                     <option value="ybdy">预备党员</option>
                     <option value="zsdy">正式党员</option>
                   </select>
                   <span id="type_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td>头像：</td>
                 <td>
                   <input type="file" name="img"/> <span id="img_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td>描述信息：</td>
                 <td>
                   <textarea id="desc" rows="5" cols="45" name="desc" onfocus="descFocus(this)" onblur="descBlur(this)">请输入描述信息~！</textarea> <br/><span id="desc_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td>验证码：</td>
                 <td>
                   <input type="text" name="valistr"/>
                   <img src="../image/img/vc.jpg" width="100px" height="20px"/>
                   <span id="valistr_msg"></span>
                 </td>
               </tr>
               <tr>
                 <td colspan="2" align="right">
                   <input type="submit" value="提 交"/>
                   <input type="reset" value="重 置"/>
                 </td>
               </tr>
             </table>
           </form>
         </body>
       </html>
   #+END_SRC
   [[./SourceCode/57.html]]
   1. 创建元素：
        document.createElement("节点类型");//为指定标签创建一个元素的实例
   2. 挂载元素：
        - 要指定元素挂载到哪一个父节点身上
          parentNode.AppendChild(childNode);//在父元素最后位置添加子元素
        - 将新节点插入到旧节点之前
          parentNode.insertBefore(newNode,oldNode);//将元素作为父对象的子节点插入到文档层次结构中
   3. 删除元素:将父节点身上的一个子节点移除，这个操作就是删除节点
        parentNode.removeChile(childNode)
   4. 修改元素:使用新节点替换掉已有的节点
        parentNode.replaceChile(newNode,oldNode);
   5. 克隆节点：将当前元素再复制一份，并复制后的元素会作为返回值返回;在调用cloneNode()方法时，可以指定一个布尔值，如果指定为false，则表示仅复制div本身，div中的子元素或子内容全部放弃。如果指定为true，则表示完全复制div，包括其中的子元素或字内容。默认不写就是false
        div = div.cloneNode(boolean);//如果位false或者不写(默认)，不复制克隆节点中的子节点，只复制指定克隆节点。//如果位true，复制当前节点及其子节点
   6. 调整样式：
      #+BEGIN_SRC html
          <html>
            <head>
              <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
              <title>新闻广告</title>
              <style type="text/css">
                <!-- 伪元素选择器 -->
                a:link,a:visited {
                    color:#FF9900;
                    text-decoration:none;
                    font-size:15px;
                }
                a:hover {
                    color:#0099FF;
                }
                .newsstyle {
                    border:#0099FF 1px solid;
                    font-size:16px;
                    width:400px;
                }
                /*
          预先定一些选择器
               ,*/
                .max {
                    border:#0099FF 1px solid;
                    font-size:20px;
                    color:#FF0000;
                    background-color:#CCFFFF;
                    width:400px;
                }
                .min {
                    border:#0099FF 1px solid;
                    font-size:12px;
                    color:#0000FF;
                    background-color:#FFFFFF;
                    width:400px;
                }
              </style>
              <script type="text/javascript">
                function resize(obj){
                  //将用户传入的参数作为div的样式值使用
                  //1. 获取div对象
                  var newstext = document.getElementById("newstext");
                  //2. 设置div身上的样式值
                  newstext.className = obj;
                }
              </script>
            </head>
            <body>
              <h2>这是一个大新闻.</h2>
              <a href="javascript:void(0)" onclick="resize('min')">小字体</a>
              <a href="javascript:void(0)" onclick="resize('newsstyle')">中字体</a>
              <a href="javascript:void(0)" onclick="resize('max')">大字体</a>
              <hr />
              <div id="newstext" class="newsstyle">
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
                演示接口.很多内容.怎么办呢?等等<br />
              </div>
            </body>
          </html>
      #+END_SRC
      - 通过修改元素的class属性，使元素使用不同的类来启用不同的样式
          div.className = "xxx";
      - 通过元素的style属性来进行样式的修改
          div.style.backgroundColor = "#f00";
      - 通过修改元素display属性，调整节点展示方法：
          div.style.display = "none"|"block";
   + 拓展：nextSibling获取对此对象的下一个兄弟对象的引用
** 5. 问题：
dom解析时，在页面中写好一个function demo1(){},适用button按钮调用这个方法，执行却发现报错，错误：ncaught ReferenceError:demo1 is not defined(demo1未定义)
- 解决：
  仔细检查<script></script>中的function demo1(){}代码，少了大括号，会出现未定义的错误
* jQuery
[[./Img/jQuery.png]]
** 1. jQuery概述
1. 由于用户在js中编写的内容十分繁多，将一些常用的操作和行为进行了封装，封装成很多个函数，这些函数就构成了一个js的函数库，用户在使用的时候直接调用函数库的函数即可，这个函数库就是jQuery
2. jQuery可以写的更少，但是做的更多
3. jQuery的本质是js
** 2. jQuery的优势
1. 可以简化JavaScript代码
2. 可以像css选择器一样选择元素
3. 可以修改css一样修改页面中的样式
4. 可以兼容常用的浏览器
** 3. jQuery版本支持
jQuery分为很多版本，还分为未压缩和压缩版，根据需要选择对应的版本进行下载
- 1.x 支持常用的浏览器和IE6+
- 2.x 支持常用的浏览器和IE9+
- 3.x 支持常用的浏览器和IE9+
  注意jQuery不兼容老版本，因为jQuery升级除了会做一些内部优化之外，还会删除以前的一些代码，比如删除一些方法，或者是添加一些新的方法，所以在升级之后，以前的代码可能会无法执行
** 4. jQuery引入
需要在页面中引入一个js文件，这个js文件就是jQuery的函数库，只有引入函数库之后才能够使用jQuery代码
#+BEGIN_SRC html
      <script src = "js/jquery-1.4.2.js"></script>
#+END_SRC
jQuery类库其实就是一个普通的js文件，和之前在html中引入js文件方式一样的
** 5. jQuery的使用方式
$就是jQuery的意思$("div") <==> jQuery("div")
** 6. js对象和jQuery对象的相互转换
1. js对象->jQuery对象
   将已有的js对象使用$()包起来即可由js对象变为jQuery对象
    #+BEGIN_SRC html
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
            <title>jQuery的引入</title>
            <script type="text/javascript" src="../other/jquery-1.4.2.js">
            </script>
            <script type="text/javascript">
              window.onload = function(){
                //js对象->jQuery对象
                var div = document.getElementById ("test");
                $ (div).text("bbb")
              }
            </script>
          </head>
          <body>
            <div id="test" class="test">
            </div>
          </body>
        </html>
      #+END_SRC
      [[./SourceCode/60.html]]
2. jQuery对象->js对象
   jQuery对象一般利用选择器选中页面
      #+BEGIN_SRC
        var div = $("div")[0];
        var div = $("div").get(0);
      #+END_SRC
      #+BEGIN_SRC html
        <html>
          <head>
            <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
            <title>jQuery的引入</title>
            <script type="text/javascript" src="../other/jquery-1.4.2.js">
            </script>
            <script type="text/javascript">
              window.onload = function(){
                //jQuery对象->js对象和jquery对象
                //第一种
                var div = $("div")[0];
                div.innerText = "ccc";
              }
            </script>
          </head>
          <body>
            <div id="test" class="test">
            </div>
          </body>
        </html>
      #+END_SRC
      [[./SourceCode/60.html]]
3. 注意：
   #+BEGIN_SRC
        var $div = $("div");
        var div = $("div");
   #+END_SRC
   此处$div和div表示的内容是同一个jQuery对象，$div这种命名的方式只是想表示当前值是一个jQuery的对象。
** 7. jQuery主要用法：
1. 在jQuery中书写一个CSS选择器 --- $("div")，这种就可以将这种形式作为jQuery选择器来使用
2. 动态创建dom元素---直接书写html元素名称来创建代表html元素的jQuery对象
       #+BEGIN_SRC
         $("<div><p>Hello</p></div>").appendTo("body");
       #+END_SRC
3. 利用jQuery控制css样式
       #+BEGIN_SRC
         $(document.body).css("background","black");
            选中的元素     .css    属性名称     属性值
       #+END_SRC
4. 文档就绪事件 --- 在整个html页面加载完成之后在执行其中的js代码
       js:
       #+BEGIN_SRC
         window.onload = function(){}
       #+END_SRC
       jQuery:ready()函数就是文档就绪事件
       #+BEGIN_SRC
         $(document).ready(function(){
         });

         <==>

         $().ready(function(){
         })
       #+END_SRC
       #+BEGIN_SRC
         $(function(){
         });
       #+END_SRC
** 8. jQuery选择器
** * 1. 基本选择器(selector案例一)
元素名选择器，类选择器，id选择器，多元素选择器，*选择器
1. 元素名选择器
   #+BEGIN_SRC
         $("div") - 匹配所有的div元素
   #+END_SRC
2. class选择器
   #+BEGIN_SRC
         $(".c1") - 匹配所有class值为c1的元素
         $("div.c1") - 匹配所有class值为c1的div元素
   #+END_SRC
3. id选择器
   #+BEGIN_SRC
         $("#d1") - 匹配所有id值为d1的元素
         $("div#d1") - 匹配所有id值为d1的div元素
   #+END_SRC
4. *号匹配符
   #+BEGIN_SRC
         $("*") - 匹配所有的元素
   #+END_SRC
5. 多元素选择器
   #+BEGIN_SRC
         $("div,span,#d1,.c1") - 匹配所有的div/span元素以及id值为d1的元素和class值为c1的元素
   #+END_SRC
   #+BEGIN_SRC html
     <!DOCTYPE>
     <html>
       <head>
         <title>基本选择器练习</title>
         <meta http-equiv="content-type" content="text/html; charset=UTF-8">
         <style type="text/css">
           body{
               font-family: "微软雅黑"
           }
           div,span {
               width: 140px;
               height: 140px;
               margin: 20px;
               background: #9999CC;
               border: #000 1px solid;
               float: left;
               font-size: 17px;
               font-family: Roman;
           }
           div.mini {
               width: 40px;
               height: 43px;
               background: #CC66FF;
               border: #000 1px solid;
               font-size: 12px;
               font-family: Roman;
           }
           input{ margin: 5px 5px; }
         </style>
         <!--引入jquery的js库-->
         <script src="../other/jquery-1.4.2.js"></script>
         <script type="text/javascript">
           //让整个页面加载完成
           $(document).ready(function() {
             /* ---------基本选择器练习--------- */
             //改变元素名为 <div> 的所有元素的背景色为 #FF69B4"  id="b1"
             $("#b1").click(function(){
               //点击事件中添加一个函数，用来实现改变背景颜色的操作
               //1.选中元素
               //2.修改选中元素背景颜色
               $("div").css("background","#FF69B4");
             });
             //改变 id 为 one 的元素的背景色为 #9ACD32"  id="b2"
             $("#b2").click(function(){
               $("#one").css("background","#9ACD32");
             });
             //改变 class 为 mini 的所有元素的背景色为 #FF0033"  id="b3"
             $("#b3").click(function(){
               $(".mini").css("background","#FF0033");
             });
             //改变所有元素的背景色为 #FDF5E6"  id="b4"
             $("#b4").click(function(){
               $("*").css("background","#FDF5E6");
             });
             //改变所有的<span>元素和 id 为 two 的元素的背景色为 #FF1493"  id="b5"
             $("#b5").click(function(){
               $("span,#two").css("background","#FF1493");
             });
             //改变所有的<span>元素和 id 为 two 的,id为one的，class为 mini的所有的元素的背景色为 #006400"  id="b6"
             $("#b6").click(function(){
               $("span,#two,#one,.mini").css("background","#006400");
             });
           });
         </script>
       </head>
       <body>
         <input type="button" value=" 改变元素名为 <div> 的所有元素的背景色为 #FF69B4" id="b1" />
         <input type="button" value=" 改变 id 为 one 的元素的背景色为 #9ACD32" id="b2" />
         <input type="button" value=" 改变 class 为 mini 的所有元素的背景色为 #FF0033" id="b3" />
         <input type="button" value=" 改变所有元素的背景色为 #FDF5E6" id="b4" />
         <input type="button" value=" 改变所有的<span>元素和 id 为 two 的元素的背景色为 #FF1493"
                id="b5" />
         <input type="button"
                value=" 改变所有的<span>元素和 id 为 two 的,id为one的，class为 mini的所有的元素的背景色为 #006400"
                id="b6" />
         <h1>天气冷了</h1>
         <h2>天气又冷了</h2>
         <div id="one">id为one</div>
         <div id="two" class="mini">
           id为two class是 mini
           <div class="mini"> class是 mini</div>
         </div>
         <div class="one">
           class是 one
           <div class="mini"> class是 mini</div>
           <div class="mini"> class是 mini</div>
         </div>
         <div class="one">
           class是 one
           <div class="mini01"> class是 mini01</div>
           <div class="mini"> class是 mini</div>
         </div>
         <br>
         <div id="mover">动画</div>
         <br>
         <span class="spanone"> span </span>
         <span class="mini"> span class是mini </span>
       </body>
     </html>
   #+END_SRC
   [[./SourceCode/61.html]]
*** 2. 层级选择器(selector案例二)
如果想通过dom元素之间的层次关系来获取特定元素，例如子元素、兄弟元素等。则需要通过层次选择器
1. 后代选择器
   #+BEGIN_SRC
         $("div span") - 匹配div下所有的span元素
   #+END_SRC
2. span子元素选择器
   #+BEGIN_SRC
         $("div > span") - 匹配div下所有的span子元素
   #+END_SRC
3. div后面紧邻span兄弟选择器
   #+BEGIN_SRC
         $("div + span") - 匹配div后面紧邻的span兄弟元素
   #+END_SRC
4. div后面所有的span
   #+BEGIN_SRC
         $("div~span") - 匹配div后面所有的span兄弟元素
   #+END_SRC
   #+BEGIN_SRC html
      <!DOCTYPE HTML>
      <html>
        <head>
          <title>层级选择器</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8">
          <style type="text/css">
            div,span {
                width: 140px;
                height: 140px;
                margin: 20px;
                background: #9999CC;
                border: #000 1px solid;
                float: left;
                font-size: 17px;
                font-family: Roman;
            }
            div.mini {
                font-size: 14px;
                height: 53px;
                width: 47px;
                background: #CC66FF;
                border: #000 1px solid;
                font-family: Roman;
            }
            input{ margin: 5px 5px; }
          </style>
          <!--引入jquery的js库-->
          <script src="../other/jquery-1.4.2.js"></script>
          <script type="text/javascript">
            $().ready(function() {
              /* ---------层级选择器练习--------- */
              //改变 <body> 内所有 <div> 的背景色为 #F08080"  id="b1"
              $("#b1").click(function(){
                $("body div").css("background","#F08080");
              });
              //改变 <body> 内子 <div> 的背景色为 #FF0033"  id="b2"
              $("#b2").click(function(){
                $("body>div").css("background","#FF0033");
              });
              //改变 id 为 one 的下一个 <div> 的背景色为 #0000FF"  id="b3"
              $("#b3").click(function(){
                $("#one+div").css("background","#0000FF");
              });
              //改变 id 为 two 的元素后面的所有兄弟<div>的元素的背景色为 #9ACD32"  id="b4"
              $("#b4").click(function(){
                $("#two~div").css("background","#9ACD32");
              });
              //改变 id 为 two 的元素所有 <div> 兄弟元素的背景色为 #FF6347"  id="b5"
              $("#b5").click(function(){
                $("#two").siblings("div").css("background","#FF6347");
              });
            });
            </script>
        </head>
        <body>
          <input type="button" value=" 改变 <body> 内所有 <div> 的背景色为 #F08080" id="b1" onclick="fn()"/>
          <input type="button" value=" 改变 <body> 内子 <div> 的背景色为 #FF0033" id="b2" />
          <input type="button" value=" 改变 id 为 one 的下一个 <div> 的背景色为 #0000FF"
                 id="b3" />
          <input type="button"
                 value=" 改变 id 为 two 的元素后面的所有兄弟<div>的元素的背景色为 #9ACD32" id="b4" />
          <input type="button" value=" 改变 id 为 two 的元素所有 <div> 兄弟元素的背景色为 #FF6347"
                 id="b5" />
          <h1>天气冷了</h1>
          <div id="one">id为one</div>
          <div id="two">
            id为two
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one">
            class是 one
            <div class="mini"> class是 mini</div>
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one">
            class是 one
            <div class="mini01"> class是 mini01</div>
            <div class="mini"> class是 mini</div>
          </div>
          <br>
          <div id="mover">动画</div>
          <br>
        </body>
      </html>
   #+END_SRC
   [[./SourceCode/62.html]]
*** 3. 基本过滤选择器(selector案例三)
    过滤选择器主要是通过特定的过滤规则筛选出所需的dom元素，该选择器都以":"开头
    - 匹配所有div中的第一个div元素
      #+BEGIN_SRC
        $("div:first")
      #+END_SRC
    - 匹配所有div中的最后一个div元素
      #+BEGIN_SRC
        $("div:last")
      #+END_SRC
    - 匹配所有div中索引值为偶数的div元素，0开始
      #+BEGIN_SRC
        $("div:even")
      #+END_SRC
    - 匹配所有div中索引值为奇数的div元素，0开始
      #+BEGIN_SRC
        $("div:odd")
      #+END_SRC
    - 匹配所有div中索引值为n的div元素，0开始
      #+BEGIN_SRC
        $("div:eq(n)")
      #+END_SRC
    - 匹配所有div中索引值小于n的div元素，0开始
      #+BEGIN_SRC
        $("div:lt(n)")
      #+END_SRC
    - 匹配所有div中索引值大于n的div元素，0开始
      #+BEGIN_SRC
        $("div:gt(n)")
      #+END_SRC
    - 匹配所有class值不为one的div元素
      #+BEGIN_SRC
        $("div:not(.one)")
      #+END_SRC
    #+BEGIN_SRC html
      <!DOCTYPE HTML>
      <html>
        <head>
          <title>基本过滤选择器</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8">
          <style type="text/css">
            div,span {
                width: 140px;
                height: 140px;
                margin: 20px;
                background: #9999CC;
                border: #000 1px solid;
                float: left;
                font-size: 17px;
                font-family: Roman;
            }
            div.mini {
                font-size: 14px;
                height: 53px;
                width: 47px;
                background: #CC66FF;
                border: #000 1px solid;
                font-family: Roman;
            }
            input{ margin: 5px 5px; }
          </style>

          <!--引入jquery的js库-->
          <script src="../other/jquery-1.4.2.js"></script>
          <script type="text/javascript">
            $(function() {
              /* ---------基本过滤选择器练习--------- */
              //改变第一个 div 元素的背景色为 #FF6347"  id="b1"
              $("#b1").click(function(){
                $("div:first").css("background","#FF6347");
              })
              //改变最后一个 div 元素的背景色为 #9ACD32" id="b2"
              $("#b2").click(function(){
                $("div:last").css("background","#9ACD32");
              });
              //改变class不为 one 的所有 div 元素的背景色为 #FF0033" id="b3"
              $("#b3").click(function(){
                $("div:not(.one)").css("background","#FF0033");
              });
              //改变索引值为等于 3 的 div 元素的背景色为 #006400"  id="b4"
              $("#b4").click(function(){
                $("div:eq(3)").css("background","#006400")
              })
              //改变索引值为小于 3 的 div 元素的背景色为 #FF69B4"  id="b5"/>
              $("#b5").click(function(){
                $("div:lt(3)").css("background","#FF69B4");
              })
              //改变索引值为大于 3 的 div 元素的背景色为 #F08080"  id="b6"
              $("#b6").click(function(){
                $("div:gt(3)").css("background","#F08080");
              });
              //改变索引值为偶数的 div 元素的背景色为 #FF6347" id="b7"
              $("#b7").click(function(){
                $("div:even").css("background","#FF6347");
              });
              //改变索引值为奇数的 div 元素的背景色为 #FF1493" id="b8"
              $("#b8").click(function(){
                $("div:odd").css("background","#FF1493");
              });
            });
          </script>
        </head>
        <body>
          <input type="button" value=" 改变第一个 div 元素的背景色为 #FF6347" id="b1" />
          <input type="button" value=" 改变最后一个 div 元素的背景色为 #9ACD32" id="b2" />
          <input type="button" value=" 改变class不为 one 的所有 div 元素的背景色为 #FF0033" id="b3" />
          <input type="button" value=" 改变索引值为等于 3 的 div 元素的背景色为 #006400" id="b4" />
          <input type="button" value=" 改变索引值为小于 3 的 div 元素的背景色为 #FF69B4" id="b5" />
          <input type="button" value=" 改变索引值为大于 3 的 div 元素的背景色为 #F08080" id="b6" />
          <input type="button" value=" 改变索引值为偶数的 div 元素的背景色为 #FF6347" id="b7" />
          <input type="button" value=" 改变索引值为奇数的 div 元素的背景色为 #FF1493" id="b8" />
          <h1>天气冷了</h1>
          <div id="one">id为one</div>
          <div id="two">
            id为two
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one" title="aa">
            class是 one
            <div class="mini"> class是 mini</div>
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one">
            class是 one
            <div class="mini01"> class是 mini01</div>
            <div class="mini"> class是 mini</div>
          </div>
          <br>
          <div id="mover">动画</div>
          <br>
        </body>
      </html>
    #+END_SRC
    [[./SourceCode/63.html]]
*** 4. 内容选择器(selector案例四)
    - 匹配所有div中包含abc内容的div元素
      #+BEGIN_SRC
        $("div:contains('abc)")
      #+END_SRC
      如：<div>xxxabcxxx</div>
    - 匹配所有包含p元素的div元素
      #+BEGIN_SRC
        $("div:has(p)")
      #+END_SRC
      如：<div><p></p></div>
    - 匹配所有内容为空的div元素
      #+BEGIN_SRC
        $("div:empty")
      #+END_SRC
      如：<div></div>
    - 匹配所有内容不为空的div元素
      #+BEGIN_SRC
        $("div:parent")
      #+END_SRC
      如：<div>xxxxx</div>
    - 可见选择器
      - 匹配所有隐藏的div元素
        #+BEGIN_SRC
          $("div:hidden")
        #+END_SRC
      - 匹配所有可见的div元素
        #+BEGIN_SRC
          $("div:visible")
        #+END_SRC
    #+BEGIN_SRC html
      <!DOCTYPE HTML>
      <html>
        <head>
          <title>内容选择器</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8">
          <style type="text/css">
            div,span {
                width: 140px;
                height: 140px;
                margin: 20px;
                background: #9999CC;
                border: #000 1px solid;
                float: left;
                font-size: 17px;
                font-family: Roman;
            }
            div.mini {
                font-size: 14px;
                height: 53px;
                width: 47px;
                background: #CC66FF;
                border: #000 1px solid;
                font-family: Roman;
            }
            input{ margin: 5px 5px; }
          </style>

          <!--引入jquery的js库-->
          <script src="../other/jquery-1.4.2.js"></script>
          <script type="text/javascript">
            $(function() {
              /* ---------内容选择器--------- */
              //改变含有文本 ‘id’ 的 div 元素的背景色为 #FF6347" id="b1" <div>xxidxx</div>
              $("#b1").click(function(){
                $("div:contains('id')").css("background-color","#FF6347");
              });
              //改变空元素div(既不包含文本也不包含子元素)的背景色为 #9ACD32" id="b2"
              $("#b2").click(function(){
                $("div:empty").css("background-color","#9ACD32");
              });
              //改变包含div子元素的div元素的背景色为 #FF0033" id="b3"
              $("#b3").click(function(){
                $("div:has(div)").css("background-color","#FF0033");
              });
              //改变非空div元素的背景色为 #006400" id="b4"
              $("#b4").click(function(){
                $("div:parent").css("background-color","#006400");
              });

              //====================================================
              /* ---------可见选择器练习--------- */
              //改变所有可见 div 元素背景色为 #F08080" id="b5"
              $("#b5").click(function(){
                $("div:visible").css("background-color","#F08080");
              });
              //让所有隐藏的div元素显示, 并改变背景色为 #FF69B4" id="b6"
              $("#b6").click(function(){
                $("div:hidden").css("background-color","red").show();
              });
            })
          </script>
        </head>
        <body>
          <input type="button" value=" 改变含有文本 ‘id’ 的 div 元素的背景色为 #FF6347" id="b1" />
          <input type="button" value=" 改变空元素div(既不包含文本也不包含子元素)的背景色为 #9ACD32" id="b2" />
          <input type="button" value=" 改变包含div子元素的div元素的背景色为 #FF0033" id="b3" />
          <input type="button" value=" 改变非空div元素的背景色为 #006400" id="b4" />
          <hr/>
          <hr/>
          <input type="button" value=" 改变所有可见 div 元素背景色为 #F08080" id="b5" />
          <input type="button" value=" 让所有隐藏元素显示, 并改变背景色为 #FF69B4" id="b6" />
          <h1>天气冷了</h1>
          <div id="one">id为one</div>
          <div id="two">
            id为two
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one" title="aa">
            class是 one
            <div class="mini"></div>
            <div class="mini"> class是 mini</div>
          </div>
          <br>
          <div id="mover"></div>
          <br>
          <div style="display:none">看不见我...,看不见我....</div>
        </body>
      </html>
    #+END_SRC
    [[./SourceCode/64.html]]
*** 5. 属性选择器(selector案例五)
    - 匹配所有具有id属性的div元素
      #+BEGIN_SRC
        $("div[id]")
      #+END_SRC
    - 匹配所有具有id属性并且值为d1的div元素
      #+BEGIN_SRC
        $("div[id='d1]")
      #+END_SRC
    - 匹配所有id属性值不为d1的div元素
      #+BEGIN_SRC
        $("div[id!='d1']")
      #+END_SRC
    - 匹配所有id属性以d1开头的div元素
      #+BEGIN_SRC
        $("div[id^='d1]")
      #+END_SRC
    - 匹配所有id属性值以d1结尾的div元素
      #+BEGIN_SRC
        $("div[id$='d1]")
      #+END_SRC
    - 子元素选择器
      - n从1开始，匹配div中第n个子元素。
          $("div:nth-child(n)")
      - 匹配div中第1个子元素
          $("div:first-child")
      - 匹配div中最后一个子元素
          $("div:last-child")
    #+BEGIN_SRC html
      <!DOCTYPE HTML>
      <html>
        <head>
          <title>基本过滤选择器</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8">
          <style type="text/css">
            div,span {
                width: 140px;
                height: 140px;
                margin: 20px;
                background: #9999CC;
                border: #000 1px solid;
                float: left;
                font-size: 17px;
                font-family: Roman;
            }

            div.mini {
                font-size: 14px;
                height: 53px;
                width: 47px;
                background: #CC66FF;
                border: #000 1px solid;
                font-family: Roman;
            }
            input{ margin: 5px 5px; }
          </style>

          <!--引入jquery的js库-->
          <script src="../other/jquery-1.4.2.js"></script>
          <script type="text/javascript">
            $(function() {
              /* ---------属性选择器练习--------- */
              //改变包含id属性的 div 元素的背景色为 #FF6347" id="b1"
              $("b1").click(function(){
                $("div[id]").css("background","#FF6347");
              });
              //改变包含属性title='aa' 的div 元素的背景色为 #9ACD32" id="b2"
              $("#b2").click(function(){
                $("div[title='aa]").css("background","#9ACD32");
              });
              //改变type属性不等于button的input 元素的背景色为 #FF0033" id="b3"
              $("#b3").click(function(){
                $("input[type!='button']").css("background","#FF0033");
              });
              //=================================================
              /* ---------子元素选择器练习--------- */
              //改变div 第二个子元素的背景色为 #006400"  id="b4"
              $("div:nth-child(2)").css("background-color","#006400");
              //改变div 第一个子元素的背景色为 #FF69B4"  id="b5"
              $("div:first-child").css("background-color","#FF69B4");
            })
          </script>
        </head>
        <body>
          <input type="button" value=" 改变包含id属性的 div 元素的背景色为 #FF6347" id="b1" />
          <input type="button" value=" 改变包含属性title='aa' 的div 元素的背景色为 #9ACD32" id="b2" />
          <input type="button" value=" 改变type属性不等于button的input 元素的背景色为 #FF0033" id="b3" />
          <hr/>
          <hr/>
          <input type="button" value=" 改变div 第二个子元素的背景色为 #006400"  id="b4" />
          <input type="button" value=" 改变div 第一个子元素的背景色为 #FF69B4"  id="b5" />
          <h1>天气冷了</h1>
          <div id="one">id为one</div>
          <div id="two">
            id为two
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one" title="aa">
            class是 one title为aa
            <div class="mini"> class是 mini</div>
            <div class="mini"> class是 mini</div>
          </div>
          <div class="one" title="bb">
            class是 one title为bb
            <div class="mini01"> class是 mini01</div>
            <div class="mini"> class是 mini</div>
          </div>
          <br>
          <div id="mover">id为mover 动画</div>
          <br>
          <input type="submit"/>
        </body>
      </html>
    #+END_SRC
    [[./SourceCode/65.html]]
*** 6. 表单选择器(selector案例六)
    - 匹配所有的input文本框、密码框、单选框、复选框、select框、textarea、button
        $(":input")
    - 匹配所有的密码框
        $(":password")
    - 匹配所有的单选框
        $(":radio")
    - 匹配所有的复选框
        $(":checkbox")
    - 匹配所有被选中的单选框/复选框/option
        $(":checked")
    - 匹配所有的被选中的单选框/复选框
        $("input:checked")
    - 匹配所有被选中的option选项
        $(":selected")
    #+BEGIN_SRC html
      <!DOCTYPE HTML>
      <html>
        <head>
          <title>表单选择器</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8">
          <style type="text/css">
            div,span {
                width: 140px;
                height: 140px;
                margin: 20px;
                background: #9999CC;
                border: #000 1px solid;
                float: left;
                font-size: 17px;
                font-family: Roman;
            }
            div.mini {
                font-size: 14px;
                height: 53px;
                width: 47px;
                background: #CC66FF;
                border: #000 1px solid;
                font-family: Roman;
            }
            input{ margin: 5px 5px; }
          </style>

          <!--引入jquery的js库-->
          <script src="../other/jquery-1.4.2.js"></script>
          <script type="text/javascript">
            $(function() {
              /* ---------表单选择器练习--------- */
              //改变所有:input 元素的背景色为 #F08080" id="b1"
              $("#b1").click(function(){
                $("input").css("background","#F08080");
              });
              //改变:password 元素的背景色为 #9ACD32" id="b2"
              $("#b2").click(function(){
                $(":password").css("background","#9ACD32")
              })
              //弹出 :radio 元素的个数" id="b3"
              $("#b3").click(function(){
                alert($(":radio").length);
              })
              //弹出所有 :checked 元素的value值" id="b4"
              $("#b4").click(function(){
                $(":checked").each(function(){
                  alert($(this).val())
                })
              })
              //弹出所有 :selected 元素的value值" id="b5"
              $("#b5").click(function(){
                alert($(":selected").val());
              })
            })
          </script>
        </head>
        <body>
          <input type="button" value=" 改变所有input 元素的背景色为 #F08080" id="b1" />
          <input type="button" value=" 改变:password 元素的背景色为 #9ACD32" id="b2" />
          <input type="button" value=" 打印 :radio 元素的个数" id="b3" />
          <input type="button" value=" 打印所有 :checked 元素的value值" id="b4" />
          <input type="button" value=" 打印所有 :selected 元素的value值" id="b5" />
          <h1>天气冷了</h1>
          用户名：<input type="text" disabled="disabled" name="username" value="被禁用了"/>
          密码：<input type="password" name="password" value="123"/>
          性别：<input type="radio" name="gender" value="man"/> 男
          <input type="radio" name="gender" value="woman" checked="checked" />女
          <br>
          <br>
          爱好：
          <input type="checkbox" name="like" value="lanqiu"  checked="checked" /> 篮球
          <input type="checkbox" name="like" value="taiqiu"/> 台球
          <input type="checkbox" name="like" value="zuqiu"/> 足球
          出生地：
          <select name="city">
            <option value="beijing">北京</option>
            <option value="shanghai" selected="selected">上海</option>
            <option value="guangzhou">广州</option>
          </select>
          简介：
          <textarea name="discription" rows="2" cols="10">请求输入个人描述...</textarea>
        </body>
      </html>
    #+END_SRC
    [[./SourceCode/66.html]]
*** 更多操作
1. 文档操作
   - 获取id为d1元素的父元素
     parent()
     #+BEGIN_SRC
       $("#d1").parent()
     #+END_SRC
   - 获取id为d1元素的祖先元素
     parents()
     #+BEGIN_SRC
       $("#d1").parents()
       $("#d1").parents("tr") - 获取id为d1元素的tr祖先元素
     #+END_SRC
   - 获取所匹配后面紧邻的兄弟元素
     next()
     #+BEGIN_SRC
       $("div").next()
       $("div").next("span") - 获取所匹配元素后面紧邻的span兄弟元素
     #+END_SRC
   - 获取所匹配元素后面所有的兄弟元素
     nextAll()
     #+BEGIN_SRC
       $("div").nextAll()
       $("div").nextAll("span") - 获取所匹配元素后面所有的span兄弟元素
     #+END_SRC
   - 获取所匹配元素前面紧邻的兄弟元素
     prev()
     #+BEGIN_SRC
       $("div").prev()
       $("div").prev("span") - 获取所匹配元素前面紧邻的span兄弟元素
     #+END_SRC
   - 获取所匹配元素前面所有的兄弟元素
     prevAll()
     #+BEGIN_SRC
       $("div").prevAll()
       $("div").prevAll("span") - 获取所匹配元素前面所有的span兄弟元素
     #+END_SRC
   - 获取所匹配元素前后所有的兄弟元素
     siblings()
     #+BEGIN_SRC
       $("div").siblings()
       $("div").siblings("span") - 获取所匹配元素前后所有的span兄弟元素
     #+END_SRC
   - 为所匹配元素追加一个span子元素
     append()
     #+BEGIN_SRC
       $("div").append("<span></span>")
     #+END_SRC
   - 删除所匹配元素
     remove()
     #+BEGIN_SRC
       $("div").remove("<span></span>")
     #+END_SRC
   - 获取所匹配元素的html内容
     html()
     #+BEGIN_SRC
       $("div").html()
       $("div").html("xxx") - 为所匹配元素设置html内容
     #+END_SRC
   - 获取所匹配元素的文本内容
     text()
     #+BEGIN_SRC
       $("div").text()
       $("div").text("xxx") - 为所匹配元素设置文本内容
     #+END_SRC
   - 获取所匹配元素的id属性值
     attr()
     #+BEGIN_SRC
       $("div").attr("id")
       $("div").attr("id","xx") - 为所匹配元素设置id属性
     #+END_SRC
   - 获取所匹配元素的width样式属性值
     css
     #+BEGIN_SRC
       $("div").css("width")
       $("div").css("width","200px") - 为所匹配元素设置width样式属性
       $("div").css({"width":"200px","color":"red","font-size":"24px"}); - 为所匹配元素设置width样式属性
     #+END_SRC
2. 事件
   - 为所匹配元素绑定点击事件
     click()
     #+BEGIN_SRC
       $("div").click(function(){})
     #+END_SRC
   - 为所匹配元素绑定失去输入焦点事件
     blur()
     #+BEGIN_SRC
       $("input").blur(function(){})
     #+END_SRC
   - 为所匹配元素绑定获取输入焦点事件
     focus()
     #+BEGIN_SRC
       $("input").focus(function(){})
       #+END_SRC
   - 为所匹配元素绑定选项切换事件
     change()
     #+BEGIN_SRC
       $("select").change(function(){})
     #+END_SRC
   - 文档就绪时间
     ready()
     #+BEGIN_SRC
       $(document).ready(function(){})
     #+END_SRC
     其作用相当于：window.onload=function(){}

     简写形式为：
     #+BEGIN_SRC
       $(function(){}) - 在整个文档加载完成后立即执行
     #+END_SRC
3. 效果
   - 将隐藏元素设置为限时(底层操作的是display);
     show()
     #+BEGIN_SRC
       $("div").show()
     #+END_SRC
   - 将显示元素设置为隐藏(底层操作的是display);
     hide()
     #+BEGIN_SRC
       $("div").hide()
     #+END_SRC
   - 切换元素的课件状态，如果元素显示则设置为隐藏，如果元素隐藏则设置为可见
     toggle()
     #+BEGIN_SRC
       $("div").toggle()
     #+END_SRC
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <html>
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <title>好友列表</title>
      <style type="text/css">
        body{
            font-family: "微软雅黑";
        }
        table {
            border:#0099FF 1px solid;
            width:100px;
            border-collapse:collapse;
            margin:15px 10px;
            width:10%;
        }
        table td{
            border:#0066FF 1px solid;
            background-color:#6f5f3e;
            text-align:center;
            padding: 5px 0px;
        }

        table td div {
            background-color:#FFFF99;
            text-align:left;
            line-height: 24px;
            padding-left: 14px;
        }
        table td a:link, table td a:visited {
            color:#00ffFF;
            text-decoration:none;
        }
        table td a:hover {
            color:#00CC00;
        }
        /*
          使用display属性:如果取值为none就是隐藏标签。
       ,*/
        table td div { display:none; }

        .open { display:block; }

        .close { display:none; }

      </style>
      <!--引入jquery的js库-->
      <script src="../other/jquery-1.4.2.js"></script>
      <script type="text/javascript">
        /* --通过jQuery实现访QQ列表好友分组-- */
        function openDiv(thisobj){
          //1. 当前点击的a标签的兄弟div展示，其他的div都隐藏
          //获取当前点击的a标签的祖先元素tr，找到其他兄弟tr，将找到的兄弟tr内包含的div隐藏即可
          //find在当前对象身上寻找某一个元素
          $(thisobj).parents("tr").siblings().find("div").hide();
          //2. 当前点击的a标签的兄弟div是展示状态，则切换为隐藏，如果是隐藏则切换为展示
          $(thisobj).next().toggle();
        }
        /* --通过js实现访QQ列表好友分组--
         function openDiv(thisobj){
         var oDiv = thisobj.parentNode.getElementsByTagName("div")[0];
         var aDiv = document.getElementsByTagName("div");

         //判断当前分组div是展开还是关闭
         if(oDiv.style.display == "block"){
         //如果当前div是打开的, 只需关闭该div即可
         oDiv.style.display = "none";
         }else{
         //如果当前div是关闭的, 先关闭其他分组的div, 再打开当前的
         for(var i=0;i<aDiv.length; i++){
         aDiv[i].style.display = "none";
         }
         oDiv.style.display = "block";
         }
         }
        ,*/
      </script>
    </head>
    <body>
      <table>
        <tr>
          <td>
            <a href="javascript:void(0)" onclick="openDiv(this)">君王好友</a>
            <div>
              秦始皇<br />
              刘邦<br />
              李世民<br />
              康熙<br />
            </div>
          </td>
        </tr>
        <tr>
          <td>
            <a href="javascript:void(0)" onclick="openDiv(this)">三国好友</a>
            <div>
              刘备<br />
              关羽<br />
              张飞<br />
              赵云<br />
            </div>
          </td>
        </tr>
        <tr>
          <td>
            <a href="javascript:void(0)" onclick="openDiv(this)">美女好友</a>
            <div>
              西施<br />
              貂蝉<br />
              杨贵妃<br />
              王昭君<br />
            </div>
          </td>
        </tr>
        <tr>
          <td>
            <a href="javascript:void(0)" onclick="openDiv(this)">IT好友</a>
            <div>
              马云<br />
              李开复<br />
              俞敏洪<br />
              黎活明<br />
            </div>
          </td>
        </tr>
      </table>
    </body>
  </html>
#+END_SRC
[[./SourceCode/67.html]]
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <html>
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <title>二级联动下拉框</title>
      <!--引入jquery的js库-->
      <script src="../other/jquery-1.4.2.js"></script>
      <script>
        var data = {
          "北京市": ["海淀区","朝阳区","丰台区"],
          "河北省": ["石家庄","唐山","秦皇岛"],
          "辽宁省": ["沈阳","大连","鞍山"],
          "山东省": ["青岛","济南","烟台"]
        }
        /* --通过jQuery实现二级联动下拉框 -- */
        function selectCity(thisobj){
          //根据省市信息获取对应城市信息，然后一个一个的拼接到第二个下拉框中。
          var province = $("#province").val();
          var citys = data[province];
          //清空
          $("#city").html("<option>--请选择--</option>")
          //循环添加到第二个下拉框
          for(var i=0;i<citys.length;i++){
            $("#city").append("<option>"+citys[i]+"</option>")
          }
        }
        /* --通过js实现二级联动下拉框--
         function selectCity(thisobj){
         //获取用户选中的省份
         var prov = thisobj.value;
         //再根据省份获取对应的市区
         var citys = data[prov];
         //获取第二个下拉列表
         var oCitySele = document.getElementById("city");
         //清空之前的数据
         oCitySele.innerHTML = "<option>--选择城市--</option>";
         //循环遍历, 将每一个城市依次填充到第二个下拉列表中
         for(var i=0; i<citys.length; i++){
         var oOption = document.createElement("option");
         oOption.innerHTML = citys[i];
         //将option挂载到select上
         oCitySele.appendChild(oOption);
         }
         }
        ,*/
        </script>
      <!--
          js实现注意问题:
          ie10以下的浏览器不支持 select,table上的innerHTML属性
          删除option时，由于删除后，options长度发生了变化，所以直接用for循环会有漏删的情况，可以由后向前删除，可以避免这样的问题
        -->
    </head>
    <body>
      <select name="country" onchange="getCountry()"  >
        <option value="none">--选择国家--</option>
        <option value="中国">中国</option>
        <option value="美国">美国</option>
        <option value="日本">日本</option>
      </select>
      <br><br>
      <hr/>
      <br>
      <div id="seleDiv">
        <select id="province" onchange="selectCity(this)">
          <option>--选择省市--</option>
          <option>北京市</option>
          <option>河北省</option>
          <option>辽宁省</option>
          <option>山东省</option>
        </select>
        <span id="citySpan">
          <select id="city">
            <option>--选择城市--</option>
          </select>
        </span>
      </div>
    </body>
  </html>
#+END_SRC
[[./SourceCode/68.html]]
#+BEGIN_SRC html
  <!DOCTYPE HTML>
  <html>
    <head>
      <title>table练习</title>
      <meta http-equiv="content-type" content="text/html; charset=UTF-8">
      <style type="text/css">
        body{
            font-family: "微软雅黑"
        }
        h2, h4{ text-align: center; }
        div#box1, div#box2 {
            text-align:center;
        }
        hr{
            margin: 20px 0;
        }
        table{
            margin: 0 auto;
            width: 70%;
            text-align: center;
            border-collapse:collapse;
        }
        td, th{padding: 7px; width:20%;}
        th{
            background-color: #DCDCDC;
        }
      </style>

      <!--引入jquery的js库-->
      <script src="../other/jquery-1.4.2.js"></script>
      <script type="text/javascript">
        //html文档加载完执行
        $(function(){
          //为"添加"按钮绑定点击事件(点击按钮添加员工信息到table中)
          $("#add").click(function(){
            //获取输入员工信息
            //拓展：$.trim()清除用户输入内容前后的空格
            var id = $.trim($("#box1 input[name='id']").val());
            var name = $.trim($("#box1 input[name='name']").val());
            var email = $.trim($("#box1 input[name='email']").val());
            var salary = $.trim($("#box1 input[name='salary']").val());
            //校验员工信息
            //员工信息不能为空
            if(id == "" || name == "" || email == "" || salary == ""){
              alert("员工信息不能为空");
              //打断代码，防止继续添加数据
              return;
            }

            //邮箱格式校验
            //lishuai@tedu.cn
            var reg = /\w+@\w+(\.\w)+/;
            if(!reg.test(email)){
              alert("邮箱格式不正确！");
              return;
            }

            //id重复校验
            //如何获取页面中已有的id，将用户输入的id与页面中已有的id比较，如果id相同则证明id已经存在，反之则不存在
            var flag = false;
            $("table tr").each(function(){
              //获取第二个td的文本内容，注意：不是val()当前td不包含value
              //判断id是否等于每行第二个td内的文本, 即id
              if($(this).find("td:eq(1)").text() == id){
                alert("ID已存在！");
                flag = true;
                return false;
              }
            });
            if(flag){
              return;
            }

            //将新员工的信息插入到员工列表中
            var $tab = $("table");
            var $tr = $("<tr></tr>");
            var $td0 = $("<td><input type='checkbox'></td>");
            var $td1 = $("<td>"+id+"</td>");
            var $td2 = $("<td>"+name+"</td>");
            var $td3 = $("<td>"+email+"</td>");
            var $td4 = $("<td>"+salary+"</td>");
            //将td添加到tr中
            $tr.append($td0).append($td1).append($td2).append($td3).append($td4);
            $tab.append($tr);
          });

          //为全选按钮绑定点击事件
          $("#all").click(function(){
            //所有的checkbox与第一行的checkbox的选中属性保持一致
            //先获取第一行的checkbox选中属性
            //获取全选状态
            var check = $(this).attr("checked");
            //使全部的checkbox选中属性与第一行的选中属性相同
            $("table input[type='checkbox']").attr("checked",check);
          });

          //为"删除"绑定点击事件(点击"删除",删除所选员工信息)
          $("#del").click(function(){
            //不能删除第一行
            //删除选中行
            //1. 找到选中行
            $("input:checked:not(#all)").parents("tr").remove();
          });

          //为"修改"绑定点击事件(点击"修改",修改指定ID的员工信息)
          $("#upd").click(function(){
            //在页面中寻找所有的id，然后与用户输入的id相比较，如果有则修改数据，如果没有则提示错误
            //获取修改的员工信息
            var id = $.trim($("#box2 input[name='id']").val());
            var name = $.trim($("#box2 input[name='name']").val());
            var email = $.trim($("#box2 input[name='email']").val());
            var salary = $.trim($("#box2 input[name='salary']").val());
            //非空校验
            if(id == "" || name == "" || email == "" || salary == ""){
              alert("修改的信息不能为空!");
              //打断代码，防止继续添加数据
              return;
            }
            //根据ID修改对应的信息
            var flag = true;
            $("table tr").each(function(){
              //在页面中寻找所有的id，然后与用户输入的id相比较，如果有则更新，如果没有则提示错误
              if($(this).find("td:eq(1)").text() == id){
                //进行修改
                $(this).find("td:eq(2)").text(name);
                $(this).find("td:eq(3)").text(email);
                $(this).find("td:eq(4)").text(salary);
                flag = false;
                return false;
              }
            })
            if(flag){
              alert("修改的员工ID不存在！");
            }
          });
        })
      </script>
    </head>
    <body>
      <h2>添加新员工</h2>
      <div id="box1">
        ID：<input type="text" name="id"/>
        姓名：<input type="text" name="name"/>
        邮箱：<input type="text" name="email"/>
        工资：<input type="text" name="salary"/>
        <input type="button" id="add" value="添加"/>
      </div>
      <hr/>
      <table border="1">
        <tr>
          <th>
            <input type="checkbox" id="all"/>
            <!--全选-->
          </th>
          <th>ID</th>
          <th>姓名</th>
          <th>邮箱</th>
          <th>工资</th>
        </tr>
        <tr>
          <td>
            <input type="checkbox"/>
          </td>
          <td>1</td>
          <td>宋江</td>
          <td>sj@163.com</td>
          <td>12000</td>
        </tr>
        <tr>
          <td>
            <input type="checkbox"/>
          </td>
          <td>2</td>
          <td>武松</td>
          <td>ws@163.com</td>
          <td>10500</td>
        </tr>
        <tr>
          <td>
            <input type="checkbox"/>
          </td>
          <td>3</td>
          <td>孙二娘</td>
          <td>sen@163.com</td>
          <td>11000</td>
        </tr>
      </table>
      <h4><a href="#" id="del">删除选中</a></h2>
  <hr/>
  <div id="box2">
    ID：<input type="text" name="id"/>
    姓名：<input type="text" name="name"/>
    邮箱：<input type="text" name="email"/>
    工资：<input type="text" name="salary"/>
    <input type="button" id="upd" value="修改"/>
  </div>
  </body>
  </html>
#+END_SRC
[[./SourceCode/69.html]]
* Git
file:./other/Git.pdf
* MySQL
[[./Img/mysql.png]]
** 1. 数据库概述
    1. 数据库的概念
       数据路：存储数据的仓库
       数据路类型：层次式数据路，网络式数据路，关系型数据库
    2. 关系型数据路
       - 使用关系模型来存储的数据的数据路叫做关系型数据路
         常见数据库
         - 商业数据路
           Oracle、SQLServer、DB2、Sybase
         - 开源数据路
           MySQL、SQLLite
    3. MySQL数据路的安装和配置
       [[./Img/18.png]]
       [[./Img/19.png]]
    4. MySQL数据库服务器、数据库和表的关系
       所谓安装数据库服务器，只是在机器上装可一个数据库管理程序，这个管理程序可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据路创建多个表，以保存程序中实体的数据。

       数据库服务器、数据库和表的关系如图所示：
       [[./Img/20.png]]
    5. 数据在数据库中的存储方式
       [[./Img/21.png]]
       列也称之为字段或者域
    6. SQL语言
       - Structured Query Language,结构化查询语言
       - 非过程性语言
       - 美国国家标准局（ANSI）与国际标准化组织（ISO）已经制定了SQL标准
       - 为加强SQL的语言能力，各厂商增强了过程性语言的特征
         - 如Oracle的PL/SQL过程性处理能力
         - SQL Server、Sybase的T-SQL
       - SQL是用来存取关系数据库的语言，具有查询、操纵、定义和控制关系型数据库的四方面功能。
** 2. SQL语句---库、表操作
    1. 创建数据库
       #+BEGIN_SRC sql
         CREATE DATABASE [IF NOT EXISTS] db_name [create_specification[,create_specification]...] create_specification:    7
         [DEFAULT] CHARACTER SET charset_name  |  [DEFAULT] COLLATE collation_name
       #+END_SRC
       CHARACTER SET:指定数据库采用的字符集

       COLLATE：指定数据库字符集的比较方式

       （查看mysql存储位置：show global variables like "%datadir%";）

       #+BEGIN_SRC
         练习：
             1. 创建一个名称为mydb1的数据库
                create database mydb1;
             2. 创建一个使用utf8字符集的mydb2数据库
                create database mydb2 character set utf8;
             3. 创建一个使用utf8字符集，并带校对规则的mydb3数据库
                create database mydb3 character utf8 collate utf8_bin
       #+END_SRC
    2. 查看、删除数据库
       - 显示数据库语句：
         #+BEGIN_SRC sql
           SHOW databases
         #+END_SRC
       - 显示数据库创建语句：
         #+BEGIN_SRC sql
           SHOW CREATE DATABASE db_name
         #+END_SRC
       - 数据库删除语句：
         #+BEGIN_SRC sql
           DROP DATABASE [IF EXISTS] db_name
         #+END_SRC
       #+BEGIN_SRC
         练习：
             1. 查看当前数据库服务器中的所有数据库
                show databases;
             2. 查看当前创建mydb2数据库的定义信息
                show create database mydb2;
             3. 删除前面创建的mydb1数据库
                drop database mydb1
       #+END_SRC
    3. 修改数据库
       #+BEGIN_SRC sql
         ALTER DATABASE [IF NOT EXISTS] db_name [alter_specification [,alter_specification]...]alter_specification
         [DEFAULT] CHARACTER SET charset_name | [DEFAULT] COLLATE collation_name
       #+END_SRC
    4. 选择数据库
       #+BEGIN_SRC sql
         use db_name;
       #+END_SRC
       查看当前使用的数据库：
       #+BEGIN_SRC sql
         select database();
       #+END_SRC
    5. 创建表（基本语句）
       #+BEGIN_SRC sql
         CREATE TABLE table_name(
         column_name column_type,
         column_name column_type,
         column_name column_type,
         )[character set 字符集][collate 校对规则]
       #+END_SRC
       #+BEGIN_SRC sql
         create table user(
                id int,
                name varchar(10),
                password varchar(15),
                birthday date
         );
       #+END_SRC
       + 注意：创建表时，要根据需保存的数据创建相应的列，并根据数据的类型定义相应的列类型。例：user对象
         [[./Img/22.png]]
    6. MySQL常用数据类型
       - 字符串型
         + VARCHAR、CHAR
           varchar(20)存储的数据内容长度是可变的,char(20)存储的数据内容长度是固定的；char的查询速度快，因不会判断字段实际的长度。varchar最长能存255的长度，varchar(255)
       - 大数据类型BLOB、TEXT
         blob将图片以机器码的形式存入到数据库字段内
       - 数值型
         TINYINT、SMALLINT、INT、BIGINT、FLOAT、DOUBLE
       - 逻辑型
         BIT
       - 日期型
         DATE、TIME、DATETIME、TIMESTAMP
    7. 创建表练习
       创建员工表employee---查看表结构：desc表名;
       #+BEGIN_SRC
         字段：id、name、gender、birthday、entry_date、job、salary、resume
         属性：整型、字符型、字符型、日期型、日期型、字符型、小数型、大文本型
         创建完毕之后利用desc employee来查看表结构
       #+END_SRC
       #+BEGIN_SRC sql
         create table employee(
                id int,
                name varchar(10),
                gender char(2),
                birthday date,
                entry_date date,
                job varchar(20),
                salary double,
                resumen text
         );
       #+END_SRC
    8. 定义表单字段的约束
       - 定义主键约束
         + primary key：不允许为空，不允许重复
         + 删除主键：alter table tablename drop primary key;
         + 主键自动增长：auto_increment
       - 定义唯一约束
         + unique
         + 例如：name varchar(20)unique
       - 定义非空约束
         + not null
         + 例如：salary double not null
       - 外键约束
       #+BEGIN_SRC sql
         create table employee(
                id int primary key auto_incement,
                name varchar(10),
                gender char(2),
                birthday date,
                entry_date date,
                job varchar(20),
                salary double,
                resumen text
         );
        #+END_SRC
       #+BEGIN_SRC
         设置主键可以提升查询效率，依赖主键可以利用其身上的索引进行查询，利用索引查询较快。
         一般情况下，一张表都会有一个主键，且这个主键一般都是int类型。
         如果一个主键设置上auto_increment尚需经则这个字段一定会是一个主键字段，且这个字段的数据不需要数据库管理员来维护，这个字段的值会自动添加，并增长。
       #+END_SRC
    9. 查看表信息
       查看表结构：
       #+BEGIN_SRC sql
         desc tabName;
       #+END_SRC
       查看当前所有表：
       #+BEGIN_SRC sql
         show tables;
       #+END_SRC
       查看当前数据库表键表语句
       #+BEGIN_SRC sql
         show create table tabName;
       #+END_SRC
    10. 修改表
        使用ALTER TABLE语句追加，修改，或删除列的语法
        #+BEGIN_SRC sql
          ALTER TABLE table_name ADD column column_type [DEFAULT expr] [,column column_type]...;
          ALTER TABLE table_name MODIFY column column_type [DEFAULT expr] [,column column_type]...;
          ALTER TABLE table_name DROP column;
        #+END_SRC
        修改表的名称：
        #+BEGIN_SRC sql
          rename table 表名 to 新表名;
        #+END_SRC
        修改表的名称：
        #+BEGIN_SRC sql
          ALTER TABLE table change old_column new_column column_type;
        #+END_SRC
        修改表的字符集：
        #+BEGIN_SRC sql
          alter table user character set utf8;
        #+END_SRC
        - 练习：
          #+BEGIN_SRC
            在上面员工表的基本上增加一个image列
            alter table employee add image blob;
            修改job列，使其长度为60
            alter table employee modify job varchar(60);
            删除gender列
            alter table employee drop gender;
            表名改为emp
            rename table employee to emp;
            修改表的字符集为utf8
            alter table emp character set utf8;
            列名name修改为username
            alter table emp change name username;
          #+END_SRC
    11. 删除表
        #+BEGIN_SRC sql
          drop table tabName;
        #+END_SRC
** 3. 数据库的CRUD
    1. 数据库表记录CRUD语句
       - insert语句（增加数据）
       - Update语句（更新数据）
       - Delete语句（删除数据）
       - Select语句（查找数据）
    2. INSERT语句
       #+BEGIN_SRC sql
         INSERT INTO table_name [(column [,column...])] VALUES (value [,value...]);
       #+END_SRC
       - 插入的数据应与字段的数据类型相同
       - 数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中
       - 在values中列出的数据位置必须与被加入的列的排列位置相对应
       - 字符和日期型数据应包含在单引号中
       - 如果一个字段是自增字段，则这个字段不需要用户添加数据，填写一个null值即可自动增长。
       - 插入空值：不指定或insert into table value（null）
       - 如果要插入所有字段可以省写列列表，直接按表中字段顺序写值列表
       - 由于在表名之后没有指定要插入的字段，所以在values后需要添加上全部字段的值，并且这些值必须按照表中字段顺序书写
         #+BEGIN_SRC sql
           insert into employee(id,name) values(2,'lg');
         #+END_SRC
         在插入数据的时候可以在表名之后添加上指定的字段名称，values书写的数据必须按照指定的字段名称顺序书写数据。
       - 使用包含主键的表中插入数据时，请注意如下内容：
         1. 创建一个包含主键的表
            #+BEGIN_SRC sql
              create table zhujian(
                                   id int primary key auto_increment,name varchar(10),
                                   gender char(2),
                                   birthday date,
                                   entry_date date,
                                   job varchar(20),
                                   salary double,
                                   resumen text
                                   );
            #+END_SRC
         2. 插入数据
            设置主键的字段在插入数据是要输入null
            #+BEGIN_SRC sql
              insert into zhujian values(null,'ks','m','1999-09-09','2000-09-09','eat',5000.0,'can eat');
            #+END_SRC
       #+BEGIN_SRC
         insert语句练习
             使用insert语句向employee表中插入三个员工的信息
             字段名：id、name、gender、birthday、entry_date、job、salary、resume
             字段类型：整型、字符串型、字符串型、日期型、日期型、字符串型、浮点型、大文本型
       #+END_SRC
       #+BEGIN_SRC sql
         insert into employee values(1,'ls','m','1999-09-09','2000-09-09','eat',5000.0,'can eat');
       #+END_SRC
       - TIP：mysql中文乱码
         修改当前窗口字符集的方式：
         #+BEGIN_SRC sql
           set names gbk;
         #+END_SRC
         - 查看是否修改成功
           #+BEGIN_SRC sql
             show variables like "%char%";
           #+END_SRC
         - mysql有六处使用了字符集，分别为：client、connection、database、results、server、system
         - client是客户端使用的字符集
         - connection是连接数据库的字符集设置类型，如果程序没有指明连接数据库使用的字符集类型就按照服务器默认的字符集设置
         - database是数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装时指定的字符集设置
         - results是数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集
         - server是服务器安装时指定的默认字符集设定
         - system是数据库系统使用的字符集设定（utf-8不可修改）
           show variables like'character%';

           set names gbk;临时修改当前CMD窗口和mysql的通信编码字符集
         - 通过修改my.ini修改字符集编码
           请到mysql安装目录下面找到my.ini文件

           修改default-character-set=utf8为default-character-set=gbk

           有两个地方都要改

           修改文件前，先停止mysql服务，等修改后再重新启动

           使用dos命令：net stop mysql 来停止服务 net start mysql来启动
         [[./Img/38.gif]]
    3. Update语句
       使用update语句修改表中数据
       #+BEGIN_SRC sql
         update table_name
         set col_name1=expr1 [,col_name2=expr2 ...] [where where_definition]
       #+END_SRC
       update语法可以用新值更新原有表行中的各列

       set子句指示要修改哪些列和要给予哪些值

       where子句指定更新哪些行，如没有where子句，则更新所有的行
       #+BEGIN_SRC
         update语句练习：
             在上面创建的employee表中修改表中的记录
             要求：
                 将所有员工薪水修改为5000元
                 将姓名为'zs'的员工薪水修改为3000元
                 将姓名为'lisi'的员工薪水修改为4000元，job改为ccc
                 将'wu'的薪水在原有基础上增加1000元
       #+END_SRC
       #+BEGIN_SRC sql
         update employee set salary = 5000;
         update employee set salary = 3000 where name = 'zs';
         update employee set salary = 4000,job='ccc' where name = 'ls';
         update employee set salary = salary + 1000 where name = 'wu';
       #+END_SRC
    4. Delete语句
       使用delete语句删除表中数据
       #+BEGIN_SRC sql
         delete from table_name [where where definition]
       #+END_SRC
       - 如果不使用where子句，将删除表中所有数据
       - delete语句不能删除某一列的值（可使用update）
         + update table_name set 字段名='';
       - 使用delete语句仅删除记录，不删除表本身，如要删除表，使用drop table语句
         + drop table table_name;
       - 同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应该始终不要忘记这个潜在的问题
       - 外键约束
       - 删除表中数据也可使用truncate table语句，它和delete有所不同，参看mysql文档
       - delete from只删除当前表中的数据，对表结构不产生影响。
         truncate会将整个表摧毁，然后依赖原有的表结构创建整张表；
         + 注意：truncate删除单表没有问题，而且删除效率较高，但是可能对表与表之间的关系产生不可恢复的影响。如果多表操作不建议使用truncate。
       #+BEGIN_SRC
         删除表中名称为'zs'的记录
         删除表中所有记录
         使用truncate删除表中记录
       #+END_SRC
       #+BEGIN_SRC sql
         delete from employee where name = 'zs';
         delete from employee;
         truncate employee;
       #+END_SRC
    5. select语句（1）
       基本select语句
       #+BEGIN_SRC sql
         select [distinct] *| {column1,column2,column3...}from table;
       #+END_SRC
       select指定查询哪些列的数据,column指定列名,*号代表查询所有列,from指定查询哪张表,DISTINCT可选，指显示结果时，是否剔除重复数据
       + 注意：书写全部字段名称比书写*查询效率要高。
       #+BEGIN_SRC sql
         select distinct name from employee;
       #+END_SRC
       #+BEGIN_SRC
         查询表中所有学生的信息
         查询表中所有学生的姓名和对应的英语成绩
         过滤表中重复数据，distinct去重
       #+END_SRC
       #+BEGIN_SRC sql
         create table exam(id int primary key auto_increment,name varchar(20) not null,chinese double,math double,english double);
         insert into exam values(null,'关羽',85,76,70);
         insert into exam values(null,'张飞',70,75,70);
         insert into exam values(null,'赵云',90,65,95);

         select * from exam;
         select name,english from exam;
         select distinct english from exam;
       #+END_SRC
    6. select语句（2）
       在select语句中可使用表达式对查询的列进行运算
       #+BEGIN_SRC sql
         select * | {column1 | expression,column2 | expression,..} from table;
       #+END_SRC
       在select语句中可使用as语句
       #+BEGIN_SRC sql
         select column as 别名 from 表名;
       #+END_SRC
       #+BEGIN_SRC
         在所有学生分数上加10分特长分显示
         统计每个学生的总分
         使用别名表示学生总分
       #+END_SRC
       #+BEGIN_SRC sql
         select name,math+10,chinese+10,english+10 from exam;
         select name,math+chinese+english from exam;
         select name,math+chinese+english as sum  from exam;
         select name,math+chinese+english sum from exam;
       #+END_SRC
    7. select语句（3）
       #+BEGIN_SRC
         使用where子句，进行过滤查询：
             查询姓名为xxx的学生成绩
             查询英语成绩大于90分的同学
             查询总分大于200分的所有同学
       #+END_SRC
       #+BEGIN_SRC sql
         select * from exam where name='张飞';
         select * from exam where english>90;
         select * from exam where math+chinese+english >230;
         select name,math+chinese+english as sum from exam where math+chinese+english >230;
       #+END_SRC
       + 注意：关键字查询顺序
         form > where > select
    8. select语句（4）
       在where子句中经常使用的运算符
       [[./Img/23.png]]
       [[./Img/24.png]]
       [[./Img/25.png]]
       [[./Img/26.png]]
       [[./Img/27.png]]
       [[./Img/28.png]]
       like语句中，%代表零个或多个任意字符，_代表一个字符，例first_name like '_a%';
       #+BEGIN_SRC sql
         select * from user where id is null;
         select ifnull(score,0) from exam;
         select ifnull(math,0) from exam;
       #+END_SRC
       #+BEGIN_SRC
         查询英语分数在80~100之间的同学
         查询数学分数为75，76，77的同学
         查询所有姓张的学生成绩
         查询数学分>70,语文分>80的同学
         查询数学分>70或者英语分<70的同学
         查询语文成绩不大于80的同学
         查询数学成绩为空(null)的同学
         查询所有同学的成绩，如果成绩中出现null则使用0分来代替
       #+END_SRC
       #+BEGIN_SRC sql
         select english from exam where english between 80 and 100;
         select name,math from exam where math in(75,76,80);
         select * from exam where name like '张%';
         select * from exam where math > 70 and chinese > 80;
         select * from exam where math>70 or english < 70;
         select * from exam where not (chinese > 80);
         select * from exam where math is null;
         select name,ifnull(math,0),ifnull(chinese,0),ifnull(english,0) from exam;
       #+END_SRC
    9. select语句（5）
       使用order by子句排序查询结果
       #+BEGIN_SRC sql
         select column1,column2,column3.. from table order by column asc|desc
       #+END_SRC
       Order by指定排序的列，排序的列既可是表中的列名，也可以是select语句后指定的列名,Asc升序（默认）、Desc降序,order by子句应位于select语句的结尾
       #+BEGIN_SRC
         对语文成绩排序后输出
         对总分排序按从高到低的顺序输出
         对姓李的学生成绩排序输出
       #+END_SRC
       #+BEGIN_SRC sql
         select chinese from exam order by chinese asc;
         select name,ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0) as sum from exam order by sum;
         select name,ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0) as sum from where name like '李%' order by sum;
       #+END_SRC
       + 注意：数据库关键字执行顺序
         from > where > select > order by
    10. 聚集函数 - count
        count(列名)返回某一列，行的总数
        #+BEGIN_SRC sql
          select count(*) | count(列名) from table_name [where where_definition]
        #+END_SRC
        #+BEGIN_SRC sql
          select count(math) from exam;
        #+END_SRC
        #+BEGIN_SRC
          练习：
              统计一个班级共有多少学生？
              统计数学成绩大于90的学生有多少人？
              统计总分大于230的人数有多少？
        #+END_SRC
        #+BEGIN_SRC sql
          select count(*) from exam;
          select count(math) from exam where math > 90;
          select count(name) from exam where ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0) > 230;
        #+END_SRC
    11. 聚集函数 - sum
        sum函数返回满足where条件的行的和
        #+BEGIN_SRC sql
          select sum(列名) {,sum(列名)...} from table_name[where where_definition]
        #+END_SRC
        #+BEGIN_SRC
          练习：
              统计一个班级数学总成绩？
              统计一个班级语文、英语、数学各科的总成绩
              统计一个班级语文、英语、数学的成绩总和
              统计一个班级语文成绩平均分
        #+END_SRC
        #+BEGIN_SRC sql
          select sum(math) from exam;
          select sum(chinese),sum(english),sum(math) from exam;
          select sum(ifnull(chinese,0)+ifnull(math,0)+ifnull(english,0)) from exam;
          select sum(ifnull(chinese,0)+ifnull(math,0)+ifnull(english,0)) / count(name) from exam;
        #+END_SRC
        + 注意：sum仅对数值起作用，否则会报错
        + 注意：对多列求和，","号不能少
    12. 聚集函数 - AVG
        AVG函数返回满足where条件的一列的平均值
        #+BEGIN_SRC sql
          select avg(列名) {,avg(列名)...} from table_name [where where_definition]
        #+END_SRC
        #+BEGIN_SRC
          练习：
              求一个班级数学平均分？
              求一个班级总分平均分？
        #+END_SRC
        #+BEGIN_SRC sql
          select avg(math) from exam;
          select avg(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) from exam;
        #+END_SRC
    13. 聚集函数 - max/min
        max/min函数返回满足where条件的一列的最大/最小值
        #+BEGIN_SRC sql
          select max(列名) from table_name [where where_definition]
        #+END_SRC
        #+BEGIN_SRC
          练习：
              求班级最高分和最低分（数值范围在统计中特别有用）
              选择表中语文成绩最高分的同学的姓名和成绩
        #+END_SRC
        #+BEGIN_SRC sql
          select max(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) from exam;
          select min(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) from exam;
          select name,max(chinese) from exam where chinese in (select max(chinese) from exam);
        #+END_SRC
    14. select语句（6）分组操作
        [[./Img/29.png]]
        使用group by子句对列进行分组,在根据某一个字段分组之后，表中其他字段的数据会只显示第一条，其他的数据都会被隐藏，但是仍然可以通过聚集函数捕获到这样隐藏起来的值。在分组过程中可以使用多个分组字段，会一次根据分组条件进行划分。
        #+BEGIN_SRC sql
          select column1,column2,column3... from table
          group by column having ...
        #+END_SRC
        创建表：
        #+BEGIN_SRC sql
          create table c (id int,cdate date,camount int);
          insert into c values(1,'2007-07-09',7);
          insert into c values(2,'2007-07-09',3);
          insert into c values(2,'2007-07-10',3);
          insert into c values(2,'2007-07-11',1);
        #+END_SRC
        #+BEGIN_SRC sql
          select id,camount
          select id,count(*),camount from c group by id,camount;
        #+END_SRC
        #+BEGIN_SRC
          练习：对订单表中商品归类后，显示每一类商品的总价
              使用having子句，对分组结果进行过滤
        #+END_SRC
        #+BEGIN_SRC
          练习：查询购买了几类商品，并且每类总价大于100的商品
        #+END_SRC
        创建表
        #+BEGIN_SRC sql
          create table orders(id int,product varchar(20),price float);
          insert into orders(id,product,price) values(1,'电视',900);
          insert into orders(id,product,price) values(2,'洗衣机',100);
          insert into orders(id,product,price) values(3,'洗衣粉',90);
          insert into orders(id,product,price) values(4,'桔子',9);
          insert into orders(id,product,price) values(5,'洗衣粉',90);
        #+END_SRC
        #+BEGIN_SRC sql
          select product,sum(price) from orders group by product having sum(price)>100;
        #+END_SRC
        - where和having区别：
          在分组之前条件判断使用where，在分组之后条件判断使用having，使用having的位置不能用where替换，而使用where的位置可以使用having替换。
          ---分组之前可以使用where或者having
          ---分组之后只能使用having
** 4. 备份、回复数据库
    1. 备份数据库表中的数据
       cmd>mysqlump -u 用户名 -p 数据库名> 文件名.sql

       mysqldump -uroot -p db_name >/Users/admin/Desktop/1.sql
    2. 恢复数据库
       （注意：如果数据库已经删除，先创建数据库在回复数据）
       - 方式一：在cmd中
         mysql -u用户名 -p 数据库名 < 文件名.sql

         mysql -uroot -p db_name < d:/1.sql

         mysql -uroot -p mydb3 < d:/1.sql
       - 方式二：在mysql客户端中
         source 文件名.sql
         source d:/1.sql
    3. 练习
       备份test库中的数据，并恢复
** 5. 多表设计
    1. 多表设计--外键约束
       定义外键约束
       #+BEGIN_SRC sql
         foreign key(ordersid) references orders(id)
       #+END_SRC
    2. 多表设计中三种实体关系
       1. M:N的联系引入关系表
          联系的属性及两个实体的主标识形成关系表

          关系表的主键为两个实体主标识的组合
          [[./Img/30.png]]
       2. 1:N的联系可不引入关系表
          将关系的属性及非多方的主标识加入到多方表

          多方表的外键是非多方实体的主标识
          [[./Img/31.png]]
       3. 1:1的联系不必引入关系表
          [[./Img/32.png]]
** 6. 外键约束
    1. 外键
       - 用来通知数据库表与表字段之间的对应关系，并让数据库帮我们维护这样关系的键叫做外键
       - 外键作用：维护数据的完整性、一致性
       - 定义外键约束
         #+BEGIN_SRC sql
           foreign key(ordersid) references orders(id)
         #+END_SRC
       - 外键在面对高并发和高吞吐的时候不推荐使用。，如果使用外键会影响数据进入数据库，在面对大量数据的时候应该先保证数据入库，在处理数据的正确性，也可以通过后期的代码保证。
    2. 案例
       新建部门表dept(id,name),通过外键约束建立与员工表emp关系
       #+BEGIN_SRC sql
         create table dept(
                           id int primary key auto_increment,
                           name varchar(20)
                          );
       #+END_SRC
       #+BEGIN_SRC sql
         insert into dept values(null,'财务部');
         insert into dept values(null,'人事部');
         insert into dept values(null,'科技部');
         insert into dept values(null,'销售部');
       #+END_SRC
       #+BEGIN_SRC sql
         create table emp(
                          id int primary key auto_increment,
                          name varchar(20),
                          dept_id int,
                          foreign key(dept_id) references dept(id)
                         );
       #+END_SRC
       #+BEGIN_SRC sql
         insert into emp values(null,'张三',1);
         insert into emp values(null,'李四',2);
         insert into emp values(null,'老王',3);
         insert into emp values(null,'赵四',4);
         insert into emp values(null,'刘能',4);
       #+END_SRC
** 7. 多表查询
    1. 多表查询
       案例：
       #+BEGIN_SRC sql
         create table dept(
                           id int primary key auto_increment,
                           name varchar(20)
                          );
       #+END_SRC
       #+BEGIN_SRC sql
         insert into dept values(null,'财务部');
         insert into dept values(null,'人事部');
         insert into dept values(null,'科技部');
         insert into dept values(null,'销售部');
       #+END_SRC
       #+BEGIN_SRC sql
         create table emp(
                          id int primary key auto_increament,
                          name varchar(20),
                          dept_id int
                         );
       #+END_SRC
       #+BEGIN_SRC sql
         insert into emp values(null,'张三',1);
         insert into emp values(null,'李四',2);
         insert into emp values(null,'老王',3);
         insert into emp values(null,'刘能',5);
       #+END_SRC
       - 需求：查询出部门信息和部门所对应的员工信息
         #+BEGIN_SRC sql
           select * from dept,emp;
         #+END_SRC
    2. 笛卡尔积查询
       - 概念
         两张表相乘得出来的结果，如果左边表有m条记录，右边有n条记录，则查询出来的结果就是m*n条。这些查询结果中包含大量错误的结果，通常不会使用这种查询
         [[./Img/33.png]]
         #+BEGIN_SRC sql
           select * from dept,emp;
           select * from dept,emp where emp.dept_id=dept.id;
           select * from dept d,emp e where e.dept_id=d.id;
         #+END_SRC
    3. 内连接查询
       - 卸载inner join左侧的表称之为左边表，右侧的表称之为右边表。
       - 内连接查询概念：左边表有且右边表也有的记录;
       [[./Img/34.png]]
       #+BEGIN_SRC sql
         select * from dept d inner join emp e on e.dept_id=d.id;
         select emp.name,dept.name from dept inner join emp on dept.id=emp.dept_id;
         select emp.name as 姓名,dept.name as 部门 from dept inner join emp on dept.id = emp.dept_id;
         select e.name as 姓名,d.name as 部门 from dept d inner join emp e on d.id = e.dept_id;
       #+END_SRC
    4. 左、右连接查询以及全连接查询
       - 左连接查询：在内连接查询的基础上，加上左边表有而右边表没有的记录
         **添加数据
         #+BEGIN_SRC sql
           insert into dept values(null,'市场部');
         #+END_SRC
         **查询出部门所对应的员工信息，同时列出那些没有员工的部门
         #+BEGIN_SRC sql
           select * from dept d left join emp e on e.dept_id=d.id;
         #+END_SRC
       - 右外连接查询：在内连接查询的基础上，加上右边表有而左边表没有的记录
         **添加数据
         #+BEGIN_SRC sql
           insert into emp values(null,'路飞',6);
         #+END_SRC
         **查询出部门所对应的员工信息，同时列出那些没有部门的员工
         #+BEGIN_SRC sql
           select * from dept d right join emp e on e.dept_id=d.id;
         #+END_SRC
       - 全外连接查询：在内连接查询的基础上，加上左边表有而右边表没有的记录和右边表而左边表没有的记录
         union是一个联合查询的关键字，在这个关键字结果中，如果有相同的结果数据，则只会保留一份相同的数据。
         **查询出部门所对应的员工信息，同时列出那些没有员工的部门及那些没有部门的员工
         #+BEGIN_SRC sql
           select * from dept d full join emp e on e.dept_id=d.id;
           ## mysql不支持全外连接查询
         #+END_SRC
         **通过union关键字来模拟全外连接查询
         #+BEGIN_SRC sql
           select * from dept left join emp on emp.dept_id=dept.id
           union
           select * from dept right join emp on emp.dept_id=dept.id;
         #+END_SRC
** 8. 扩展
    1. mysql查询关键字执行顺序
       查询中用到的关键字主要包含六个，并且他们的顺序依次为：

       select--from--where--group by--having--order by

       其中select和from是必须的，其他关键词是可选则，这六个关键字的执行顺序，与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行

       from--where--group by--having--select--order by
       + 注意：
         1. 虽然select在having后执行，但是mysql中仍然可以在having中使用select语句定义的别名。

            原因分析：mysql在查询的时候会产生一个临时表，所有的字段名称（别名）在临时表中已经产生，产生了临时表之后才会进行having操作。也就是说mysql内部有一定的解析顺序，解析顺序select优先于having。
         2. Oracle中having无法使用select语句内的别名
    2. insert into和replace into和merge into
       1. insert into是mysql的基本插入语句
       2. replace into是mysql中的代替插入语句，可以理解为insert into的升级版。replace into在执行的时候，首先会根据指定的主键或者唯一索引判断当前表中是否存在指定的主键或索引，如果主键或唯一索引已经存在，则先将对应的索引的数据删除，然后在索引位置插入replace into中包含的数据。如果主键和唯一索引没有存在，则直接在索引位置插入replace into中包含的数据
       3. merge into是oracle数据库中的代替插入语句。实现方式和replace into类似
       4. 执行效率
          1. 如果指定索引位置没有数据，insert into和replace into执行效率相差无几，二者效率相同
          2. 如果指定位置索引已经存在，insert into语句不能正常执行，replace into语句可以正常执行
       5. 注意：
          虽然replace into比较好实用，但是也存在一定风险：
          1. replace每次要重新分配自增id;
          2. replace中执行delete时，在有外键的情况下会很麻烦;
          3. 如果delete时定义的有触发器，则会被执行
          4. 副作用也会被传播到replica slave
       6. 推荐使用insert into ... on duplicate key update
          on duplicate key update是mysql特有的一个sql关键字，只能在mysql中使用。在mysql数据库中，如果在insert语句后面带上on duplicate key update子句，而要插入的行与表中现有记录的唯一索引或主键中产生重复值，那么就会发生旧行的更新；如果插入的行数据与现有表中记录的唯一索引或者主键不重复，则执行新记录插入操作。比如有这样一张表：
          #+BEGIN_SRC sql
            cteate table func(id int primary key,count int,birthday date);
            insert into func values(1,1,'1990-09-09');
          #+END_SRC
          [[./Img/35.png]]
          #+BEGIN_SRC sql
            insert into func values(1,1,'1990-09-09')onduplicate key update count=count+1;
          #+END_SRC
          删除元表数据，将新数据插入
          [[./Img/36.png]]
          提示两行收到影响，说明先执行的删除操作，然后插入新的数据
          [[./Img/37.png]]
          观察到没有任何新数据插入，count字段被更新。（count字段更新是因为刚刚的插入语句中书写了update count=count+1;）

          如果不希望任何字段更新，可以写成如下格式：
          #+BEGIN_SRC sql
            insert into func values(1,1,'1990-09-09')on duplicate key update=values(count);
          #+END_SRC
          再次执行，没有新数据插入到数据库中
    3. mysql内置函数
    4. 在已经存在的表中添加外键
       #+BEGIN_SRC sql
         alter table tb_name add constraint fk_name foreign key(tb_name.id)references tb_stu(id);
       #+END_SRC
       例如:
           #+BEGIN_SRC sql
           alter table emp add constraint forkey foreign key(dept_id)references dept(id);
           #+END_SRC
           该语句是在tb_name表上添加一个外键约束，引用tb_stu的主键，fk_name是约束的名字

           删除约束：
           #+BEGIN_SRC sql
             alter table tb_name drop constraint fk_name;
           #+END_SRC
    5. 外键的使用情景：
       在不要求吞吐速度而对数据的正确性和安全性，推荐使用外键

       如果面对高吞吐量，要求优先保证读取效率时，则不推荐使用外键
    6. 删除的时候使用别名
       原句：
       #+BEGIN_SRC sql
         delete from employee where id=1;
       #+END_SRC
       别名：
       delete e fromemployee as e where id=1;
* JDBC
[[./Img/JDBC.png]]
** JDBC概述
1. 知识回顾
   [[./Img/39.png]]
2. 概述
   [[./Img/40.png]]
   - 驱动
     - 为了能让程序员利用java程序操作数据库，数据库厂商提供了一套jar包，通过导入这个jar包就可以直接调用其中的方法操作数据库，这个jar包称之为驱动。
       + 两个数据路驱动互不兼容
     - 行业中有很多中的数据库，要使用这么多数据库需要学习很多数据库驱动，对于程序员来说学习成本非常高。
     - 想要让java程序兼容数据库，所有的数据库驱动都实现了jdbc这套接口。
   - JDBC简介：
     - JDBC全称为：Java Data Base Connectivity(java数据库连接)，它主要由接口组成。
       + 组成JDBC的2个包：
         java.sql包、javax.sql包
       + 开发JDBC应用需要以上2个包的支持外，还需要导入相应JDBC的数据库实现(即数据库驱动)
         [[./Img/41.png]]
       + 不仅需要jdbc接口，还需要驱动这个实现，驱动中就是对jdbc接口的一些实现。
3. java程序中引入mysql数据库驱动包
   1. 课前资料找到mysql-connector-java-5.0.8-bin.jar文件
   2. 在项目下创建一个新的lib目录
      [[./Img/42.png]]
   3. 将jar包复制粘贴到项目中的lib目录下
      [[./Img/43.png]]
   4. 右键点击lib下的包，选择Build Path -> add to build path
      [[./Img/44.png]]
** 详解JDBC六步
1. 程序详解--DriverManager
   - JDBC程序中的DriverManager用于加载驱动，并创建于数据库的链接，这个API的常用方法：
     #+BEGIN_SRC java
       DriverManager.registerDriver(new Driver());
       DriverManager.getConnection(url,user,password);
     #+END_SRC
   - 注意：在实际开发中并不推荐采用registerDriver方法注册驱动，原因有二：
     + 查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象。
     + 程序依赖mysql的API，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。
   - 推荐方式：
     #+BEGIN_SRC java
       //mysql5版本用
       Class.forName("com.mysql.jdbc.Driver");
       //mysql8版本用
       Class.forName("com.mysql.cj.jdbc.Driver");
     #+END_SRC
     + 采用此种方式不会导致驱动对象在内存中重复出现，并且采用此种方式，程序仅仅只需要一个字符串，不需要依赖具体的驱动，使程序的灵活性更高。
     + 同样，在开发中也不建议采用具体的驱动类型指向getConnection方法返回的connection对象。
2. 数据库URL
   URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为：

   [[./Img/45.png]]
3. 常用数据库URL地址的写法：
   - Oracle写法：jdbc:oracle:thin:@localhost:1521:sid
   - SQLServer：jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=sid
   - MySql:jdbc:mysql://localhost:3306/sid
   - MySql简写:jdbc:mysql:///sid
   常用属性：useUnicode=true&characterEncoding=UTF-8
4. 程序详解--Connection
   - jdbc程序中的Connection，它用于代表数据库的链接，Connection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法：
     + createStatement():创建向数据库发送sql的statement对象。
     + prepareStatement(sql):创建向数据库发送预编译sql的PrepareSatement对象。
     + prepareCall(sql):创建执行存储过程的callableStatement对象。
     + setAutoCommit(boolean autoCommit):设置事务是否自动提交。
     + commit():在链接上提交事务。
     + rollback():在此链接上回滚事务。
5. 程序详解--Statement
   - jdbc程序中的Statement对象用于向数据库发送SQL语句，Statement对象常用方法：
     + executeQuery(String sql):用于向数据发送查询语句。
     + executeUpdate(String sql):用于向数据库发送insert、update或delete语句。
     + execute(String sql):用于向数据库发送任意sql语句、
     + addBatch(String sql):把多余sql语句放到一个批处理中。
     + executeBatch():想数据库发送一批sql语句执行。
   - 子接口-preparedStatement
     有预编译功能，可以防止sql注入攻击
6. 程序详解--ResultSet
   - jdbc程序中的ResultSet用于代表sql语句的执行结果。ResultSet封装执行结果时，采用的类似于表格的方式。ResultSet对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next()方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。
   - ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法：
   - 获取任意类型的数据
     + getObject(int index)
     + getObject(String columnName)
   - 提问：数据库中列的类型是varchar，获取该列的数据调用什么方法？int类型呢？bigInt类型呢？Boolean类型？
7. 常用数据类型转换表
   [[./Img/46.png]]
8. ResultSet中的api
   - ResultSet还提供了对结果集进行滚动的方法：
     + next():移动到下一行
     + previous():移动到前一行
     + absolute(int row):移动到指定行
     + beforeFirst():移动resultSet的最前面
     + afterLast():移动到resultSet的最后面
9. 程序详解--释放资源
   - 为什么关闭资源？
     + 在安装数据库的时候，设置过最大连接数量，如果用了不还连接，别人就无法使用了。
     + rs对象中可能包含很多的一个数据，对象保存在内存中，这样就十分占用内存。需要将它关闭。
     + 最晚创建的对象，最先关闭。
   - jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet，Statement和Connection对象。
   - 特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正常的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。
   - 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。
10. 释放资源
    - 在关闭过程中可能会出现异常，为了能够关闭资源，需要将资源在finally中关闭。
    - 如果在finally中关闭资源则需要将conn,stat,rs三个对象定义成全局的变量。
    - 在conn,stat,rs三个变量出现异常的时候可能会关闭不成功，我们需要将他们在finally中置为null。conn,stat,rs这三个对象是引用，将引用置为null，它引用的对象就会被JVM回收，也能保证资源的释放。
#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import java.sql.*;

  public class Demo2 {

      public static void main(String[] args){
          Connection conn = null;
          Statement stat = null;
          ResultSet rs = null;
          try {
              //注册数据库驱动
              //1. 引入的驱动对象使用的是mysql驱动包中具体的类型，这样代码就和包名绑死在一起，如果需要更换数据库，则还需要修改代码中的包名
              //2. 用户手动注册一次数据库驱动，底层也注册一次数据库驱动，一共注册两次，两次注册可能会出现不必要的风险，所以只需要注册一次
              //DriverManager.registerDriver(new Driver());
              Class.forName("com.mysql.cj.jdbc.Driver");

              //获取数据库连接
              conn = DriverManager.getConnection
                  ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC", "root", null);
              //DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root&password=null");

              //创建传输器
              stat = conn.createStatement();

              //传输sql并返回结果
              rs = stat.executeQuery("select * from exam");

              //遍历结果
              while(rs.next()){
                  //next()调用的时候会先将光标向下移动一行
                  //如果向下移动的一行有效则返回true
                  //如果向下移动的一行无效则返回false
                  //利用返回值可以遍历整张则返回false
                  //利用返回值可以遍历整张表的数据
                  int id = rs.getInt(1);
                  String name = rs.getString("name");
                  System.out.println("id:"+id+">>>>name:"+name);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              //关闭资源
              //后创建的先关闭
              if(rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      rs = null;
                  }
              }
              if(stat != null) {
                  try {
                      stat.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      stat = null;
                  }
              }
              if(stat != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      conn = null;
                  }
              }
          }

      }
  }
#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import org.junit.Test;

  import java.sql.Connection;
  import java.sql.SQLException;
  import java.sql.Statement;
  import java.sql.DriverManager;

  /**
   ,* 向数据路mydb1.exam表插入和更新数据
   ,*/
  public class Demo3 {
      @Test
      public void add(){
          Connection conn = null;
          Statement stat = null;

          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection
                  ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root");
              stat = conn.createStatement();
              int count = stat.executeUpdate("insert into exam values(null,'鸣人',10,20,30)");
              if(count >0){
                  System.out.println("恭喜插入成功，受到影响的行数为："+count);
              }
          }catch(Exception e) {
              e.printStackTrace();
          }finally {
              if (stat != null) {
                  try {
                      stat.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      stat = null;
                  }
              }
              if (conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      conn = null;
                  }
              }
          }
      }
      @Test
      public void update(){
          Connection conn = null;
          Statement stat = null;
          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              conn = DriverManager.getConnection
                  ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root");
              stat = conn.createStatement();
              int count = stat.executeUpdate("update exam set chinese = 90 where id = 2");
              if(count >0){
                  System.out.println("更新成功，受到影响的行数为："+count);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              if(stat != null) {
                  try {
                      stat.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      stat = null;
                  }
              }
              if(conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      conn = null;
                  }
              }
          }
      }
  }
#+END_SRC
** JDBCUtils工具类
在类加载器启动的时候，可以读取当前类所在的工程的src目录，通过getClassLoader()方法获取类加载器，在使用getResource()获取src目录，在参数位置书写要获取的文件名称，最后通过getPath()方法获取String类型的路径返回值。
#+BEGIN_SRC java
  Properties prop = new Properties();
  prop.load(new FileInputStream(new File(JDBCUtils.class.getClassLoader().getResource("conf.properties").getPath())));
#+END_SRC
#+BEGIN_SRC
  driver = com.mysql.cj.jdbc.Driver
  url = jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC
  user = root
#+END_SRC

#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import cn.commandoptionesc.utils.JDBCUtils;
  import org.junit.Test;
  import java.sql.*;

  /**
   ,* 向数据路mydb1.exam表插入和更新数据
   ,*/
  public class Demo4 {
      @Test
      public void add(){
          Connection conn = null;
          Statement stat = null;

          try {
              conn = JDBCUtils.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("insert into exam values(null,'鸣人',10,20,30)");
              if(count >0){
                  System.out.println("恭喜插入成功，受到影响的行数为："+count);
              }
          }catch(Exception e) {
              e.printStackTrace();
          }finally {
              JDBCUtils.close(null,stat,conn);
          }
      }
      @Test
      public void update(){
          Connection conn = null;
          Statement stat = null;
          try {
              conn = JDBCUtils.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("update exam set chinese = 80 where id = 2");
              if(count >0){
                  System.out.println("更新成功，受到影响的行数为："+count);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils.close(null,stat,conn);
          }
      }
      @Test
      public void delete()  {
          Connection conn = null;
          Statement stat = null;
          try {
              conn = JDBCUtils.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("delete from exam where id = 6");
              if(count >0){
                  System.out.println("删除成功，受到影响的行数为："+count);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils.close(null,stat,conn);
          }
      }
      @Test
      public void select(){
          Connection conn = null;
          Statement stat = null;
          ResultSet rs = null;
          try {
              conn = JDBCUtils.getConnection();
              stat = conn.createStatement();
              rs = stat.executeQuery("select * from exam");
              while(rs.next()){
                  //next()调用的时候会先将光标向下移动一行
                  //如果向下移动的一行有效则返回true
                  //如果向下移动的一行无效则返回false
                  //利用返回值可以遍历整张则返回false
                  //利用返回值可以遍历整张表的数据
                  int id = rs.getInt(1);
                  String name = rs.getString("name");
                  System.out.println("id:"+id+">>>>name:"+name);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils.close(rs,stat,conn);
          }
      }
  }
#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc.utils;

  import java.sql.*;

  /**
   ,* 创建连接和关闭资源的工具类
   ,* 工具类中一般是通过类名.方法的形式来调用其中的方法的
   ,*/
  public class JDBCUtils {
      private JDBCUtils(){

      }
      /**
       ,* 创建连接
       ,* @throws Exception
       ,*/
      public static Connection getConnection() throws Exception {
          Class.forName("com.mysql.cj.jdbc.Driver");
          return DriverManager.getConnection
              ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root");
      }
      /**
       ,* 关闭资源
       ,*/
      public static void close(ResultSet rs, Statement stat, Connection conn){
          if(rs != null) {
              try {
                  rs.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  rs = null;
              }
          }
          if(stat != null) {
              try {
                  stat.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  stat = null;
              }
          }
          if(stat != null) {
              try {
                  conn.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  conn = null;
              }
          }
      }
  }

#+END_SRC

#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import cn.commandoptionesc.utils.JDBCUtils1;
  import org.junit.Test;
  import java.sql.*;

  /**
   ,* 向数据路mydb1.exam表插入和更新数据
   ,*/
  public class Demo5 {
      @Test
      public void add(){
          Connection conn = null;
          Statement stat = null;
          try {
              conn = JDBCUtils1.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("insert into exam values(null,'鸣人',10,20,30)");
              if(count >0){
                  System.out.println("恭喜插入成功，受到影响的行数为："+count);
              }
          }catch(Exception e) {
              e.printStackTrace();
          }finally {
              JDBCUtils1.close(null,stat,conn);
          }
      }
      @Test
      public void update(){
          Connection conn = null;
          Statement stat = null;
          try {
              conn = JDBCUtils1.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("update exam set chinese = 80 where id = 2");
              if(count >0){
                  System.out.println("更新成功，受到影响的行数为："+count);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils1.close(null,stat,conn);
          }
      }
      @Test
      public void delete()  {
          Connection conn = null;
          Statement stat = null;
          try {
              conn = JDBCUtils1.getConnection();
              stat = conn.createStatement();
              int count = stat.executeUpdate("delete from exam where id = 8");
              if(count >0){
                  System.out.println("删除成功，受到影响的行数为："+count);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils1.close(null,stat,conn);
          }
      }
      @Test
      public void select(){
          Connection conn = null;
          Statement stat = null;
          ResultSet rs = null;
          try {
              conn = JDBCUtils1.getConnection();
              stat = conn.createStatement();
              rs = stat.executeQuery("select * from exam");
              while(rs.next()){
                  //next()调用的时候会先将光标向下移动一行
                  //如果向下移动的一行有效则返回true
                  //如果向下移动的一行无效则返回false
                  //利用返回值可以遍历整张则返回false
                  //利用返回值可以遍历整张表的数据
                  int id = rs.getInt(1);
                  String name = rs.getString("name");
                  System.out.println("id:"+id+">>>>name:"+name);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils1.close(rs,stat,conn);
          }
      }
  }

#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc.utils;

  import java.io.File;
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.io.IOException;
  import java.sql.*;
  import java.util.Properties;

  /**
   ,* 创建连接和关闭资源的工具类
   ,* 工具类中一般是通过类名.方法的形式来调用其中的方法的
   ,*/
  public class JDBCUtils1 {
      private JDBCUtils1(){

      }
      private static Properties prop = null;
      //由于配置文件只需要读取一次即可，所以将读取配置文件的过程书写在一个静态代码块中，这样在类加载的时候就会读取一个配置信息，并且保留在内存中，可以避免重复读取
      static{
          prop = new Properties();
          try {
              prop.load(new FileInputStream
                        (new File(JDBCUtils1.class.getClassLoader().getResource("conf.properties").getPath())));
          } catch (FileNotFoundException e) {
              e.printStackTrace();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
      /**
       ,* 创建连接
       ,* @throws Exception
       ,*/
      public static Connection getConnection() throws Exception {
          Class.forName(prop.getProperty("driver"));
          return DriverManager.getConnection(prop.getProperty("url"),prop.getProperty("user"),null);
      }
      /**
       ,* 关闭资源
       ,*/
      public static void close(ResultSet rs, Statement stat, Connection conn){
          if(rs != null) {
              try {
                  rs.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  rs = null;
              }
          }
          if(stat != null) {
              try {
                  stat.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  stat = null;
              }
          }
          if(stat != null) {
              try {
                  conn.close();
              } catch (SQLException e) {
                  e.printStackTrace();
              }finally{
                  conn = null;
              }
          }
      }
  }
#+END_SRC
* 登陆功能实现
1. 创建数据库
   #+BEGIN_SRC sql
     create table user(id int,name varchar(10),password varchar(10));
     insert into user values(1,'ls','123');
     insert into user values(2,'lg','qwe');
     insert into user values(3,'pq','qaz');
   #+END_SRC
2. 在控制台输入用户名和密码之后实现登陆操作：
   #+BEGIN_SRC java
     package cn.commandoptionesc.jdbc;

     import cn.commandoptionesc.utils.JDBCUtils1;

     import java.sql.Connection;
     import java.sql.ResultSet;
     import java.sql.Statement;
     import java.util.Scanner;

     /**
      ,* 登陆功能 --- jdbc实现
      ,*
      ,*/
     public class Login {
         public static void main(String[] args) {
             //要求用户输入用户名和密码
             Scanner sc = new Scanner(System.in);
             System.out.println("请输入用户名");
             String name = sc.nextLine();
             System.out.println("请输入密码");
             String password = sc.nextLine();
             loginTest(name,password);
         }

         private static void loginTest(String name, String password) {
             //将获取到的值和数据库中的数据作比对
             Connection conn = null;
             Statement stat = null;
             ResultSet rs = null;
             try {
                 conn = JDBCUtils1.getConnection();
                 stat = conn.createStatement();
                 rs = stat.executeQuery("select * from user where name = '"+name+"' and password = '"+password+"'");
                 if(rs.next()){
                     System.out.println("登陆成功");
                 }else{
                     System.out.println("登陆失败");
                 }
             } catch (Exception e) {
                 e.printStackTrace();
             }finally{
                 JDBCUtils1.close(rs,stat,conn);
             }

         }
     }

   #+END_SRC
   + 注意：这样书写的话，在控制台输入用户名是输入：用户名'#就会成功登入，因#号在数据库中是注释的意思。
     #+BEGIN_SRC sql
       select * from user where name = '用户名'#' and password = 'password'
     #+END_SRC
* Tomcat
[[./other/tomcat完整笔记.pdf]]

[[./Img/web应用与虚拟主机.png]]

[[./Img/tomcat执行原理图.png]]
** 课堂笔记
*** 1. 服务器概述
[[./Img/硬件服务器与软件服务器.png]]
- 服务器的分类：
  1. 硬件的服务器：oracle服务器（一台价值百万美金）;联想/微软的单片机（一个机房中有几百台单片机）;如果要进行学习使用,直接使用咱们的笔记本当做一台硬件服务器即可！
     模拟硬件服务器：本地电脑
  2. 软件的服务器：在这里特指web应用服务器！！！它是一个应用程序，该应用程序能够提供浏览器的访问！！
     web应用服务器的常用的几种：
     1. webLogic：收费，目前应用最广泛的Web服务器,服务器本身这个应用程序，很庞大，几十个G,一般是使用在大型的项目中，比如京东/淘宝
     2. webSphere：收费,服务器本身这个应用程序，很庞大，几十个G,一般是使用在大型的项目中，比如京东/淘宝
     3. tomcat：免费 ，体积很小，安装程序只有十几M，tomcat是在中小型企业中，或者学习中，应用最广泛的web服务器
*** 2. tomcat服务器的下载与安装
**** 2.1 下载本地资源
#+BEGIN_SRC
  【课前资料-tomcat/】
  -->【课前资料day06-tomcat\day06-tomcat\资源】
  --->【把这个压缩包复制到D:\software\】
  --->【解压到当前文件，生成了apache-tomcat-7.0.62文件夹】
  --->【重命名：tomcat7】
#+END_SRC
**** 2.2 官方网站下载资源
tomcat官方网站：里面可以下载各个版本的tomcat
#+BEGIN_SRC
  Core:
  zip (pgp, sha512)   window版本 免安装
  tar.gz (pgp, sha512)   linux版本 免安装
  32-bit Windows zip (pgp, sha512)   32位windows 免安装
  64-bit Windows zip (pgp, sha512)   64位windows 免安装
  32-bit/64-bit Windows Service Installer (pgp, sha512) 安装版

  Source Code Distributions  tomcat应用服务器的源程序，程序员可以查看
  tar.gz (pgp, sha512)
  zip (pgp, sha512)
#+END_SRC
**** 2.3 tomcat的运行环境
#+BEGIN_SRC
  tomcat的运行环境：
                  需要java-jdk的支持，必须要先安装jdk才可以
                  验证操作1：删除了 jdk的环境变量，然后再运行tomcat就不可以
                  验证操作2：找到了tomcat7/lib，里面都是.jar包，
                  所以，tomcat需要java的jdk支持

  举例：java的运行环境：JDK(JRE/JVM)
#+END_SRC
**** 2.4 tomcat与jdk对应的版本
#+BEGIN_SRC
tomcat版本与java版本的对应：

tomcat6 需要 jdk5.0以上版本。
tomcat7 需要 jdk6.0以上版本。
tomcat8 需要 jdk7.0以上版本。
tomcat9 最新的版本 -->不建议使用
#+END_SRC
**** 2.5 端口号被占用问题
1. tomcat7在启动过程中，一闪而过，不能运行：
   1. jdk没有安装
   2. 已经启动过了，再次启动时，将不能启动,端口号被占用
2. 端口号被占用的解决方案：
   1. 先查出来是谁在占用 8080端口
      cmd >>>>> netstat -ano
      TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       13188
   2. 把8080端口这个程序 直接'杀'掉
      打开【启动任务管理器】 --> 【进程/服务】-->【查看PID 13188】
      -->【右键单击 选择结束进程 】
[[./Img/b.png]]
**** 2.6 修改端口号
tomcat服务器：修改端口号
1. 打开配置文件【conf/server.xml文件】
2. 找到代码的第70行：
   <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />

   post="端口号"
3. 直接把port="8080" --->修改为 端口号port="80"
4. 如果修改了端口号，那么必须要重新启动一次tomcat，【bin/startup.sh】
   tomcat的80端口是一个默认的端口：访问tomcat时，浏览器地址栏中，直接输入 localhost就可以访问到
**** 2.7 tomcat的目录结构：
| bin     | 存放tomcat启动和关闭的.bat脚本文件                                                                          |
| conf    | tomcat应用程序的核心配置文件                                                                                |
| lib     | 是tomcat运行时，所需要的jar包                                                                               |
| logs    | 这是一个tomcat运行时产生的日志文件                                                                          |
| temp    | tomcat运行时产生的一些临时文件，不需要关注                                                                  |
| webapps | 开发人员编写网站代码，存放的目录。                                                                          |
| work    | tomcat运行的真正的目录，比如：.java文件，当tomcat加载运行时.class文件，是在work中，所以work是运行的真正目录 |
*** 3. tomcat的基本概念
#+BEGIN_SRC
tomcat本身是一个web应用服务器，提供对外访问的接口和资源。
localhost:80 去访问！！！
模拟一个场景：
           两个地址：fanyi.baidu.com
                    tieba.baidu.com
这两个百度的产品是在一个硬件服务器吗？？？答案：是在不同的虚拟主机中
#+END_SRC
[[./Img/c.png]]
*** 4. web应用配置虚拟路径映射的三种方式
虚拟主机的模拟场景：
**** 方式一：
1. 创建一个web应用：创建一个新的文件夹new1
   #+BEGIN_SRC
              new1 这个文件就是一个web应用
                |
                |---1.html
                |---1.css
                |---1.js
                |---WEB-INF 文件夹
                |       | classes 存放编译之后的java代码 .class文件
                        | lib  存放项目需要的jar包
                        | web.xml 名字不能改，核心的配置文件
   #+END_SRC
2. 找到localhost虚拟主机：
   找到[tomcat7\conf\server.xml\125行]

   [[./Img/d.png]]
   #+BEGIN_SRC xml
        <Host name="localhost"  appBase="webapps"
              unpackWARs="true" autoDeploy="true">
              <Context path="/aaa" docBase="/Users/coe/Desktop/news1" />
        </Host>
   #+END_SRC
   这个host name="localhost" 就是一个tomcat7默认的虚拟主机
3. 把new1 应用，添加到虚拟主机localhost中,path属性指定虚拟路径（浏览器访问的路径），docBase指向真实的web应用目录。
   #+BEGIN_SRC xml
     <Host>
         <Context  docBase="/Users/coe/commandoptionesc/Another/JavaWeb/SourceCode/news1" path="/aaa"  />
     </Host>
   #+END_SRC
4. 把new1 文件夹中的 [WEB-INF\web.xml]修改
   #+BEGIN_SRC xml
     <?xml version="1.0" encoding="ISO-8859-1"?>
     <web-app xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                           http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
       version="3.0">
     </web-app>
   #+END_SRC
5. 重新启动 tomcat7 ，然后打开浏览器访问：
   localhost/aaa/1.html
**** 方式二： 直接部署，不需要重新启动tomcat
1. 创建一个新的文件夹 news2
   #+BEGIN_SRC
            new2 这个文件就是一个web应用
                |
                |---1.html
                |---1.css
                |---1.js
                |---WEB-INF 文件夹
                |       | classes 存放编译之后的java代码 .class文件
                        | lib  存放项目需要的jar包
                        | web.xml 名字不能改，核心的配置文件
   #+END_SRC
2. [tomcat]/conf/[engin引擎]/[host虚拟主机]
   #+BEGIN_SRC
     tomcat7\conf\Catalina\localhost\news2.xml
     tomcat会把news2.xml的文件名前缀当做  当前web应用的虚拟路径
   #+END_SRC
3. 打开【new2.xml】，编写配置 web应用new2的真实路径
   #+BEGIN_SRC xml
        <Context docBase="/Users/coe/commandoptionesc/Another/JavaWeb/SourceCode/news2" />
   #+END_SRC
4. 配置缺省的ROOT.xml文件
   #+BEGIN_SRC
     把"tomcat7\conf\Catalina\localhost\news2.xml""修改为"tomcat7\conf\Catalina\localhost\ROOT.xml"
     优先级问题：【自己的应用news --> ROOT.xml】 >【Tomcat的ROOT】
   #+END_SRC
**** 方式三：
1. 确定【tomcat：webapps】-->存放了所有的web应用,tomcat会自动管理webapps中的每一个web应用.以后，我们创建的所有web应用都要放在webapps下，交给tomcat管理即可！！
2. 创建一个新的web应用：news3
   #+BEGIN_SRC
        new3 这个文件就是一个web应用
                        |
                        |---1.html
                        |---1.css
                        |---1.js
                        |---WEB-INF 文件夹
                        |       | classes 存放编译之后的java代码 .class文件
                                | lib  存放项目需要的jar包
                                | web.xml 名字不能改，核心的配置文件
   #+END_SRC
3. 把【news3】----> 【tomcat7\webapps中】
   tomcat会自动发布，然后自动管理news3；通过路径进行测试：localhost/news3/1.html
4. 默认缺省的方式【tomcat7\webapps\new3】
   把文件夹的名字改为  ROOT即可
5. 默认缺省的 访问页面【直接输入localhost，会显示1.html的内容】
   1. 【先把第四部完成 news3 变为一个ROOT 应用】
   2. 【把ROOT\WEB-INF\web.xml】，配置一个welcome-file-list文件
      #+BEGIN_SRC xml
                <welcome-file-list>
                        <welcome-file>1.html</welcome-file>
                </welcome-file-list>
      #+END_SRC
   3. 【浏览器输入:localhost】--->【直接进入欢迎页面 1.html】
*** 5. 配置一个虚拟主机
注意：如果要配置www.baidu.com，需要绕过 DNS域名解析器。DNS域名解析器 会把 输入的域名www.baidu.com 解析成IP地址
- 基本步骤：
  1. 找到【tomcat7\conf\server.xml】
  2. 打开，在<Host name="localhost"></Host>下方并列的位置,添加一条 <Host name="www.baidu.com"  appBase="d:\software\baidu" >
  3. baidu文件夹目录【d:\software\baidu】里面存在了一个web应用 ：news3
  4. 找到【c:/windwos/system32/drivers/etc/hosts】，打开。新增一条信息：本机的IP地址  与  www.baidu.com的映射关系
     127.0.0.1 www.baidu.com
  5. 重新启动tomcat，然后浏览器输入【www.baidu.com/news3/1.html】
     这样就访问成功了
*** 6. 综合练习
配置www.163.com虚拟主机,以三种方式配置web应用,并选择一种配置为缺省web应用,并且配置web应用的主页,最终实现,直接访问www.163.com时能够显示主页的内容。
* SQL注入攻击
由于sql语句中的参数是由前台传输而来，后台是对sql语句的拼接，在参数传递的过程中，用户可能输入一些数据库的关键字，这些关键字可能会导致sql的语义发生改变从而执行一些特殊的操作，像这样呃操作就称之为sql注入攻击。
1. preparedStatement的使用
      预编译
2. 预编译如何保证sql语句语义不改变：
      - 在PreparedStatement中，会先将sql语句发送到数据库，发送的语句到达数据库服务器之后，会在服务器中保留一份，并将这个语句转换成一个机器码，这个机器码是不允许也不能够被修改的，这个就保证了sql语句不会被改变。
      - 在sql语句中如果有参数需要传入，则在sql语句的主干部分用?来代替参数。这时用户传入参数，传入的参数还会被当做纯文本来使用。第二次保证sql语句语义不会被改变。
      - 总结：利用preparedStatement只需操作两步：
        1. 发送sql语句的主干部分，如果有参数用?预留。
        2. 发送当前sql语句的参数
#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import cn.commandoptionesc.utils.JDBCUtils1;
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;

  public class PreparedDemo1 {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              conn = JDBCUtils1.getConnection();
              //发送sql语句的主干部分
              ps = conn.prepareStatement("select * from user where name = ?");
              //发送参数
              //setString(第几个问号的下标,对应下标的出入值);
              ps.setString(1,"ls");
              //此句表示sql语句的主干和参数部分都已经传递完成，继续执行当前sql语句。
              ps.executeQuery();
              while(rs.next()){
                  String password = rs.getString("password");
                  System.out.println("password:"+password);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils1.close(rs,ps,conn);
          }
      }
  }
#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc.jdbc;

  import cn.commandoptionesc.utils.JDBCUtils1;
  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.util.Scanner;

  /**
   ,* 登陆功能 --- jdbc实现
   ,*
   ,*/
  public class Login1 {
      public static void main(String[] args) {
          //要求用户输入用户名和密码
          Scanner sc = new Scanner(System.in);
          System.out.println("请输入用户名");
          String name = sc.nextLine();
          System.out.println("请输入密码");
          String password = sc.nextLine();
          loginTestPrepared(name,password);
      }
      //Prepared实现jdbc
      private static void loginTestPrepared(String name, String password) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          try {
              conn = JDBCUtils1.getConnection();
              ps = conn.prepareStatement("select * from user where name = ? and password = ?");
              ps.setString(1,name);
              ps.setString(2,password);
              rs = ps.executeQuery();
              if (rs.next()) {
                  System.out.println("登陆成功");
              }else{
                  System.out.println("登陆失败");
              }
          } catch (Exception e) {
              e.printStackTrace();
          }finally{
              JDBCUtils1.close(rs,ps,conn);
          }
      }
  }
#+END_SRC
* 批处理
1. 使用情景：
   如果有多条sql语句需要执行，一条书写一个jdbc的完整过程十分浪费资源，和编码的时间，所以希望使用一种方案一次性执行多条sql语句，那么像这样的方法数据库当红称之为批处理操作。
2. 批处理实现
   原理：一次性发送多条sql语句到数据库执行。减少diamante量以及多次发送sql的过程。
3. 批处理中的api
   | Statement.addBatch()     | 添加一条批处理语句 |
   | Statement.executeBatch() | 执行当前批处理     |
   | Statement.clearBatch()   | 清楚批处理中的语句 |
   + 注意：PreparedStatement在添加批处理的时候操作的都是统一语义的sql，所以传输sql的参数即可。
4. Statement批处理
   #+BEGIN_SRC java
     package cn.commandoptionesc.batch;

     import cn.commandoptionesc.utils.JDBCUtils1;
     import java.sql.Connection;
     import java.sql.Statement;

     /**
      ,* PreparedStatement批处理
      ,* 优点：可以处理不同语义的sql语句
      ,* 缺点：1. 执行效率低下
      ,*       2. sql语句无法预留在数据库服务器中，每次都是发送一条sql语句到达数据库。数据库需要重新解读sql语句。
      ,*       3. 没有预编译功能。
      ,*/
     public class StatementBatchDemo1 {
         /*
           create table t1(id int,name varchar(20));
           insert into v1 values(1,'阿一');
           insert into t1 values(2,'阿二');
           insert into t1 values(3,'阿三');
           insert into t1 values(4,'阿四');
         ,*/
         public static void main(String[] args) {
             Connection conn = null;
             Statement stat = null;
             try {
                 conn = JDBCUtils1.getConnection();
                 stat = conn.createStatement();
                 //批处理
                 stat.addBatch("create table v1(id int,name varchar(20))");
                 stat.addBatch("insert into v1 values(1,'阿一')");
                 stat.addBatch("insert into v1 values(2,'阿二')");
                 stat.addBatch("insert into v1 values(3,'阿三')");
                 stat.addBatch("insert into v1 values(4,'阿四')");
                 //通知数据库服务器sql语句已经准备完成
                 //请执行当前批处理
                 stat.executeBatch();
                 System.out.println("执行成功！");
             } catch (Exception e) {
                 e.printStackTrace();
             }finally{
                 JDBCUtils1.close(null,stat,conn);
             }
         }
     }

   #+END_SRC
4. PreparedStatement批处理：
   #+BEGIN_SRC java
     package cn.commandoptionesc.batch;

     import cn.commandoptionesc.utils.JDBCUtils1;
     import java.sql.Connection;
     import java.sql.PreparedStatement;

     /**
      ,* Statement批处理
      ,* 优点：1. 执行效率较高
      ,*       2. sql语句已经预留在内存中可以重复使用。
      ,*       3. 有预编译功能。
      ,* 缺点：不能处理不同语义的sql语句
      ,*/
     public class PreparedBatchDemo1 {
         public static void main(String[] args) {
             Connection conn = null;
             PreparedStatement ps = null;
             try {
                 conn = JDBCUtils1.getConnection();
                 ps = conn.prepareStatement("insert into v1 values(?,?)");
                 for(int i = 0;i<100199;i++){
                     ps.setInt(1,i);
                     ps.setString(2,"name"+i);
                     ps.addBatch();
                     if(i%1000 == 0){
                         //满1000条执行批处理
                         ps.executeBatch();
                         //将执行完成的数据库释放，避免内存溢出
                         ps.clearBatch();
                         System.out.println("第"+i/1000+"次成功");
                     }
                 }
                 //如果数据中有不满1000的，为了保证数据都可以执行需要最后执行一遍executeBatsh()
                 ps.executeBatch();
                 System.out.println("全部处理成功");
             } catch (Exception e) {
                 e.printStackTrace();
             } finally{
                 JDBCUtils1.close(null,ps,conn);
             }
         }
     }
   #+END_SRC
* 数据库连接池
** 1. C3P0连接池
[[./Img/47.png]]
- 缺点：用户每次请求都需要向数据库获得连接，而数据库创建连接通畅性乣消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成上护具库服务器内存溢出、宕机。
[[./Img/48.png]]
- 它是将那些已连接的数据库连接存放在一个容器里（连接池），这样以后别人要连接数据库的时候，将不会重新建立数据库连接，会直接从连接池里取出可用的链接，用户使用完毕后，连接又重新还回到连接池中。
+ 注意：连接池路里的链接将会一直保存在内存里，即使你没用也是一样。所以这个时候你得权衡一下连接池的接连数量了。
+ 连接池又叫做数据源。
** 2. 实现：
- 编写连接池需实现  javax.sql.DataSource  接口。DataSource接口中定义了两个重载的getConnection方法：
  Connection getConnection()、Connection getConnection(String username,String password)
  + 在DataSource构造函数中批量创建于数据库的连接，并把创建的连接保存到一个集合对象中。
  + 实现getConnection方法，让getConnection返回给用户
  + 当用户使用完Connection，调用Connection.close()方法时，Connection对象应保证将自己返回到连接池的集合对象中，而不要把conn还给数据库。
  + 扩展Connection的close()方法。
  + 在关闭数据库连接时，将connection存回连接池中，而并非真正的关闭。
** 3. 手写MyPool连接池：
#+BEGIN_SRC java
  package cn.commandoptionesc.pool;

  import javax.sql.DataSource;
  import java.io.PrintWriter;
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  import java.sql.SQLFeatureNotSupportedException;
  import java.util.LinkedList;
  import java.util.List;
  import java.util.logging.Logger;

  /**
   ,* 作为连接池上使用
   ,*/
  public class MyPool implements DataSource {
      //主要目的：为了存储初始化的5个链接
      public static List<Connection> pool = new LinkedList<Connection>();
      static {
          try {
              Class.forName("com.mysql.cj.jdbc.Driver");
              for(int i = 0;i<5;i++) {
                  //由于每次都会执行getConnecton方法所以一定会有五个不同的对象存储在pool中。
                  Connection conn = DriverManager.getConnection
                      ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root");
                  pool.add(conn);
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
      /**
       ,*
       ,* 获取一个链接
       ,*/
      @Override
      public Connection getConnection() throws SQLException {
          Connection conn1 = null;
          //利用pool.size()获取连接池数量，如果位零则证明已经取空，需要在初始化一批连接。
          if(pool.size()>0) {
              //remove会将当前指定下标的元素删除，并且作为返回值返回
              conn1 = pool.remove(0);
          }else{
              for(int i = 0;i<5;i++) {
                  //由于每次都会执行getConnecton方法所以一定会有五个不同的对象存储在pool中。
                  Connection conn = DriverManager.getConnection
                      ("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC&user=root");
                  pool.add(conn);
              }
              conn1 = pool.remove(0);
          }
          System.out.println("已经从池中取出一个连接，现在池中生下："+pool.size()+"个链接");
          return conn1;
      }

      /**
       ,*
       ,* 归还连接
       ,* conn:用户归还的连接对象
       ,*/
      public void returnConnection(Connection conn) throws SQLException{
          //归还连接时要保证连接是正常使用开着的，而且不能为null。
          if(conn != null && !conn.isClosed())
              pool.add(conn);
          System.out.println("归还成功,当前连接池中还剩："+pool.size()+"个连接");
      }

      @Override
      public Connection getConnection(String username, String password) throws SQLException {
          return null;
      }

      @Override
      public <T> T unwrap(Class<T> iface) throws SQLException {
          return null;
      }

      @Override
      public boolean isWrapperFor(Class<?> iface) throws SQLException {
          return false;
      }

      @Override
      public PrintWriter getLogWriter() throws SQLException {
          return null;
      }

      @Override
      public void setLogWriter(PrintWriter out) throws SQLException {

      }

      @Override
      public void setLoginTimeout(int seconds) throws SQLException {

      }

      @Override
      public int getLoginTimeout() throws SQLException {
          return 0;
      }

      @Override
      public Logger getParentLogger() throws SQLFeatureNotSupportedException {
          return null;
      }
  }
#+END_SRC
#+BEGIN_SRC java
  package cn.commandoptionesc.pool;

  import java.sql.Connection;
  import java.sql.PreparedStatement;
  import java.sql.ResultSet;
  import java.sql.SQLException;

  public class TestMyPool {
      public static void main(String[] args) {
          Connection conn = null;
          PreparedStatement ps = null;
          ResultSet rs = null;
          //从连接池中取出连接
          MyPool pool = new MyPool();
          //利用连接池对象获取连接
          try {
              conn = pool.getConnection();
              ps = conn.prepareStatement("select * from exam");
              rs = ps.executeQuery();
              while(rs.next()){
                  int id = rs.getInt("id");
                  String name = rs.getString("name");
                  System.out.println("id:"+id+">>>>name:"+name);
              }
          } catch (SQLException e) {
              e.printStackTrace();
          }finally{
              if(rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      rs = null;
                  }
              }
              if(ps != null) {
                  try {
                      ps.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      ps = null;
                  }
              }
              if(conn != null) {
                  try {
                      //利用连接池对象归还对象
                      pool.returnConnection(conn);
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      conn = null;
                  }
              }
          }
      }
  }

#+END_SRC
** 4. 开源连接池
现在很多web服务器都提供了DataSource的实现，即连接池的实现。通常我们把DataSource的实现，按其英文含义称之为数据源，数据源中都包含了数据库连接池的实现。也有一些开源组织提供了数据源的独立实现：DBCP数据库连接池、C3P0数据库连接池。

实际应用时不需要编写连接数据库代码，直接从数据源获得数据库的链接。程序员变成时也应尽量使用这些数据源的实现，以提升程序的数据库访问性能。
- DBCP
  DBCP是Apache软件基金组织下的开源连接池实现，使用DBCP数据源，应用程序应在系统中增加如下两个jar文件：Commons-dbcp.jar：连接池的实现、Commons-pool.jar：连接池实现的依赖库
- DBCP示例代码：
  #+BEGIN_SRC java
    static{
        InputStream in = JDBCUtil.class.getClassLoader().getResourceAsStream("dbcpconfig.properties");
        Properties prop = new Properties();
        prop.load(in);
        BasicDataSourceFactory factory = new BasicDataSourceFactory();
        dataSource = factory.createDataSource(prop);
    }
  #+END_SRC
- c3p0配置：
  + 第一种方式：c3p0-config.xml
    #+BEGIN_SRC xml
      <?xml version="1.0" encoding="UTF-8" ?>
      <c3p0-config>
        <default-config>
          <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
          <property name="jdbcUrl">jdbc:mysql://localhost:3306/mydb1</property>
          <property name="userSSL">false</property>
          <property name="servertimezont">UTC</property>
          <property name="user">root</property>
          <property name="password"></property>
        </default-config>
      </c3p0-config>
    #+END_SRC
  + 第二种方式：c3p0.properties
    #+BEGIN_SRC
      c3p0.driverClass=com.mysql.cj.jdbc.Driver
      c3p0.jdbcUrl=jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC
      c3p0.user=root
    #+END_SRC
- DBCPDemo1.java
  #+BEGIN_SRC java
    package cn.commandoptionesc.pool;

    import org.apache.commons.dbcp2.BasicDataSource;
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;

    /**
     ,* DBCP连接池的使用
     ,*/
    public class DBCPDemo1 {
        public static void main(String[] args) {
            Connection conn = null;
            Statement stat = null;
            ResultSet rs = null;
            //利用DBCP获取连接
            BasicDataSource source = new BasicDataSource();
            //手动设置配置信息
            source.setDriverClassName("com.mysql.cj.jdbc.Driver");
            source.setUrl("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC");
            source.setUsername("root");
            source.setPassword(null);
            try {
                conn = source.getConnection();
                stat = conn.createStatement();
                rs = stat.executeQuery("select * from exam");
                while(rs.next()){
                    int id = rs.getInt("id");
                    int chinese = rs.getInt("chinese");
                    System.out.println("id:"+id+">>>>chinese:"+chinese);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }finally{
                if(rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        rs = null;
                    }
                }
                if(stat != null) {
                    try {
                        stat.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        stat = null;
                    }
                }
                if(conn != null) {
                    try {
                        //此处不是关闭连接，是归还连接
                        conn.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        conn = null;
                    }
                }
            }
        }
    }
  #+END_SRC
- DBCPDemo2.java、dbcp.properties
  #+BEGIN_SRC java
    package cn.commandoptionesc.pool;

    import org.apache.commons.dbcp2.BasicDataSourceFactory;

    import javax.sql.DataSource;
    import java.io.File;
    import java.io.FileReader;
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;
    import java.util.Properties;

    /**
     ,* DBCP连接池的使用
     ,*/
    public class DBCPDemo2 {
        public static void main(String[] args) throws Exception {
            Connection conn = null;
            Statement stat = null;
            ResultSet rs = null;
            Properties prop = new Properties();
            prop.load(new FileReader(new File(DBCPDemo2.class.getClassLoader().getResource("dbcp.properties").getPath())));
            BasicDataSourceFactory factory = new BasicDataSourceFactory();
            DataSource source = factory.createDataSource(prop);
            try {
                conn = source.getConnection();
                stat = conn.createStatement();
                rs = stat.executeQuery("select * from exam");
                while(rs.next()){
                    int id = rs.getInt("id");
                    int chinese = rs.getInt("chinese");
                    System.out.println("id:"+id+">>>>chinese:"+chinese);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }finally{
                if(rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        rs = null;
                    }
                }
                if(stat != null) {
                    try {
                        stat.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        stat = null;
                    }
                }
                if(conn != null) {
                    try {
                        //此处不是关闭连接，是归还连接
                        conn.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        conn = null;
                    }
                }
            }
        }
    }
  #+END_SRC
  #+BEGIN_SRC
    driverClassName = com.mysql.cj.jdbc.Driver
    url = jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC
    username = root
  #+END_SRC
- C3P0Demo1.java
  #+BEGIN_SRC java
    package cn.commandoptionesc.pool;

    import com.mchange.v2.c3p0.ComboPooledDataSource;

    import java.beans.PropertyVetoException;
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;

    /**
     ,*
     ,*/
    public class C3P0Demo1 {
        public static void main(String[] args) {
            Connection conn = null;
            Statement stat = null;
            ResultSet rs = null;
            //创建一个C3P0数据源的对象
            ComboPooledDataSource source = new ComboPooledDataSource();
            //利用对象读取配置信息
            try {
                source.setDriverClass("com.mysql.cj.jdbc.Driver");
                source.setJdbcUrl("jdbc:mysql://localhost:3306/mydb1?useSSL=false&servertimezone=UTC");
                source.setUser("root");
                source.setPassword(null);
            } catch (PropertyVetoException e) {
                e.printStackTrace();
            }

            try {
                conn = source.getConnection();
                stat = conn.createStatement();
                rs = stat.executeQuery("select * from exam");
                while(rs.next()){
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    System.out.println("id:"+id+">>>>name:"+name);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }finally{
                if(rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        rs = null;
                    }
                }
                if(stat != null) {
                    try {
                        stat.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        stat = null;
                    }
                }
                if(conn != null) {
                    try {
                        //此处不是关闭连接，是归还连接
                        conn.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        conn = null;
                    }
                }
            }

        }
    }

  #+END_SRC
- C3P0Demo2.java、c3p0-config.xml
  #+BEGIN_SRC java
    package cn.commandoptionesc.pool;

    import com.mchange.v2.c3p0.ComboPooledDataSource;
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;

    /**
     ,*
     ,*/
    public class C3P0Demo2 {
        public static void main(String[] args) {
            Connection conn = null;
            Statement stat = null;
            ResultSet rs = null;
            //创建一个C3P0数据源的对象
            ComboPooledDataSource source = new ComboPooledDataSource();
            //利用对象读取配置信息
            try {
                conn = source.getConnection();
                stat = conn.createStatement();
                rs = stat.executeQuery("select * from exam");
                while(rs.next()){
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    System.out.println("id:"+id+">>>>name:"+name);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }finally{
                if(rs != null) {
                    try {
                        rs.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        rs = null;
                    }
                }
                if(stat != null) {
                    try {
                        stat.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        stat = null;
                    }
                }
                if(conn != null) {
                    try {
                        //此处不是关闭连接，是归还连接
                        conn.close();
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }finally{
                        conn = null;
                    }
                }
            }

        }
    }

  #+END_SRC
  #+BEGIN_SRC xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <c3p0-config>
      <default-config>
        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql://localhost:3306/mydb1</property>
        <property name="userSSL">false</property>
        <property name="servertimezont">UTC</property>
        <property name="user">root</property>
        <property name="password"></property>
      </default-config>
    </c3p0-config>
  #+END_SRC
* Servlet、Request、Response
** Servlet
*** 1. Servlet概述
- Servlet是Sun公司提供的一门动态资源开发的奇数。本质就是一个java文件。将编译后的文件放入servlet容器中方可使用servlet提供服务。
- Servlet容器是存储并运行servlet的环境，称之为servlet的环境。
- web容器是存储并运行web资源的环境。
*** 2. 手写Servlet
1. 编写一个类，让这个类实现servlet接口，那么这个类就会变为一个servlet文件
2. 编译写好的文件，并且将其加入到servlet容器中去运行。
3. 将servlet文件添加到任意一个web应用的classes目录中。
*** 3. 配置servlet映射
在添加servlet文件web应用中配置web.xml文件，内容如下：
#+BEGIN_SRC xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
    <servlet>
      <servlet-name>FirstServlet</servlet-name>
      <servlet-class>cn.commandoptionesc.servlet.FirstServlet</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>Firstservlet</servlet-name>
      <url-pattern>/servlet/Firstservlet</url-pattern>
    </servlet-mapping>
  </web-app>
#+END_SRC
*** 4. Servlet调用过程和生命周期
1. 确认ip地址对应的服务器。
2. 确认服务器中的虚拟机主机名称
3. 确认虚拟主机中对应的web应用
4. 确认web应用中的资源虚拟路径
5. 根据web.xml文件寻找对应的真是Servlet
6. servlet执行声明周期的过程
7. servlet的service方法提供服务，将所有数据写入response缓冲区
8. 服务器中的service缓冲区中的数据组织成一定机构后相应给浏览器
[[./Img/55.png]]
*** 1. Servlet继承结构
#+BEGIN_SRC
Servlet --- 包含五个最基础的方法 init() destory() service()
  |
  |---GenericServlet --- service()  通用servlet
           |
           |---HttpServlet ---在通用Servlet基础上，添加了包含大量和HTTP协议相关的方法。
#+END_SRC
*** 2. 图片如何被加载？
#+BEGIN_SRC
news
  |--- 1.jpg
localhost/news/1.jpg
localhost/news/servlet/FirstServlet
注意：所有的静态资源都是有缺省servlet--defaultServlet加载而来
#+END_SRC
*** 3. 拓展：request对象和response对象
1. 接口为什么可以创建对象？
   - HttpServletRequest是一个接口，为什么request对象依然可以用来发送请求数据？
   - HttpServletResponse是一个接口，为什么response对象依然可以用来发送相应数据？
   原因：真正创建对象的并不是这两个接口而是这两个接口下的子实现类。HttpServletRequestWrapper、HttpServletResponseWrapper两个子实现类创建了request和response对象。
2. request对象和response对象何时创建？
   servlet完成初始化操作之后，service方法身上的request和response对象也会被创建出来。
*** 5. Servlet细节讨论
1. Servlet标签问题
   #+BEGIN_SRC xml
     <servlet>
       <servlet-name></servlet-name>
       <sevlet-class>cn.commandoptionesc.FirstServlet</sevlet-class>
     </servlet>
     <servlet-mapping>
       <servlet-name></servlet-name>
       <url-pattern>/servlet/FirstServlet</url-pattern>
     </servlet-mapping>
   #+END_SRC
   - <servlet>注册servlet标签
   - <servlet-mapping>servlet映射标签
   - 标签由两部分组成的原因：为了便于多个不同的映射路径映射到同一个servlet身上。这种方式只需要重写servlet-mapping部分配置并修改url-pattern即可。
2. servlet映射路径通配形式
   如果有大量相似的路径都映射到同一个servlet身上，多次重写servlet-mapping配置代码量仍然很大，这是可以使用映射中通配的形式来定义url-pattern
   - 定义方式
     1. *.后缀
        #+BEGIN_SRC xml
          <servlet-mapping>
            <servlet-name>FirstServlet</servlet-name>
            <url-pattern>*.do</url-pattern>
          </servlet-mapping>
        #+END_SRC
     2. 以 / 开头以 /* 结束
        #+BEGIN_SRC xml
          <servlet-mapping>
            <servlet-name>FirstServlet</servlet-name>
            <url-pattern>/servlet/*</url-pattern>
          </servlet-mapping>
        #+END_SRC
3. Servlet的一些细节(3)
   1. 对于如下的一些映射关系：
      - Servlet1映射到 /abc/*
      - Servlet2映射到 /*
      - Servlet3映射到 /abc
      - Servlet4映射到 *.do  （永远匹配级级最低）
   2. 问题：
      1. 当请求URL为 /abc/a.html、/abc* 和 /* 都匹配，哪个servlet响应
         Servlet引擎将调用Servlet1
      2. 当请求URL为 /abc时，/abc/* 和 /abc 都匹配，哪个servlet响应
         Servlet引擎将调用Servlet3
      3. 当请求URL为 /a/a.do 时，/a/* 和 *.do 都匹配，哪个servlet响应
         Servlet引擎将调用Servlet1
      4. 当请求URL为 /a.do 时，/*和 *.do 都匹配，哪个servlet响应
         Servlet引擎将调用Servlet2
      5. 当请求URL为 /xxx/yyy/a.do 时，/*和*.do都匹配，哪个servlet响应
         Servlet引擎将调用Servlet2
4. Servlet的一些细节(4)
   1. Servlet是一个供其他Java程序(Servlet引擎)调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度
   2. 针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁
   3. 在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。
   4. 在servlet被访问到时会创建一个servlet对象驻留在内存中，如果有多个servlet资源被访问，则每个servlet在被初次访问的时候都会创建一个各自的servlet对象保存在tomcat内存当中。
5. Load-on-startup标签
   #+BEGIN_SRC xml
     <servlet>
       <servlet-name>default</servlet-name>
       <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
       <init-param>
         <param-name>debug</param-name>
         <param-value>0</param-value>
       </init-param>
       <init-param>
         <param-name>listings</param-name>
         <param-value>false</param-value>
       </init-param>
       <load-on-startup>1</load-on-startup>
     </servlet>
   #+END_SRC
   1. 如果一个servlet标签中配置了load-on-startup标签，则在tomcat服务器启动的时候就会自动访问一次这个servlet，让这个servlet的对象驻留在内存中一份，为后边的请求提供访问。
   2. load-on-startup标签中间可以配置一个数字，这个数字可以采用0及其以上的数字，一般采用1及其以上的数字。如果这个数字越小，则优先级越高，如果数字越大则优先级越低。注意：尽管各个servlet之间存在优先级关系，但是仍然都是随着tomcat服务器的启动而加载。
6. 缺省servlet
   1. 如果某个Servlet的映射路径仅仅为一个正斜杠/，那么这个Servlet就成为当前Web应用程序的缺省Servlet
   2. 凡是在web.xml文件中找不到匹配的<servlet-mapping>元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。
   3. 在<tomcat的安装目录>\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.Default的Servlet，并将这个Servlet设置为了缺省Servlet。
   4. 当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet
   5. 如果访问的资源虚拟路径不存在，依然是交给缺省servlet处理。
7. servlet多线程并发安全的问题
   1. 在面对局部变量的时候，所有线程操作的都是各自独立的变量，这些变量之间是没有联系的，相互不产生影响。
   2. 面对全局变量的时候存在线程并发安全问题，这个问题可以通过加锁来解决，但是添加锁的时候要注意：锁对象一定要统一。锁住部分的代码一定尽可能的少，只锁住必要部分代码，如果锁住过多的代码则会导致程序的运行效率。
   3. 尝试利用sun公司提供的SingThreadModel接口解决多线程并发安全问题。发现一个一个servlet的对象，这些对象会同时为所有的用户提供服务，所以导致了用户初次访问闲置的servlet提供服务的线程，按照接口思路应该为每一个新的用户都提供一个新的servlet对象，但是结果表明事实是调用内存中已有的一个ervlet对象提供的服务。显然结果不正确，当前接口如果被实现会导致线程安全问题更加复杂，不要使用当前接口。

      [[./Img/56.png]]
   4. 解决线程安全问题：
      1. 加锁：合理添加锁，锁住关键部分代码，尽可能少的降低代码的执行效率。
      2. 尽可能多定义局部变量少定义全局变量，因为全局变量不可避免的会出现多线程并发安全问题。
** Request
*** 1. request概述与功能一 --- API操作
1. 回顾：HTTP协议
   - HTTP数据交互模型：
     请求响应模型、一次请求对应一次响应、请求只能由浏览器发出，服务器可以根据请求作出响应
*** 2. HTTP请求
**** 1. 继承结构
   #+BEGIN_SRC
   ServletRequest 提供servletrequest对象必要的方法
         |
         |--- HttpServletRequest 包含和HTTP协议操作的一些API，可以通过这些API来开发浏览器和服务器之间的功能。
   #+END_SRC
**** 2. HTTP请求的组成
   #+BEGIN_SRC
   一个请求行   请求方式   请求资源的路径   HTTP协议版本
   多个请求头   Host:虚拟主机名称
   一个空行
   请求实体内容   用户发送请求时携带的请求参数
   #+END_SRC
*** 3. Request当中的API操作：
**** 1. 获取客户端相关的信息
   - getRequestURL方法 --- 返回客户端发出请求完整URL
   - getRequestURI方法 --- 返回请求行中的资源名部分
   - getQueryString方法 --- 返回请求行中的参数部分
   - getRemoteAddr方法 --- 返回发出请求的客户机的IP地址
   - getMethod --- 得到客户机请求方式
   - getContextPath --- 获取当前web应用虚拟目录名称 -- 在写路径时不要将web应用的虚拟路径的名称写死，应该在需要些web应用的名称的地方通过getContextPath方法动态获取
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import java.io.IOException;
     /**
      ,* 请求当中包含的客户端参数
      ,* 获取客户端参数的API
      ,*/
     public class RequestDemo1 extends javax.servlet.http.HttpServlet {
         // getRequestURL方法 -- 返回客户端发出请求完整URL
         // getRequestURL方法 -- 返回请求行中的资源名部分
         // getQueryString方法 -- 返回请求行中的参数部分
         // getRemoteAddr方法 -- 返回发出请求的客户机的IP地址
         // getMethod -- 得到客户机请求方式
         // getContextPath -- 获得当前web应用虚拟目录名称 -- 在写路径时不要将web应用的
         protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             String url = request.getRequestURL().toString();
             System.out.println("url:"+url);
             String uri = request.getRequestURI().toString();
             System.out.println("uri:"+uri);
             String qs = request.getQueryString();
             System.out.println("qs:"+qs);
             String ip = request.getRemoteAddr();
             System.out.println("ip:"+ip);
             String method = request.getMethod();
             System.out.println("method:"+method);
             String cp = request.getContextPath();
             System.out.println("cp:"+cp);
         }
         protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             doGet(request, response);
         }
     }

   #+END_SRC
**** 2. 获取请求头信息
   - getHeader(name)方法 --- String
   - getHeaders(String name)方法 --- Enumeration<String>
   - getheaderNames方法 --- Enumeration<String>
   - getIntHeader(name)方法 --- int
   - getDateHeader(name)方法 --- long(日期对应毫秒)
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.util.Enumeration;
     /**
      ,* 获取请求中的头信息
      ,*/
     public class RequestDemo2 extends HttpServlet {
         // getHeader(name)方法 --- String
         // getHeaders(String name)方法 --- Enumeration<String>
         // getHeaderNames方法 --- Enumeration<String>
         // getIntHeader(name)方法 --- int
         // getDateHeader(name)方法 --- long(日期对应毫秒)
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             String host = request.getHeader("Host");
             System.out.println("host:"+host);

             //getHeaders方法可以获取多个同名的请求头对应的内容
             //这些内容会放入一个迭代器中，可以通过遍历循环获取
             Enumeration<String> headers = request.getHeaders("Host");
             while(headers.hasMoreElements()){
                 String string = (String)headers.nextElement();
                 System.out.println("head:"+string);
             }
             //获取全部的请求头
             Enumeration<String> headerNames = request.getHeaderNames();
             while(headerNames.hasMoreElements()){
                 //遍历全部请求头的名称
                 String string = (String)headerNames.nextElement();
                 //根据请求头获取全部头对应的值
                 String value = request.getHeader(string);
                 System.out.println("header"+string+">>>>value:"+value);
             }
         }
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
     }
   #+END_SRC
**** 3. 获取请求参数
   - getParameter(String name) --- String通过name获得值
   - getParameterValues(String name) --- String[] 通过name获得多值checkbox
   - getParameterMap() --- Map<String,string[]> key:name value:多值 将查询的参数保存在一个Map中
   - getParameterNames() --- Enumeration<String>获得所有name
   #+BEGIN_SRC xml
     <?xml version="1.0" encoding="UTF-8"?>
     <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
              version="4.0">
       <servlet>
         <servlet-name>RequestDemo1</servlet-name>
         <servlet-class>cn.commandoptionesc.request.RequestDemo1</servlet-class>
       </servlet>
       <servlet>
         <servlet-name>RequestDemo2</servlet-name>
         <servlet-class>cn.commandoptionesc.request.RequestDemo2</servlet-class>
       </servlet>
       <servlet>
         <servlet-name>RequestDemo3</servlet-name>
         <servlet-class>cn.commandoptionesc.request.RequestDemo3</servlet-class>
       </servlet>
       <servlet-mapping>
         <servlet-name>RequestDemo1</servlet-name>
         <url-pattern>/servlet/RequestDemo1</url-pattern>
       </servlet-mapping>
       <servlet-mapping>
         <servlet-name>RequestDemo2</servlet-name>
         <url-pattern>/servlet/RequestDemo2</url-pattern>
       </servlet-mapping>
       <servlet-mapping>
         <servlet-name>RequestDemo3</servlet-name>
         <url-pattern>/servlet/RequestDemo3</url-pattern>
       </servlet-mapping>
     </web-app>
   #+END_SRC
   #+BEGIN_SRC html
     <!DOCTYPE html>
     <html>
       <head>
         <meta charset="utf-8" />
       </head>
       <body>
         <h1>GET提交</h1>
         <form action="/iDay10reqres/servlet/RequestDemo3" method="GET">
           用户名: <input type="text" name="username" />
           昵称: <input type="text" name="nickname" />
           <input type="submit" value="提交" />
         </form>
         <h1>POST提交</h1>
         <form action="/iDay10reqres/servlet/RequestDemo3" method="POST">
           用户名: <input type="text" name="username" />
           昵称: <input type="text" name="nickname" />
           爱好: <input type="checkbox" name="like" value="lanqiu" />篮球
           <input type="checkbox" name="like" value="zuqiu" />足球
           <input type="checkbox" name="like" value="taiqiu" />台球
           <input type="submit" value="提交" />
         </form>
       </body>
     </html>

   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.util.Arrays;
     import java.util.Enumeration;
     import java.util.Map;
     import java.util.Map.Entry;
     /**
      ,* 获取请求参数
      ,*/
     public class RequestDemo3 extends HttpServlet {
         // getParameter(String name) --- String 通过name获得值
         // getParameterValues(String name) --- String[]通过name获得多值 checkbox
         // getParameterMap() --- Map<String,String[]> key:name value:多值  将查询的参数保存在一个Map中
         // getParameterNames() --- Enumeration<String> 获得所有name
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //utf-8中有中文，所以需要将服务器的字符集修改为utf-8
             //通知服务器使用utf-8字符集解码数据
             request.setCharacterEncoding("utf-8");
             String username = request.getParameter("username");
             //byte[] bytes = username.getBytes("iso8859-1");
             //username = new String(bytes,"utf-8");
             System.out.println("username:"+username);
             //多个同名参数获取需要使用getParameterValues来获取
             String[] like = request.getParameterValues("like");
             System.out.println("like:"+ Arrays.toString(like));
             //获取全部请求参数名称
             Enumeration<String> pNames = request.getParameterNames();
             while(pNames.hasMoreElements()){
                 //遍历全部的参数名
                 String name = (String)pNames.nextElement();
                 //根据参数名获取参数值
                 String[] value = request.getParameterValues(name);
                 //根据参数名获取参数值，由于获取的参数值中可能会有多个，所以利用getParameterValues获取所有参数值，这样所有参数值会放入一个数组当中
                 System.out.println("≤name:"+name+">>>>value:"+Arrays.toString(value));
             }
             //将用户的全部参数名以及参数值放入一个map中
             @SuppressWarnings({"unused","unckecked"})
             Map<String,String[]> map = request.getParameterMap();
             for(Entry<String,String[]> entry:map.entrySet()){
                 String key = entry.getKey();
                 String [] value = entry.getValue();
                 System.out.println(key+":"+Arrays.toString(value));
             }
         }
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
     }

   #+END_SRC
**** 4. 中文乱码问题：
   [[./Img/57.png]]
   1. 获取请求参数乱码问题：
      乱码出现的原因:编解码不一致
   2. 浏览器发送的数据字符集使用的UTF-8，原因是在浏览器打开的时候使用的是什么字符集发送数据的时候就会使用什么字符集进行编码操作
   3. tomcat服务器接收数据字符集ISO8859-1，因为服务器的默认字符集是ISO8859-1，所以在收到浏览器发送的以UTF-8编码的数据时解码过程会出现乱码
   4. 统一浏览器端和服务器的字符集为UTF-8
      修改服务器接收数据时使用的字符集
      1. request.setCharacterEncoding
         当前语句仅对post请求生效，因为用户使用post提及时，请求参数会存储在请求实体内容中。语句可以将请求实体内容中的中文参数乱码做出处理。
      2. 由于get提交参数在地址栏中拼接传输，没有进入请求实体内容，所以此处无法处理get提交的乱码
      3. 注意：post乱码处理一定要放在获取参数的代码之前。
   5. get提交参数乱码处理
      1. 先对获取到的中文进行编码操作，使用字符集iso8859-1，获取到真正的二进制数据，将二进制数据使用正确是utf-8字符集重新解码。
         #+BEGIN_SRC java
           byte[] bytes = ??????.getBytes("iso8859-1");
         #+END_SRC
      2. 使用utf-8字符集解码二进制数据
         #+BEGIN_SRC java
           username = new String(bytes,"utf-8");
         #+END_SRC
      3. 这种处理方式其实就是将获取到的参数重新编码、解码各一次，所以不管get提交还是post提交参数都会重新编解码，所以它既能解决get提交乱码也可以解决post提交乱码。
         #+BEGIN_SRC java
           username = new String(????.getBytes("iso8859-1"),"utf-8");
         #+END_SRC
*** 4. request功能二 --- 请求转发
**** 1. 什么是请求转发：
   是一种资源跳转方式；是由一个动态资源跳转到另外一个动态资源，让第二个动态资源对浏览器做出相应的操作，这个过程就称之为请求转发。
**** 2. 请求转发的特点：
   [[./Img/58.png]]
   #+BEGIN_SRC
   一次请求一次相应
   一个请求对象和一个响应对象
   服务器内部的资源跳转
   浏览器地址栏不会发生变化

   注意：请求转发是一个服务器内部的资源跳转，浏览器不会察觉到变化，最明显的反馈就是浏览器地址栏不发生变化。
   #+END_SRC
**** 3. 请求转发实现：
创建一个调度器，利用调度器实现请求转发，代码如下：
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.RequestDispatcher;
     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 请求转发实现
      ,* 与RequestDemo5一组
      ,*/
     public class RequestDemo4 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                 //请求转发
                 //获取一个调度器
                 RequestDispatcher rd = request.getRequestDispatcher("/servlet/RequestDemo5");
                 //利用调度器实现请求转发
                 rd.forward(request,response);
             }
     }

   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 与RequestDemo4一组
      ,*/
     public class RequestDemo5 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             response.getWriter().write("$100000000000000000000");
         }
     }
   #+END_SRC
   - 请求转发的细节
     1. 请求转发之前如果response缓冲区中有数据，在请求转发的时候会将response缓冲区中的内容清空
     2. 如果冲刺response缓冲区，则会造成一次响应操作，在请求转发过程中也会发生一次响应操作，两个响应操作不满足一次请求对应一次响应的模型，所以会发生异常。
     3. 请求转发之前和之后的语句依然会正常执行，执行的顺序就是请求转发的顺序。
     4. 请求转发可以多重转发，但是不能再同一个servlet中多次转发。如果多次转发会造成多次响应必然不符合一次请求一次响应的模型，发生异常。
     #+BEGIN_SRC java
     package cn.commandoptionesc.request;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;

       /**
        ,* 请求转发的细节：
        ,* 与RequestDemo7一组
        ,*/
       public class RequestDemo6 extends HttpServlet {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               doGet(request, response);
           }
           protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               //请求转发之前如果response缓冲区中有数据
               //则在请求转发的时候会将response缓冲区清空
               //response.getWriter().write("aaa");
               //冲刷缓冲区
               //如果在请求转发之前，冲刷response缓冲区则会造成一次响应操作
               //一旦发生一次响应操作，请求转发中的响应就无法实现。
               //因为在请求转发的模型中只能出现一次响应
               //冲刷缓冲区已经造成一次响应操作，那么请求转发中的响应就无法正常工作，导致最终报错。
               //response.flushBuffer();
               //请求转发
               request.getRequestDispatcher("/servlet/RequestDemo7").forward(request,response);
               //如果在请求转发之后冲刷缓冲区，那么为时已晚，请求转发已经做出了影响动作，不会再次执行响应操作了
               //response.getWriter().write("aaa");
               //response.flushBuffer();
           }
       }


     #+END_SRC
     #+BEGIN_SRC java
       package cn.commandoptionesc.request;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;

       /**
        ,* 与RequestDemo6一组
        ,*/
       public class RequestDemo7 extends HttpServlet {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               doGet(request, response);
           }
           protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               response.getWriter().write("bbb");
           }
       }

     #+END_SRC
     [[./Img/59.png]]
     #+BEGIN_SRC java
       package cn.commandoptionesc.request;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;
       /**
        ,* 请求转发细节：
        ,*   请求转发前后的语句都会正常执行,并且按照请求转发的顺序执行
        ,*
        ,*   可以实现多重转发，不可以在一个servlet中多次请求转发
        ,*/
       public class RequestDemo8 extends HttpServlet {
           public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               doGet(request,response);
           }
           public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               System.out.println("RequestDemo8 Start......");
               request.getRequestDispatcher("/servlet/RequestDemo9").forward(request,response);
               System.out.println("RequestDemo8 End......");
           }
       }

     #+END_SRC
     #+BEGIN_SRC java
       package cn.commandoptionesc.request;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;

       public class RequestDemo9 extends HttpServlet {
           public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               doGet(request, response);
           }
           public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               System.out.println("RequestDemo9 Start......");
               //response.getWriter().write("I am Demo 9");
               //再次转发，将RequestDemo9转发到RequestDemo10
               //实现多重转发
               request.getRequestDispatcher("/servlet/RequestDemo10").forward(request,response);
               System.out.println("RequestDemo9 End......");
           }
       }

     #+END_SRC
     #+BEGIN_SRC java
       package cn.commandoptionesc.request;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;

       public class RequestDemo10 extends HttpServlet {
           public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
               doGet(request,response);
           }
           public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
               response.getWriter().write("I am Demo10");
           }
       }

     #+END_SRC
**** 4. 注意：请求转发是web应用内部的资源跳转，不可以在web应用之间跳转
*** 5. request功能三 --- 作为域对象使用
**** 1. 域对象概述
   域对象就是一个对象有一个可以被看见的范围，在这个范围内利用对象身上的map实现数据、资源的共享，像这样的一个对象称之为域对象。
**** 2. 域对象的时候用方式：
   1. setAttribute() 像域中添加数据
   2. setAttribute(String name) 获取指定名称的域属性
   3. removeAttribute(String name) 删除指定名称的域属性
   4. getAttributeNames()   获取全部域属性的名称
   #+BEGIN_SRC java
     request.getParameter("name"); //请求参数中包含的参数
     request.getAttribute("name"); //域中包含的属性
   #+END_SRC
**** 3. request域对象的特点
   1. 声明周期：
      在请求链开始的时候request对象创建，在请求链结束的时候request对象销毁。
   2. 作用范围：
      请求链的范围即为request域对象的作用范围。(整个请求链)
   3. 主要功能
      在请求链中共享数据。
**** 4. 案例：从servlet向首页输出数据
   1. 使用request域对象实现
   2. 代码如下：
      #+BEGIN_SRC java
        package cn.commandoptionesc.request;

        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        /**
         ,* 作为域对象使用：
         ,* 向域中添加数据
         ,* 请求转发给首页展示
         ,*/
        public class RequestDemo11 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request, response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                String username = "lishuai";
                int age = 19;
                String addr = "bj";
                String gender = "男";
                //第一步添加数据到request域中
                request.setAttribute("username",username);
                request.setAttribute("age",age);
                request.setAttribute("addr",addr);
                request.setAttribute("gender",gender);
                //添加完数据后，请求转发到首页
                request.getRequestDispatcher("/index.jsp").forward(request,response);
            }
        }

      #+END_SRC
      #+BEGIN_SRC xml
        <%@ page import="java.util.*" pageEncoding="UTF-8" language="java" %>
        <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
        <html>
         <head>
          <title>My JSP 'index.jsp' starting page</title>
         </head>
         <body>
          <!-- 在首页中获取RequestDemo11中设置的域属性对应的值 -->
          姓名：<%=request.getAttribute("username")%>
          年龄：<%=request.getAttribute("age")%>
          性别：<%=request.getAttribute("gender")%>
          地址：<%=request.getAttribute("addr")%>
         </body>
        </html>
      #+END_SRC
*** 6. request功能四 --- 请求包含
**** 1. 请求包含概念
   一个动态资源和另一个动态资源一起处理一个请求操作，并将两个Servlet的结果合并输出给浏览器，像这样的过程称作请求包含。
**** 2. 请求包含的特点
   [[./Img/60.png]]
**** 3. 请求包含实现:
代码如下：
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 请求包含实现
      ,* 与RequestDemo13一组
      ,*/
     public class RequestDemo12 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             response.getWriter().write("aaa");
             //获取一个调度器
             //利用调度器实现请求包含
             request.getRequestDispatcher("/servlet/RequestDemo13").include(request,response);
         }
     }

   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.request;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 与RequestDemo12一组
      ,*/
     public class RequestDemo13 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             response.getWriter().write("$100000000");
         }
     }

   #+END_SRC
** Response
*** 1. response对象
1. 继承机构
   #+BEGIN_SRC
     ServletResponse
           |
           | --- HttpServletResponse 包含HTTP协议相关的API操作，跟适合用户HTTP协议相关的开发
   #+END_SRC
2. HTTP响应的组成
   #+BEGIN_SRC
   一个状态行            200成功     302+location请求重定向    304、307缓存   404资源找不到  500服务出错
   多个响应头            refresh   定时刷新  location地址  Expires   Pragma   Cache-Cotrol  控制缓存
   一个空行
   响应实体内容           response缓冲区
   #+END_SRC
3. response对象的操作
   1. 设置状态码的方法
      void setStatus(int sc)

      void setStatus(int sc,String sm)
   2. 设置响应头的方法
      void setHeader(String name,String value)

      void setDateHeader(String name,long date)

      void setIntHeader(String name,int value)

      void addHeader(String name,String value)

      void addDateHeader(String name,long date)

      void addIntHeader(String name,int value)
   3. 设置响应内容的方法
      ServletOutputStream getOutputStream()

      PringWriter getWriter()
*** 2. response参数乱码处理
1. 字节流乱码处理
   #+BEGIN_SRC java
     response.getOutputStream().write("中文".getBytes());
   #+END_SRC
   当前语句执行不发生乱码，由于浏览器接收数据采用系统默认的GBK字符集，服务器发送数据采用servlet默认的GBK字符集，编解码一致所以不会出现乱码。
   #+BEGIN_SRC java
     response.getOutputStream().write("中文".getBytes("utf-8"));
   #+END_SRC
   - 在服务器发送数据的时候如果使用utf-8，浏览器也必须以utf-8字符集来接收数据，才能避免乱码的出现。所以应该通过浏览器使用utf-8字符集。
   - 通知的方式如下：
     #+BEGIN_SRC java
       response.setHeader("Content-Type","text/html;charset=utf-8");
     #+END_SRC
     此句会通知浏览器使用utf-8来接收数据
   #+BEGIN_SRC java
     package cn.commandoptionesc.response;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 响应参数乱码处理
      ,* getOutputStream()
      ,* getWriter()
      ,*/
     public class ResponseDemo1 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //通知浏览器使用utf-8字符集接收数据
             response.setHeader("Content-Type","text/html;charset=utf-8");
             response.getOutputStream().write("中文".getBytes());
         }
     }
   #+END_SRC
 2. 字符流乱码处理
    #+BEGIN_SRC java
      response.getWriter().write("中文");
    #+END_SRC
    服务器以字符流发送数据本质上仍然是用字节流发送数据。在服务器发送数据的时候会采用tomcat默认的字符集进行编码iso8859-1操作，在这个字符集中没有中文，自然就会出现乱码
 3. 必须通知服务器和浏览器两方面都是用utf-8字符集才能避免乱码
    1. 通知服务器和使用utf-8字符集
       #+BEGIN_SRC java
         response.setCharacterEncoding("utf-8");
       #+END_SRC
    2. 通知浏览器使用utf-8字符集
       #+BEGIN_SRC java
         response.setHeader("Content-Type","text/html;charset=utf-8");
       #+END_SRC
 4. 在通知浏览器使用utf-8字符集时，服务器也自动采用所通知的字符集来发送数据
 5. response.setHeader("Content-Type","text/html;charset=utf-8");可以简写为：response.setContentType("text/html;charset=utf-8");
 #+BEGIN_SRC java
   package cn.commandoptionesc.response;

           import javax.servlet.ServletException;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.IOException;

   /**
    ,* 响应参数乱码处理
    ,* getOutputStream()
    ,* getWriter()
    ,*/
   public class ResponseDemo1 extends HttpServlet {
       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           doGet(request, response);
       }
       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           //通知服务器使用utf-8字符集
           response.setCharacterEncoding("utf-8");
           //通知浏览器使用utf-8字符集接收数据
           //response.setHeader("Content-Type","text/html;charset=utf-8");
           response.setHeader("Content-Type","text/html;charset=utf-8");
           response.getWriter().write("中文");
       }
   }
 #+END_SRC
 6. 总结：
    1. 在面对字节流和字符流的时候都是用通知浏览器的方式来修改字符集
    2. 字节流和字符流是不可以同时使用的。会在第二个流身上发生异常
    3. 使用流之后不需要关闭，浏览器会自动帮助我们关闭流。千万不要手动关闭可能会发生异常。
    4. 将通知服务器与浏览器的使用字符集的语句书写在所有代码之前。
*** 3. response功能一 --- 请求重定向
[[./Img/61.png]]
1. 请求重定向
   是一种资源跳转方式，可以在不同的服务器之间跳转。
2. 请求重定向的特点：
   #+BEGIN_SRC
     两次请求两次响应
     两次请求对象两个响应对象
     服务器之间的资源跳转
     浏览器地址栏会发生变化
   #+END_SRC
3. 请求重定向的实现：
   1. 设置状态码302
      #+BEGIN_SRC java
        response.setStatus(302);
      #+END_SRC
   2. 设置响应头location
      #+BEGIN_SRC java
        response.setHeader("location","http://www.tmooc.cn");
        response.setHeader("location",request.getContextPath()+"/servlet/ResponseDemo1");
        response.sendRedirect("http://www.baidu.com");
      #+END_SRC
   3. 也可以通过一下代码实现重定向
      #+BEGIN_SRC java
        response.sendRedirect(location);
      #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.response;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 请求重定向
      ,*/
     public class ResponseDemo2 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //1. 设置302状态码
             //response.setStatus(302);
             //2. 设置location响应头
             //response.setHeader("location","http://www.tmooc.cn");
             //response.setHeader("location",request.getContextPath()+"/servlet/ResponseDemo1");
             response.sendRedirect("http://www.baidu.com");
         }
     }

   #+END_SRC
*** 4. response功能二 --- 定时刷新
[[./Img/62.png]]
1. 定时刷新概念
   是一种资源跳转方式，可以在不同服务器之间跳转
2. 定时刷新的特点：
   #+BEGIN_SRC
     两次请求两次响应
     两个请求对象两个响应对象
     服务器之间的资源跳转
     浏览器地址栏会发生变化
   #+END_SRC
   注意：与请求重定向不同是定时刷新会等待指定时候之后才跳转。
3. 定时刷新的实现：
   只需设置一个refresh响应头即可。
   #+BEGIN_SRC java
     response.setContentType("text/html;charset=utf-8");
     response.getWriter().write("<h1 align='center'><font color='red'>3秒钟之后跳转！</font></h1>");
     //设置响应头
     response.setHeader("refresh","3;url=http://www.tmooc.cn");
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.response;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     /**
      ,* 定时刷新
      ,*/
     public class ResponseDemo3 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             response.setContentType("text/html;charset=utf-8");
             response.getWriter().write("<h1 align='center'><font color='red'>3秒钟之后跳转</font></h1>");
             //设置响应头
             response.setHeader("refresh","3;url=http://www.baidu.com");
         }
     }
   #+END_SRC
*** 5. response功能三 --- 控制浏览器缓存
由于不同的浏览器的缓存行为可能是不同的，我们可以在服务器中通过何止响应头来控制浏览器的缓存行为！！
1. 控制浏览器不要缓存
   #+BEGIN_SRC java
     response.setDateHeader("Expires",-1);
     response.setHeader("Pragma","no-cache");
     response.setHeader("Cache-control","no-cache");
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.response;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.util.Date;

     /**
      ,* 控制缓存：
      ,* 不使用缓存
      ,*/
     public class ResponseDemo4 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //不使用缓存
             response.setDateHeader("Expires",-1);//1970-01-01
             response.setHeader("Pragma","no-cache");
             response.setHeader("Cache-control","no-cache");
             Date date = new Date();
             String time = date.toLocaleString();
             response.getWriter().write("time:"+time);
         }
     }

   #+END_SRC
2. 控制浏览器缓存：
   #+BEGIN_SRC java
     response.setDateHeader("Expires",System.currentTimeMillis()+1000*60*60*24);
     //24小时
     response.setHeader("Cache-control","max-age=60");//60秒
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.response;

     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.text.DateFormat;
     import java.text.SimpleDateFormat;
     import java.util.Date;

     /**
      ,* 控制缓存：
      ,* 使用缓存
      ,*/
     public class ResponseDemo5 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //当前缓存3秒钟
             //response.setHeader("Cache-control","max-age=3");
             //当前缓存24小时
             response.setDateHeader("Expires",System.currentTimeMillis()+1000*60*60*24);

             Date date = new Date();
             //String time = date.toLocaleString();
             //response.getWriter().write("time:"+time);
             SimpleDateFormat sdf = (SimpleDateFormat) DateFormat.getDateTimeInstance();
             response.getWriter().write("time:"+sdf.format(date));
         }
     }
   #+END_SRC
** 课堂笔记
*** 1. 概述
[[./Img/servlet的编写步骤和调用过程.png]]
**** 1. servlet是什么？？？
#+BEGIN_SRC
  servlet是由sun公司提供的一套接口规范，是专门应用于javaweb网站的开发技术。
  servlet = server + applet 服务端的应用程序。
  servlet是web应用服务器实现了 这一套接口规范，tomcat实现了servlet的接口规范。
#+END_SRC
**** 2. servlet的主要作用
#+BEGIN_SRC
  处理客户端（浏览器）发送过来的HTTP请求，
  响应给客户端（浏览器）一个请求的结果。
  举例： 我百度搜索【手机】 --> 点击按钮搜之后 --> 得到【响应结果】
#+END_SRC
**** 3. servlet的API
servlet的API在哪里？？？
1. 如果要是使用servlet，那么必须要先导入 它的jar包
   #+BEGIN_SRC
      tomcat ---> lib库
                    | --- servlet-api.jar
   #+END_SRC
**** 4. 编写一个servlet的程序：入门案例
1. 在src目录下
   - 创建一个package包：cn.tedu.servlet
   - 创建一个java类：Servlet01_servlet接口
2. 需要先实现 Servlet接口
3. servlet程序如果要进行代码的执行，需要浏览器发送一个请求过来才可以
   举例： servlet相当于餐厅服务员的觉得，只有当有客户过来用餐时，服务员才会执行起来。
4. 需要在web.xml中配置一个文件：servlet的映射关系
   举例： 就相当于客户点餐时，需要一个菜单，服务员看到菜单才知道客户要什么！！！
   #+BEGIN_SRC xml
     <!--servlet的映射关系：浏览器请求  与  servlet代码 的映射关系 -->
     <servlet>
         <!--servlet-name是程序员自定义的名字：相当于一个菜名-->
         <servlet-name>hello</servlet-name>
         <servlet-class>cn.tedu.servlet.Servlet01_servlet接口</servlet-class>
     </servlet>
     <servlet-mapping>
         <!--必须与servlet标签的name对应-->
         <servlet-name>hello</servlet-name>
         <!--浏览器发送请求的资源路径：相当于 客户点菜-->
         <url-pattern>/hello</url-pattern>
     </servlet-mapping>
   #+END_SRC
   #+BEGIN_SRC java
     package cn.tedu.servlet;

     import javax.servlet.*;
     import java.io.IOException;

     public class Servlet01_servlet接口 implements Servlet {

         @Override
         public void init(ServletConfig servletConfig) throws ServletException {
             System.out.println("这是一个初始化方法，先执行init（）方法");
         }

         @Override
         public ServletConfig getServletConfig() {
             return null;
         }

         @Override
         public void service(ServletRequest servletRequest, ServletResponse servletResponse)
                 throws ServletException, IOException {
             System.out.println("这是service服务方法，程序员编写业务逻辑（处理请求的代码）就在这里写！！！");
         }

         @Override
         public String getServletInfo() {
             return null;
         }

         @Override
         public void destroy() {
             System.out.println("大哥....我快不行了...救救我，这是遗言！！");
         }
     }

   #+END_SRC
*** 2. servlet的GenericServlet详解
[[./Img/抽象类GeneraicServlet.png]]
**** 1. servlet是一个接口，内部只有方法签名，没有方法体
如果要使用servlet就必须实现servlet接口，有以下方法：
#+BEGIN_SRC
  void destroy() ----常用
  ServletConfig getServletConfig()
  String getServletInfo()
  void init(ServletConfig config)  ----常用
  void service(ServletRequest req, ServletResponse res)  ---最常用
#+END_SRC
**** 2. servlet的一个实现类：GenericServlet类
对Serlvet接口中的大部分方法都做了默认实现，只有service方法是一个抽象方法需要继承者自己实现。实现者只需要实现Service方法在其中写处理请求的代码即可。

创建一个类：cn.tedu.servlet.Servlet02_GenericServlet
#+BEGIN_SRC java
  public class Servlet02_GenericServlet extends GenericServlet {
      @Override
      public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
          //主要的业务逻辑代码
          //实现的功能如下：在浏览器中显示当前的日期时间
          Date date = new Date();
          //如何把data日期 返回给浏览器
          System.out.println(date.toString());
          //参数一：ServletRequest 是 接受浏览器的请求
          //参数二：ServletResponse 是 响应给浏览器的结果
          //servletResponse.getWriter();它只是通过response打开一个wirter流
          servletResponse.getWriter().write(date.toString());
      }
  }
#+END_SRC
**** 3. 浏览器发送HTTP请求的方式：7种
- 常用的有：
  *GET* 方式和 *POST* 方式；
- 不常用的有：
  /PUT / 、 / DELETE / 和 / TARCE,HEAD / 、 / OPTIONS/
#+BEGIN_SRC
  问题是：GenericServlet.service()是专门接受请求的，那么它能接受多少中HTTP请求？？
  答案：能接受以上7种所有的请求。接受请求后，不同的请求方式，比如get和post方式，那么service方法中的处理逻辑要分开执行，get方式的请求执行get的代码逻辑，post方式的请求执行post的代码逻辑
#+END_SRC
这种书写方式很繁琐，需要简化处理！！！！
#+BEGIN_SRC java
  package cn.tedu.servlet;

  import javax.servlet.GenericServlet;
  import javax.servlet.ServletException;
  import javax.servlet.ServletRequest;
  import javax.servlet.ServletResponse;
  import javax.servlet.http.HttpServletRequest;
  import java.io.IOException;
  import java.util.Date;

  public class Servlet02_GenericServlet extends GenericServlet {

      @Override
      public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

          //主要的业务逻辑代码
          //实现的功能如下：在浏览器中显示当前的日期时间
          Date date = new Date();
          //如何把data日期 返回给浏览器
          System.out.println(date.toString());
          //参数一：ServletRequest 是 接受浏览器的请求
          //参数二：ServletResponse 是 响应给浏览器的结果
          //servletResponse.getWriter();它只是通过response打开一个wirter流
          servletResponse.getWriter().write(date.toString());

          //根据不同的请求，会执行不同的代码逻辑
          //1.获取浏览器的请求方式
          HttpServletRequest req = (HttpServletRequest) servletRequest;
          String method = req.getMethod();//得到http的请求方式
          System.out.println("请求方式："+method);
          if ("GET".equalsIgnoreCase(method)) {
              System.out.println("get方式的处理逻辑在这里写");
          } else if ("POST".equalsIgnoreCase(method)) {
              System.out.println("post方式的处理逻辑在这里写");
          }
      }
  }

#+END_SRC
*** 3. servlet的HttpServlet详解
**** 1.HttpServlet的继承关系
HttpServlet 的诞生 是专门为了HTTP请求而服务的！！！

HttpServlet  extends  GenericServlet  implements Servlet
**** 2.HttpServlet的方法详解
#+BEGIN_SRC java
  protected  void doDelete(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a DELETE request.
      由服务器（通过服务方法）调用，以允许servlet处理删除请求。
  protected  void doGet(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a GET request.
      服务器（通过服务方法）允许servlet处理GET请求。
  protected  void doHead(HttpServletRequest req, HttpServletResponse resp)
      Receives an HTTP HEAD request from the protected service method and handles the request.
      从受保护的服务方法接收HTTP HEAD请求并处理该请求。
  protected  void doOptions(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a OPTIONS request.
      由服务器（通过服务方法）调用，以允许servlet处理选项请求。
  protected  void doPost(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a POST request.
      由服务器（通过服务方法）调用，以允许servlet处理POST请求。
  protected  void doPut(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a PUT request.
      由服务器（通过服务方法）调用，以允许servlet处理PUT请求。
  protected  void doTrace(HttpServletRequest req, HttpServletResponse resp)
      Called by the server (via the service method) to allow a servlet to handle a TRACE request.
      由服务器（通过服务方法）调用，以允许servlet处理跟踪请求。
  protected  long getLastModified(HttpServletRequest req)
      Returns the time the HttpServletRequest object was last modified, in milliseconds since midnight January 1, 1970 GMT.
      返回HttpServletRequest对象上次修改的时间，以自1970年1月1日格林尼治标准时间午夜起的毫秒为单位。
  protected  void service(HttpServletRequest req, HttpServletResponse resp)
      Receives standard HTTP requests from the public service method and dispatches them to the doXXX methods defined in this class.
      接收来自公共服务方法的标准HTTP请求，并将它们分派给该类中定义的doXXX方法。
  void service(ServletRequest req, ServletResponse res)
      Dispatches client requests to the protected service method.
      将客户端请求分派到受保护的服务方法。
#+END_SRC
**** 3. HttpServlet的方法：service()方法
#+BEGIN_SRC java
  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
      String method = req.getMethod();
      long lastModified;
      if (method.equals("GET")) {
          ...
              this.doGet(req, resp);
      } else if (method.equals("HEAD")) {
          lastModified = this.getLastModified(req);
          this.maybeSetLastModified(resp, lastModified);
          this.doHead(req, resp);
      } else if (method.equals("POST")) {
          this.doPost(req, resp);
      } else if (method.equals("PUT")) {
          this.doPut(req, resp);
      } else if (method.equals("DELETE")) {
          this.doDelete(req, resp);
      } else if (method.equals("OPTIONS")) {
          this.doOptions(req, resp);
      } else if (method.equals("TRACE")) {
          this.doTrace(req, resp);
      } else {
          String errMsg = lStrings.getString("http.method_not_implemented");
          Object[] errArgs = new Object[]{method};
          errMsg = MessageFormat.format(errMsg, errArgs);
          resp.sendError(501, errMsg);
      }

  }
#+END_SRC
**** 4. 模拟一个场景：用户的一个注册提交的场景
创建一个注册页面：param.html
#+BEGIN_SRC html
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8" />
    </head>
    <body>
      <h1>GET提交</h1>
      <form action="/day10-servlet/demo3" method="GET">
        用户名: <input type="text" name="username" />
        昵称: <input type="text" name="nickname" />
        <input type="submit" value="提交" />
      </form>
      <h1>POST提交</h1>
      <form action="/day10-servlet/demo3" method="POST">
        用户名: <input type="text" name="username" />
        昵称: <input type="text" name="nickname" />
        爱好: <input type="checkbox" name="like" value="lanqiu" />篮球
        <input type="checkbox" name="like" value="zuqiu" />足球
        <input type="checkbox" name="like" value="taiqiu" />台球
        <input type="submit" value="提交" />
      </form>
    </body>
  </html>
#+END_SRC
把页面复制到【day10-servlet/web/param.html】
- 代码的编写步骤：
  1. 修改param.html中form表单的action路径：是一个请求的url
     #+BEGIN_SRC
       /web虚拟路径的名称/请求的名称
       action="/day10-servlet/demo03"
     #+END_SRC
  2. 配置web.xml，完成url路径与servlet类的映射关系
     #+BEGIN_SRC xml
       <?xml version="1.0" encoding="UTF-8"?>
       <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
                version="4.0">
         <!--这是案例02的映射关系-->
         <servlet>
           <servlet-name>demo02</servlet-name>
           <servlet-class>cn.tedu.servlet.Servlet02_GenericServlet</servlet-class>
         </servlet>
         <servlet-mapping>
           <servlet-name>demo02</servlet-name>
           <url-pattern>/demo02</url-pattern>
         </servlet-mapping>
       </web-app>
     #+END_SRC
  3. 编写后台的servlet的代码,找到doGet()与doPost()方法
     #+BEGIN_SRC java
       package cn.tedu.servlet;

       import javax.servlet.ServletException;
       import javax.servlet.http.HttpServlet;
       import javax.servlet.http.HttpServletRequest;
       import javax.servlet.http.HttpServletResponse;
       import java.io.IOException;

       public class Servlet03_HttpServlet extends HttpServlet {

           @Override
           protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               //程序员自己处理的代码逻辑，可以被重复的调用
               String method = req.getMethod();
               System.out.println("执行了do"+method+"方法："+method);
           }

           @Override
           protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               this.doGet(req, resp);
               //String method = req.getMethod();
               //System.out.println("执行了doPost方法："+method);
           }
       }
     #+END_SRC
*** 4. servlet的HttpServletRequest详解
[[./Img/HTTP请求.png]]
**** 1. Request的继承结构
1. ServletRequest：接口
   定义将客户端请求信息提供给某个servlet的对象。servlet容器(tomcat服务器中的一个组件)创建ServletRequest对象，并将该对象作为参数传递给该servlet的service方法。接受的请求不仅仅是HTTP类型的请求,还可能是其他类型的请求，
   + 特别注意：javaweb课程，包括以后工作中，默认的都是HTTP协议的请求
2. HttpServletRequest(以后写代码用),只接收HTTP协议的请求
   主要作用：扩展javax.servlet.ServletRequest接口，为HttpServlet提供请求信息。
   #+BEGIN_SRC
   ServletRequest接口
             |
             | --- HttpServletRequest接口 （对ServletRequest的扩展）
             |           |                  （提供了更多的方法，去操作HTTP协议）
                         |
                         |  --- HttpServletRquestWrapper （实现类）
                         |    tomcat服务器会自动创建一个对象：HttpServletRequest类型的对象
                         |      HttpServletRequest   req = new  HttpServletRquestWrapper();
   #+END_SRC
**** 2. HttpServletRequest的常用方法
***** 1. 获取客户端相关信息
      #+BEGIN_SRC java
        /*("/request01") 代表的是 浏览器发送过来的请求信息  */
        @WebServlet("/request01") /*完全代替了web.xml的配置文件映射关系*/
        public class Request01_获取客户机相关信息 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                this.doGet(request,response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //编写自己的业务逻辑
                /**
                 ,* getRequestURL方法 -- 返回客户端发出请求完整URL
                 ,*    结果：http://localhost:80/day10_servlet_war_exploded/request01
                 ,* getRequestURI方法 -- 返回请求行中的资源名部分
                 ,*    结果： /request01
                 ,* getQueryString方法 -- 返回请求行中的参数部分
                 ,*     结果： username=...&password=...
                 ,* getRemoteAddr方法 -- 返回发出请求的客户机的IP地址
                 ,*     结果：127.0.0.1:80
                 ,* getMethod方法 -- 返回客户机的请求方式
                 ,*     结果：GET/POST
                 ,* getContextPath方法 -- 获得当前web应用的虚拟目录名称
                 ,*      结果：/day10_servlet_war_exploded
                 ,*/
                String url = request.getRequestURL().toString();
                System.out.println("完整请求路径"+url);
                String requestURI = request.getRequestURI();
                System.out.println("资源路径："+requestURI);
                String queryString = request.getQueryString();
                System.out.println("请求行中参数："+queryString);
                String remoteAddr = request.getRemoteAddr();
                System.out.println("客户机的IP地址："+remoteAddr);
                String contextPath = request.getContextPath();
                System.out.println("虚拟目录名称："+contextPath);
            }
        }
      #+END_SRC

***** 2. 获取请求头信息
#+BEGIN_SRC java
  package cn.tedu.servlet;

  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.util.Enumeration;

  @WebServlet("/request02")
  public class Request02_获取请求头信息 extends HttpServlet {

      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          this.doPost(req,resp);
      }

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          /**
           ,* getHeader(name)方法 --- String
           ,* getHeaders(String name)方法 --- Enumeration<String>
           ,* getHeaderNames方法 --- Enumeration<String>
           ,* getIntHeader(name)方法 --- int
           ,* getDateHeader(name)方法 --- long(日期对应毫秒)
           ,*/
          //获取请求头中的信息
          /*   Host: localhost
           ,* getHeader(name) : name表示字符串类型的key ，返回值是字符串类型value
           ,* */
          String host = req.getHeader("Host");
          System.out.println(host);
          String accept = req.getHeader("Accept");
          System.out.println(accept);

          /*
           ,*  getHeaders(String name)方法 --- Enumeration<String>
           获取多个同名的请求头对应的内容
           ,* */
          Enumeration<String> headers = req.getHeaders("Host");
          while(headers.hasMoreElements()){
              String string = (String)headers.nextElement();
              System.out.println("head:"+string);
          }

          //这是返回了一个所有的请求头信息，枚举类型的集合
          Enumeration<String> headerNames = req.getHeaderNames();
          //判断集合是否存在元素
          while (headerNames.hasMoreElements()) {
              //获取元素对象，返回值是 请求头的key
              String headerName = headerNames.nextElement();
              String value = req.getHeader(headerName);
              System.out.println("head:"+headerName+"   value:"+value);
          }

          /* Upgrade-Insecure-Requests：1 value值是int类型
           ,*  getIntHeader(name)  --- 返回值int
           ,* */
          int intHeader = req.getIntHeader("Upgrade-Insecure-Requests");
          System.out.println("int类型的值："+intHeader);

          /*
           ,* getDateHeader(name)  --- 返回值 date的 long类型（毫秒数）
           ,* */
          long dateHeader = req.getDateHeader("Date");
          System.out.println("测试："+dateHeader);
      }
  }
#+END_SRC
***** 3. 获取请求参数
#+BEGIN_SRC java
  package cn.tedu.servlet;

  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;

  @WebServlet("/request03")
  public class Request03_获取请求中的参数 extends HttpServlet {

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          this.doGet(req,resp);
      }

      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          //设置请求对象 req的编码格式为 utf-8
          req.setCharacterEncoding("utf-8");
          //设置响应队形  resp的编码格式为 utf-8
          resp.setContentType("text/html;charset=utf-8");

          //获取请求中的参数信息：key=value ，获取结果为value
          /*模拟一个场景：注册信息的获取*/
          String username = req.getParameter("username");
          String password = req.getParameter("password");
          System.out.println(username);
          System.out.println(password);
          //如果注册用户名是tony
          if ("tony".equals(username)) {
              resp.getWriter().write("注册失败，tony已经存在了");
          } else {
              resp.getWriter().write("注册成功了");
          }
      }
  }

#+END_SRC
* EasyMall注册功能
1. 搭建虚拟主机
   搭建一台www.easymall.com的虚拟主机，并且将这台虚拟主机配置成一个缺省的虚拟主机。
   1. 修改[tomcat]/conf目录中的server.xml文件添加内容如下：
      #+BEGIN_SRC xml
        <Host name="www.easymall.com" appBase="/Users/coe/commandoptionesc/idea-workspace/EasyMall">
        </Host>
      #+END_SRC
   2. 在Engine标签身上修改缺省的虚拟主机为www.easymall.com
      #+BEGIN_SRC xml
        <Engine name="Catalina" defaultHost="www.easymall.com">
      #+END_SRC
   3. 配置hosts文件：
      在hosts文件设置 127.0.0.1  www.easymall.com
2. 发布一个web应用到虚拟主机中
   创建一个名称为EasyMall的web应用，并且将web应用作为缺省web应用部署到www.easymall.com网站中
3. 添加页面到EasyMall中
4. 组合页面
   1. 首页的构成分为三部分，头部，身体和尾部
   2. 在身体index.jap页面中引入头部和尾部
      代码实现：在body标签中添加头部和尾部
      <%@include file="_foot.jsp"%>
      #+BEGIN_SRC
        <BODY>
        <!--添加首部和尾部-->
            <!--添加首部-->
            <%--<%request.getRequestDispatcher("/_head.jsp").include(request,response);%>--%>
            <%@include file="_head.jsp"%>
        <!--引入尾部-->
            <%--<%request.getRequestDispatcher("/_foot.jsp").include(request,response);%>--%>
            <%@include file="_foot.jsp"%>
        </BODY>
      #+END_SRC
5. 引入regist.jsp页面
   1. 将课前资料中的regist目录所有内容复制粘贴到webroot目录中
   2. 修改regist.html页面为regist.jsp方式和上方修改方式一样。
   3. 删除regist.html页面。
   4. 修改_head.jsp页面中内容
      #+BEGIN_SRC
        <div id="content">
            <a href="#">登陆</a>&nbsp;&nbsp;&nbsp;&nbsp;
            <a href="<%=request.getContextPath()%>/regist.jsp">注册</a>
        </div>
      #+END_SRC
6. 修改regist.jsp页面代码
   #+BEGIN_SRC
     <form action="<%=request.getContextPath()%>/RegistServlet" method="POST">
     </form>
   #+END_SRC
7. 创建一个注册功能的RegistServlet
   #+BEGIN_SRC java
     package com.easymall.servlet;

     import com.easymall.utils.JDBCUtils;
     import com.easymall.utils.WebUtils;
     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.sql.Connection;
     import java.sql.PreparedStatement;
     import java.sql.ResultSet;

     /**
      ,* 注册功能
      ,*/
     public class RegistServlet extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
             //乱码处理
             //处理请求参数乱码
             request.setCharacterEncoding("utf-8");
             //处理响应乱码
             response.setContentType("text/html;charset=utf-8");

             //获取用户发送的参数信息
             String username = request.getParameter("username");
             String password = request.getParameter("password");
             String password2 = request.getParameter("password2");
             String nickname = request.getParameter("nickname");
             String email = request.getParameter("email");
             String valistr = request.getParameter("valistr");
             //非空校验
             if(WebUtils.isNULL(username)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","用户名称不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             if(WebUtils.isNULL(password)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","密码不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             if(WebUtils.isNULL(password2)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","确认密码不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             if(WebUtils.isNULL(nickname)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","昵称不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             if(WebUtils.isNULL(email)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","邮箱不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             if(WebUtils.isNULL(valistr)){
                 //注册页面提示：用户名称不能为空
                 request.setAttribute("msg","验证码不能为空");
                 //请求转发之后当前servlet与regist.jsp页面看到的是同一块域，可以共享数据
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             //邮箱格式校验
             //lishuai@tide.com
             String reg = "\\w+@\\w+(\\.\\w+)+$";
             if (!email.matches(reg)) {
                 request.setAttribute("msg","邮箱格式错误");
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             //密码一致性校验
             if(!password.equals(password2)){
                 request.setAttribute("msg","两次密码不一致");
                 request.getRequestDispatcher("/regist.jsp").forward(request,response);
                 return;
             }
             //验证码校验
             //TODO:session

             //完成注册
             //用户名存在校验
             Connection conn = null;
             PreparedStatement ps = null;
             ResultSet rs = null;
             try {
                 conn = JDBCUtils.getConnection();
                 ps = conn.prepareStatement("select * from user where username = ?");
                 ps.setString(1,username);
                 rs = ps.executeQuery();
                 //如果能欧冠查询到结果则证明用户已经存在不允许注册，并且在前台页面做出提示
                 if (rs.next()) {
                     request.setAttribute("msg","用户名已经存在");
                     request.getRequestDispatcher("/regist.jsp").forward(request,response);
                     return;
                 }else{
                     //用户名不存在就可以将用户信息插入到数据库中
                     ps = conn.prepareStatement("insert into user values(null,?,?,?,?)");
                     ps.setString(1,username);
                     ps.setString(2,password);
                     ps.setString(3,nickname);
                     ps.setString(4,email);
                     ps.executeUpdate();
                 }
             } catch (Exception e) {
                 e.printStackTrace();
             }finally{
                 JDBCUtils.close(conn,ps,rs);
             }
             //跳转回首页
             //定时刷新
             response.getWriter().write("<h1 align='center'><font color='red'>恭喜注册成功，3秒之后跳转回首页</font></h1>");
             response.setHeader("refresh","3;url=http://www.easymall.com");
         }

         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

         }
     }

     ,#+END_SR
         8. 创建WebUtiles工具类
         ,#+BEGIN_SRC java
         package com.easymall.utils;

     /**
      ,* 判断是否为空的工具类
      ,*/
     public class WebUtils {
         private WebUtils() {

         }
         public static boolean isNULL(String name){
             //return name.trim().equals("") || name == null;
             //如果用户名为空的话 null.trim()...就会造成空指针异常
             //""双引号放在前面可以避免
             return "".equals(name.trim()) || name == null;
         }
     }
   #+END_SRC
9. 在regist.jsp页面中添加错误信息提示信息、回显操作
   1. 获取后台传递来的错误消息提示信息
      #+BEGIN_SRC
        <table>
          <tr>
            <td class="tds" colspan=2 style="color:red;text-align:center">
              <%=request.getAttribute("msg")==null?"":request.getAttribute("msg")%>
            </td>
          </tr>
        </table>
      #+END_SRC
   2. 数据回显操作
      在<input name="username" />添加value属性：
      #+BEGIN_SRC
        <input type="text" name="username" value="<%=request.getParameter("username")==null?"":request.getParameter("username")%>"/>
        <input type="text" name="nickname" value="<%=request.getParameter("nickname")==null?"":request.getParameter("nickname")%>"/>
        <input type="text" name="email" value="<%=request.getParameter("email")==null?"":request.getParameter("email")%>"/>
      #+END_SRC
10. 创建数据库
    #+BEGIN_SRC sql
      create database easymall;
      use easymall;
      create table user(id int primary key auto_increment,username varchar(100),password varchar(100),nickname varchar(100),email varchar(100));
      insert into user values(null,'admin','123','超级管理员','admin@tedu.cn');
      insert into user values(null,'张飞','123','管理员','admin@tedu.cn');
    #+END_SRC
11. 连接数据库
    1. 在当前web应用中添加数据库连接所需jar包，和c3p0的jar包。将两个包放入WEB-INF中的lib目录下。
    2. 导入之前使用的c3p0.properties配置文件，在其中修改配置如下：（将该配置文件放入src目录下）
       #+BEGIN_SRC
         c3p0.driverClass=com.mysql.cj.jdbc.Driver
         c3p0.jdbcUrl=jdbc:mysql://localhost:3306/easymall?useSSL=false&servertimezone=UTC
         c3p0.user=root
         c3p0.password=password
       #+END_SRC
12. 添加一个JDBCUtils工具类---获取连接、关闭资源
    #+BEGIN_SRC java
      package com.easymall.utils;

      import com.mchange.v2.c3p0.ComboPooledDataSource;
      import java.sql.*;
      /**
       ,* 获取连接和关闭资源
       ,*/
      public class JDBCUtils {
          private JDBCUtils(){

          }
          private static ComboPooledDataSource source = new ComboPooledDataSource();
          //获取连接
          public static Connection getConnection() throws SQLException {
              return source.getConnection();
          }
          //关闭资源
          /*连接写死，检测是否可以成功获取连接

            public static Connection getConnection() throws Exception{

            Class.forName("com.mysql.cj.jdbc.Driver");
            return DriverManager.getConnection
            ("jdbc:mysql://localhost:3306/easymall?useSSL=false&servertimezone=UTC&user=root&password=Root*0201");
            }
          ,*/
          public static void close(Connection conn, Statement stat, ResultSet rs){
              if(rs != null) {
                  try {
                      rs.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      rs = null;
                  }
              }
              if(stat != null) {
                  try {
                      stat.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      stat = null;
                  }
              }
              if(conn != null) {
                  try {
                      conn.close();
                  } catch (SQLException e) {
                      e.printStackTrace();
                  }finally{
                      conn = null;
                  }
              }
          }
      }
    #+END_SRC
13. 页面中添加前台校验
    在用户访问一个可提交的页面的时候，可能会频繁点击提交按钮，造成大量无效访问，让服务器的访问产生无意义的压力，应该通过一个前台校验避免这种情况。
    1. 在regist.jsp的head标签中添加如下代码
       在用户访问一个可提交的页面的时候，可能会频繁点击提交按钮，造成大量无效访问，让服务器的访问产生无意义的压力，应该通过一个前台校验避免这种情况。
       #+BEGIN_SRC java
         <!--引入jQuery函数库-->
             <script type="text/javascript" src="<%=request.getContextPath()%>/js/jquery-1.4.2.js">
              </script>
              <script type="text/javascript">
              /*前台校验操作*/
              var formObj= {
              checkForm : function() {
                  var canSub = true;
                  //调用checkNull把它当做一个函数使用
                  canSub = this.checkNull("username","用户名称不能为空") && canSub;
                  canSub = this.checkNull("password","密码不能为空") && canSub;
                  canSub = this.checkNull("password2","确认密码不能为空") && canSub;
                  canSub = this.checkNull("email","邮箱不能为空不能为空") && canSub;
                  canSub = this.checkNull("nickname","昵称不能为空") && canSub;
                  canSub = this.checkNull("valistr","验证码不能为空") && canSub;
                  canSub = this.checkEmail() && canSub;
                  canSub = this.checkPassword() && canSub;

                  return canSub;
              },
              checkPassword : function () {
                  //密码一致性校验
                  var password = $("input[name='password']").val();
                  var password2 = $("input[name='password2']").val();
                  if(password!="" && password2!="" && password != password2){
                      this.setMsg("password2","两次密码不一致");
                      return false;
                  }
                  return true;
              }
              ,
              checkEmail : function(){
                  //邮箱格式校验
                  var reg = /\w+@\w+(\.\w+)+/;
                  var email = $("input[name='email']").val();
                  //在邮箱不为空的情况下进行校验
                  if(email!="" && !reg.test(email)){
                      this.setMsg("email","邮箱格式不正确");
                      return false;
                  }
                  return true;
              }
              ,
              //非空校验
              checkNull : function (name,msg) {
                  var tag= $("input[name='"+name+"']").val();
                  //清空操作
                  //$("input[name='"+name+"']").val();
                  this.setMsg(name,"");
                  //去当前参数前后空格
                  if($.trim(tag) == ""){
                      //$("input[name='"+name+"']").nextAll("span").text(msg);
                      this.setMsg(name,msg);
                      return false;
                  }
                  return true;
              },
              setMsg : function (name,msg) {
                  //设置信息
                  $("input[name='"+name+"']").nextAll("span").text(msg).css("color","red");
              }
          };
         #+END_SRC
    2. 在form标签身上添加onsubmit属性：
       #+BEGIN_SRC
         <form action="<%=request.getContextPath()%>/RegistServlet" method="POST" onsubmit="return formObj.checkForm()">
         </form>
       #+END_SRC
       注意：前台的js校验只是为了降低无效访问，并不能真正阻拦用户提交错误数据到数据库中。后台Servlet代码才会真正的验证数据是否有效，阻拦错误数据进入数据库中。
14. 添加jQuery离开焦点校验
    #+BEGIN_SRC java
      //鼠标离开焦点事件
      //文档就绪时间
      $(function(){
              //鼠标离开焦点事件
              $("input[name='username']").blur(function() {
                      //非空校验操作，此处不需要重新写，调用就可以
                      //此处没有用户动态的传入的参数，只能手写参数名
                      formObj.checkNull("username", "用户名称不能为空");
              });
              $("input[name='username']").blur(function() {
                      formObj.checkNull("password", "密码不能为空");
              });
              $("input[name='username']").blur(function() {
                      formObj.checkNull("password2", "确认密码名称不能为空");
                      formObj.checkPassword();
              });
              $("input[name='username']").blur(function(){
                      formObj.checkNull("nickname","昵称不能为空");
              });
              $("input[name='username']").blur(function(){
                      formObj.checkNull("emial","邮箱不能为空");
                      formObj.checkEmail();
              });
      });
    #+END_SRC
15. 连接数据库判断用户名是否存在
    #+BEGIN_SRC java
      //完成注册
      //用户名存在校验
      Connection conn = null;
      PreparedStatement ps = null;
      ResultSet rs = null;
      try {
          conn = JDBCUtils.getConnection();
          ps = conn.prepareStatement("select * from user where username = ?");
          ps.setString(1,username);
          rs = ps.executeQuery();
          //如果能欧冠查询到结果则证明用户已经存在不允许注册，并且在前台页面做出提示
          if (rs.next()) {
              request.setAttribute("msg","用户名已经存在");
              request.getRequestDispatcher("/regist.jsp").forward(request,response);
              return;
          }else{
              //用户名不存在就可以将用户信息插入到数据库中
              ps = conn.prepareStatement("insert into user values(null,?,?,?,?)");
              ps.setString(1,username);
              ps.setString(2,password);
              ps.setString(3,nickname);
              ps.setString(4,email);
              ps.executeUpdate();
          }
      } catch (Exception e) {
          e.printStackTrace();
      }finally{
          JDBCUtils.close(conn,ps,rs);
      }
      //跳转回首页
      //定时刷新
      response.getWriter().write("<h1 align='center'><font color='red'>恭喜注册成功，3秒之后跳转回首页</font></h1>");
      response.setHeader("refresh","3;url=http://www.easymall.com");
      }
    #+END_SRC
** 课堂笔记
[[./Img/idea搭建EasyMall图片.png]]

[[./Img/EasyMall项目搭建与项目开发.png]]
*** 中文乱码
1. 接受请求时，出现乱码的原因：
   #+BEGIN_SRC
     浏览器的编码格式 与 服务器的编码格式不一致
     浏览器发送过来的参数 是 需要服务器进行解码，然后才能够获得数据。
   #+END_SRC
2. 浏览器页面设置了什么格式，那么页面传递的参数就是什么格式的
   #+BEGIN_SRC
     页面中：<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
            所以页面的格式是UTF-8的格式。
     因此：输入的字符，比如：张 --> UTF-8的格式
          UTF-8的格式 会把中文的一个字  转换为 3个字节的字节码
   #+END_SRC
   1. POST请求方式
      [[./Img/中文乱码1.png]]
      #+BEGIN_SRC java
        req.setCharacterEncoding("utf-8");
      #+END_SRC
      - /该方法能够获取的信息是HTTP请求中的请求正文的内容，而POST方式是把所有的参数都放入到了请求正文中/
      - /这句话一般放在代码的开头,该方法只能解析 请求正文的参数，也就是对地址栏的参数无效/
   2. GET请求方式
      [[./Img/中文乱码2.png]]
      /以下的这种方式是对get方法做的专门的处理,要求是：要使用此方法，必须先拿到参数信息/
      /此方法：无论get方法还是post方式都有效/
      1. 第一种方式
         #+BEGIN_SRC java
           username.getBytes("iso-8859-1");
           username = new String(bytes,utf-8);
         #+END_SRC
      2. 第二种方式
         #+BEGIN_SRC java
           String username = WebUtils.encoding(request.getParameter("username"),"utf-8");
         #+END_SRC
         写入工具类
         #+BEGIN_SRC java
           /*2. 对字符集进行正确的编码，防止乱码出现*/
           public static String encoding(String value,String character){
               try {
                   if (value != null) {
                       value = new String(value.getBytes("ISO-8859-1"),character);
                   }

               } catch (UnsupportedEncodingException e) {
                   e.printStackTrace();
               }
               return value;
           }
         #+END_SRC
*** 请求转发
[[./Img/request转发.png]]
该技术使用的一个API就是 HttpServletRequest去进行转发
- 特点：
  对于浏览器来说，我发送了一次请求，得到了一次响应
  服务器内部，对请求的资源可以进行多次的转发
- 案例demo

  #+BEGIN_SRC java
    package cn.tedu.demo;

    import javax.servlet.RequestDispatcher;
    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @WebServlet("/request01")
    public class Request01 extends HttpServlet {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            this.doPost(req, resp);
        }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            //模拟场景
            System.out.println("浏览器发送的请求，我暂时处理不了");
            System.out.println("需要交给另外一个servlet去处理");
            //1.创建一个调度器：作用是把request请求指向了另一个servlet
            RequestDispatcher requestDispatcher = req.getRequestDispatcher("/request02");
            //2. 把request对象 与 response对象 一并发送给request02
            /*主要作用，在转发过程中，分别保证请求对象、响应对象是相同的*/
            System.out.println("request01....start");
            requestDispatcher.forward(req,resp);
            System.out.println("request01....end");

        }
    }

  #+END_SRC

  #+BEGIN_SRC java
    package cn.tedu.demo;

    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @WebServlet("/request02")
    public class Request02 extends HttpServlet {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            this.doPost(req, resp);
        }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            System.out.println("我接受到了request01转发过来的请求，");
            System.out.println("我需要做出响应");
            //向浏览器发送一个响应
            //resp.getWriter().write("。。。$10000");
            System.out.println("request02....start");
            req.getRequestDispatcher("/request01").forward(req,resp);
            System.out.println("request02....end");
        }
    }

  #+END_SRC

  #+BEGIN_SRC java
    package cn.tedu.demo;

    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @WebServlet("/request03")
    public class Request03 extends HttpServlet {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            this.doPost(req, resp);
        }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            System.out.println("我接受到了request02转发过来的请求，");
            System.out.println("我需要做出响应");
            //向浏览器发送一个响应
            //resp.getWriter().write("。。。$10000");
            System.out.println("request03....start");
            req.getRequestDispatcher("/request04").forward(req,resp);
            System.out.println("request03....end");
        }
    }

  #+END_SRC

  #+BEGIN_SRC java
    package cn.tedu.demo;

    import javax.servlet.ServletException;
    import javax.servlet.annotation.WebServlet;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @WebServlet("/request04")
    public class Request04 extends HttpServlet {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            this.doPost(req, resp);
        }

        @Override
        protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            System.out.println("我接受到了request03转发过来的请求，");
            System.out.println("我需要做出响应");
            //向浏览器发送一个响应
            //resp.getWriter().write("。。。$10000");
            System.out.println("request04....start");
            /*最终这个请求转发到了 jsp中 */
            req.getRequestDispatcher("/regist.jsp").forward(req,resp);
            System.out.println("request04....end");
        }
    }

  #+END_SRC


* ServletConfig、ServletContext
** ServletConfig
[[./Img/ServletConfig.png]]
#+BEGIN_SRC xml
  <servlet>
    <servlet-name>SConfigDemo1</servlet-name>
    <servlet-class>cn.commandoptionesc.sconfig.SConfigDemo1</servlet-class>
    <!--在当前servlet配置中添加初始化配置信息-->
    <init-param>
      <param-name>username</param-name>
      <param-value>root</param-value>
    </init-param>
  </servlet>
  <servlet>
    <servlet-name>SConfigDemo2</servlet-name>
    <servlet-class>cn.commandoptionesc.sconfig.SConfigDemo2</servlet-class>
    <init-param>
      <param-name>key</param-name>
      <param-value>value1</param-value>
    </init-param>
  </servlet>
  <servlet-mapping>
    <servlet-name>SConfigDemo1</servlet-name>
    <url-pattern>/servlet/SConfigDemo1</url-pattern>
  </servlet-mapping>
  <servlet-mapping>
    <servlet-name>SConfigDemo2</servlet-name>
    <url-pattern>/servlet/SConfigDemo2</url-pattern>
  </servlet-mapping>
#+END_SRC
如果有任何参数在servlet启动的时候需要被加载，且这个参数可能仅在web应用每次重启的时候读取，那么这个参数就可以添加在servlet标签身上，作为一个初始化信息参数使用
1. ServletConfig代表当前servlet的初始化信息的对象
   可以通过这个对象来获取配置在web.xml中某一个servlet的初始化配置信息。
2. 获取ServletConfig对象的方法：
   #+BEGIN_SRC java
     this.getServletConfig();
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.sconfig;

     import javax.servlet.ServletConfig;
     import javax.servlet.ServletException;
     import java.io.IOException;
     //ServletConfig 可以获取servlet中的初始化配置信息

     public class SConfigDemo1 extends javax.servlet.http.HttpServlet {
         ServletConfig config = null;
         //1. 获取ServletConfig对象
         //获取方式：通过init方法
         @Override
         public void init(ServletConfig config) throws ServletException {
             //如果config对象需要被doGet方法使用
             //则应该将config对象提取成一个成员变量
             //将局部变量的config赋值到全局变量身上
             this.config = config;
             //super.init(config);
         }
         protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             //从当前servlet身上获取指定名称的初始化配置信息
             String username = config.getInitParameter("username");
             System.out.println("username:"+username);
         }
     }
   #+END_SRC
   通过init方法获取十分繁琐，所以通过当前servlet对象自带的成员变量config去操作
3. 功能一：获取初始化配置信息的方式：
   #+BEGIN_SRC java
     config.getInitParameter(String name);
     config.getInitParameterNames();
   #+END_SRC
   #+BEGIN_SRC java
     package cn.commandoptionesc.sconfig;

     import javax.servlet.ServletConfig;
     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.util.Enumeration;

     public class SConfigDemo2 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             //当前方法可以获取一个ServletConfig类型的对象
             ServletConfig config = this.getServletConfig();
             //获取当前SConfgDemo2的初始化配置信息
             String key = config.getInitParameter("key");
             System.out.println("key:"+key);
             Enumeration<String> names = config.getInitParameterNames();
             while(names.hasMoreElements()){
                 String name = names.nextElement();
                 System.out.println("name:"+name);
             }
         }
     }
   #+END_SRC
4. 功能二：用来获取ServletContext对象
   #+BEGIN_SRC java
     package cn.commandoptionesc.sconfig;

     import javax.servlet.ServletContext;
     import javax.servlet.ServletException;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;

     public class SConfigDemo3 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             ServletContext sc = this.getServletConfig().getServletContext();
         }
     }
   #+END_SRC
** ServletContext
[[./Img/day13-ServletContext.png]]
ServletContext就是一个代表web应用的对象。
1. 如果有多个servlet需要使用同一段初始化配置信息，那么这个信息就可以配置成一个web应用的配置信息，通过代表web应用的对象来获取。
2. 代表web应用的对象可以被web应用的所有servlet访问，也可以通过这个web应用的对象获取到web应用的配置信息
3. 获取web应用对象方式：
   1. this.getServletConfig().getServletContext();
      #+BEGIN_SRC java
        package cn.commandoptionesc.scontext;

        import javax.servlet.ServletContext;
        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        //1. 获取ServletContext对象
        public class SContextDemo1 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request, response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //获取ServletContext对象
                ServletContext sc = this.getServletConfig().getServletContext();
                //获取web应用的配置信息
                String user = sc.getInitParameter("user");
                System.out.println("user:"+user);
            }
        }

      #+END_SRC
   2. this.getServletContext();
      #+BEGIN_SRC java
        package cn.commandoptionesc.scontext;

        import javax.servlet.ServletContext;
        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public class SContextDemo2 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request, response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                ServletContext sc = this.getServletContext();
                String user = sc.getInitParameter("user");
                System.out.println("user:"+user);
            }
        }

      #+END_SRC
4. 功能一：获取web应用的配置信息操作
   #+BEGIN_SRC java
     context.getInitParameter(String name);//获取指定名称的参数
     context.getInitParameterNames();//获取全部web应用的配置信息的参数名
   #+END_SRC
5. 功能二：作为域对象来使用
   1. 操作域对象
      #+BEGIN_SRC
        getAttribute(String name,Object obj);
        getAttribute(String name);
        removeAttribute(String name);
        getAttrubuteNames();
      #+END_SRC
   2. 生命周期
      web应用加载代表web应用的对线创建，web应用销毁代表web应用的对象也会被销毁
   3. 作用范围
      当前web应用范围内
   4. 主要功能
      当前web应用范围内实现资源共享
      #+BEGIN_SRC java
        package cn.commandoptionesc.scontext;

        import javax.servlet.ServletContext;
        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        //ServletContext作为域对象使用
        public class SContextDemo3 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request, response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //获取ServletContext
                ServletContext sc = this.getServletContext();
                //作为域对象使用
                sc.setAttribute("name","兰芳");
            }
        }

      #+END_SRC
      #+BEGIN_SRC java
        package cn.commandoptionesc.scontext;

        import javax.servlet.ServletContext;
        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        //获取ServletContextDemo中的域属性
        public class SContextDemo4 extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request, response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                ServletContext sc = this.getServletContext();
                String name = (String)sc.getAttribute("name");
                System.out.println("name:"+name);
            }
        }

      #+END_SRC
6. 功能三：获取web资源
   1. 文件的路径的获取方式
      1. 相对路径 config.properties
         在问件加载的服务器启动目录去寻找指定文件名称的文件。
      2. 绝对路径 /config.properties
         会到项目启动的磁盘根目录下寻找指定名称的文件
      3. 书写全部路径名称
         确实可以找到指定路径的文件，但是这种书写方式过于死板，一旦对路径上任意一个级别的名称做出修改，则这个配置文件就会加载不到。不推荐使用。
      4. ServletContext
         #+BEGIN_SRC java
           context.getRealPath(String pathname)
         #+END_SRC
         获取当前web应用的全路径，在当前路径下寻找指定名称的文件。如果文件位于web应用目录内部，则仍需要在参数位置书写基于web应用目录下的子级目录名称和资源文件名称才可以找到文件。
         #+BEGIN_SRC java
           package cn.commandoptionesc.scontext;

           import javax.servlet.ServletContext;
           import javax.servlet.ServletException;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.File;
           import java.io.IOException;
           //路径问题
           public class SContextDemo5 extends HttpServlet {
               protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   doGet(request, response);
               }
               protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   //相对路径
                   //String path = "config.properties";
                   //绝对路径(不推荐使用)
                   //String path = "D:\\......";
                   ServletContext sc = this.getServletContext();
                   String path = sc.getRealPath("WEB-INF/web.xml");
                   File file = new File(path);
                   System.out.println(file.getAbsolutePath());
               }
           }

         #+END_SRC
      5. 类加载器获取路径
         通过当前类的类加载器可以获取当前web应用src目录下的资源文件。
         getClassLoader().getResource("文件名称").getPath();
         #+BEGIN_SRC java
           package cn.commandoptionesc.scontext;

           import javax.servlet.ServletException;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.File;
           import java.io.IOException;

           public class SContextDemo6 extends HttpServlet {
               protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   doGet(request, response);
               }
               protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   String path = SContextDemo6.class.getClassLoader().getResource("config.properties").getPath();
                   File file = new File(path);
                   System.out.println(file.getAbsolutePath());
               }
           }

         #+END_SRC
         + 在使用web工程并发布的时候，这种获取路径的方式会自动调整到classes目录中去获取指定名称的文件。
* AJAX
[[./Img/day13-AJAX.png]]
1. AJAX是什么？
   asynchronous js and xml 异步的js和xml；通过ajax给服务器发送请求，并让服务器根据请求作出响应实现ajax，只是这个过程是一个异步请求的过程，作出的操作作为局部刷新。

   [[./Img/63.png]]
2. 异步交互和同步交互
   - 异步交互：
     - 如果一个ajax实现的是同步交互，发出请求之后，浏览器会等待响应结束之后才允许继续操作。一次请求必须要等待一次响应结束，在这期间不允许进行任何操作。
     - 刷新范围：整体刷新。必须等待页面中的请求加载完毕才能继续操作。
   - 异步交互：
     - 如果一个ajax实现的是异步交互，发出请求之后，浏览器仍然可以继续操作。多次请求直接互不干扰，可以连续多次发送请求，服务器会针对各个请求作出响应。
     - 刷新范围：局部刷新。不必等待页面完全加载完成即可以继续操作页面。
3. 使用情景：
   异步交互：
   1. 搜索框中书写内容是异步交互
   2. 点击搜索按钮是同步交互
4. 异步交互的特点：
   1. 优点：用户体验靓号，如果用户合理使用ajax，会降低服务器的访问压力。
   2. 缺点：会无端产生很多无效的请求，增加服务器访问的压力。
5. javascript实现ajax四步
   1. 第一步，获取XMLHttpRequest对象
      #+BEGIN_SRC java
        var xmlHttp = ajaxFunction();
        function ajaxFunction(){
            var xmlHttp;
            try{
                //现代浏览器(IE7+、Firefox、Chrome、Safari和Opera)都有内建的XMLHttpRequest对象
                xmlHttp = new XMLHttpRequest();
            }catch(e){
                try{
                    //IE6.0
                    xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
                }catch(e){
                    try{
                        //IE5.0及更早版本
                        xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
                    }catch(e){
                        alert("...");
                        throw e;
                    }
                }
            }
            return xmlHttp;
        }
      #+END_SRC
   2. 第二步，打开与服务器的连接
      #+BEGIN_SRC
        xmlHttp.open(method,url,async);
            > method: 请求方式，可以是GET或POST
            > url: 所要访问的服务器中资源的路径 如：/Day10/servlet/AServlet
            > async: 是否为异步传输，true表示为异步传输，一般都是true false表示同步传输
      #+END_SRC
   3. 第三步，发送请求
      #+BEGIN_SRC
        xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded");//通知服务器发送的数据是请求参数
        xmlHttp.send("xxxx");//注意，如果不给参数可能会造成部分浏览器无法发送请求
          > 参数：
              如果是GET请求，可以是null，因为GET提交参数会拼接在url后面
              如果是POST请求，传入的就是请求参数
                "username = 张飞&psw=123"
      #+END_SRC
   4. 第四部，注册监听
      1. 在XMLHttpRequest对象的一个时间上注册监听器：
         onreadystatechange
      2. 一共有五个状态：(XMLHttp.readyState)
         - 0状态：表示刚创建XMLHttpRequest对象，还未调用open()方法
         - 1状态：表示刚调用open()方法，但是还没有调用send()方法发送请求
         - 2状态：调用完了send()方法了，请求已经开始
         - 3状态：服务器已经开始响应，但是不代表响应结束
         - 4状态：服务器响应结束（通常我们只关心这个状态）
      3. 获取xmlHttp对象的状态：
         #+BEGIN_SRC java
           var state = xmlHttp.readyState;//可能得到0，1，2，3，4
         #+END_SRC
      4. 获取服务器响应的状态码
         #+BEGIN_SRC java
           var status = xmlHttp.status;
         #+END_SRC
      5. 获取服务器响应的内容
         #+BEGIN_SRC java
           var data = xmlHttp.responseText;//得到服务器响应的文本格式的数据
           xmlHttp.onreadystatechange = function(){
               //服务器已经处理完请求之后
               if(xmlHttp.readyState == 4){
                   if(xmlHttp.status == 200){
                       //获取响应数据
                       var result = xmlHttp.responseText;
                       result = xmlHttp.responseXML;
                   }
               }
           }
         #+END_SRC
6. jQuery实现AJAX
   1. load方法
      1. $(selector).load(url,data,callback);
         #+BEGIN_SRC
           selector -- 选择器，将从服务器获取到的数据加载到指定的元素中
           url -- 发送请求的URL地址
           data -- 可选，向服务器发送的数据key/value数据 如：{"username":"张飞","psw":"123"}
           callback -- 可选，load方法完成后所执行的函数
         #+END_SRC
         实例：
         #+BEGIN_SRC js
           $("#username_msg").load("<%=request.getContextPath()%>/AjaxCheckUsernameServlet",{"username":username});
         #+END_SRC
      2. $.get方法
         #+BEGIN_SRC
           %.get(url,[data],[callback]);
           url -- 发送请求的URL地址
           data -- 可选，向服务器发送的数据
           callback -- 可选，请求成功后所执行的函数
         #+END_SRC
         实例：
         #+BEGIN_SRC js
           $.get("<%=request.getContextPath()%>/AjaxCheckUsernameServlet",{"username":username},function(result){
             $("#username_msg").html("<font style='color:red>"+result+"</font>");
           });
         #+END_SRC
   2. $ajax方法
      #+BEGIN_SRC
        $.ajax(url,[data],[async],[callback]);
        url -- 发送请求的URL地址
        data -- 可选，发送至服务器的key/value数据
        async -- 可选，默认为true，表示异步交互
        type -- 可选，请求方式，默认为"GET"
        success -- 可选，请求成功后执行的函数，函数参数
        result --- 服务器返回的数据
      #+END_SRC
      实例：
      #+BEGIN_SRC js
        $.ajax({
          "url":"<%=request.getContextPath()%>/AjaxCheckUsernameServlet",
          "data":{"username":username},
          "async":"POST",
          "success":function(result){
            $("#username_msg").html("<font style='color:red'>"+result+"</font>")
          },
          error:function(){

          }
        });
      #+END_SRC
* 修改EasyMall
1. 添加ajax用户名是否存在校验
   1. 需求：
      在用户鼠标离开用户输入框的时候发生ajax校验，校验的内容是访问数据库，查看数据库中是否包含用户名所输入的用户名称，如果存在就在span中提示用户名已存在，如果不存在提示用户名可以使用。
   2. 代码实现：
      1. 修改regist.jsp页面：在鼠标离开焦点事件中添加ajax校验
         #+BEGIN_SRC js
           //鼠标离开焦点事件
           //文档就绪时间
           $(function(){
             //鼠标离开焦点事件
             $("input[name='username']").blur(function() {
               //非空校验操作，此处不需要重新写，调用就可以
               //此处没有用户动态的传入的参数，只能手写参数名
               formObj.checkNull("username", "用户名称不能为空");
               //获取用户名框中的数据，作为ajax请求的参数传递。
               var username = $("input[name='username']").val();
               //如果用户名为空则不应该发生ajax校验
               if($.trim(username)==""){
                 return ;
               }
               //ajax的实现
               //鼠标离开用户名输入框之后去数据库完成查重操作
               $("#username_msg").load("<%=request.getContextPath()%>/AjaxCheckUsernameServlet",{"username":username});
           });
         #+END_SRC
         #+BEGIN_SRC html
           <tr>
             <td class="tds">用户名：</td>
             <td>
               <input type="text" name="username" value="<%=request.getParameter("username")==null?"":request.getParameter("username")%>"/>
               <span id="username_msg"></span>
             </td>
           </tr>
         #+END_SRC
      2. 创建AjaxCheckUsernameServlet：添加如下代码
         #+BEGIN_SRC java
           package com.easymall.servlet;

           import com.easymall.utils.JDBCUtils;
           import javax.servlet.ServletException;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.IOException;
           import java.sql.Connection;
           import java.sql.PreparedStatement;
           import java.sql.ResultSet;

           //ajax用户名查重检验
           public class AjaxCheckUsernameServlet extends HttpServlet {
               protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   doGet(request, response);
               }
               protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   //乱码处理
                   request.setCharacterEncoding("utf-8");
                   response.setContentType("text/html;charset=utf-8");
                   //获取ajax中的请求参数
                   String username = request.getParameter("username");
                   //连接数据库查重
                   Connection conn = null;
                   PreparedStatement ps = null;
                   ResultSet rs = null;
                   try {
                       conn = JDBCUtils.getConnection();
                       ps = conn.prepareStatement("select * from user where username = ?");
                       ps.setString(1,username);
                       rs = ps.executeQuery();
                       //如果rs.next()为true则标签用户名已经存在
                       if (rs.next()) {
                           //向response缓冲区写入数据，待服务器组成一定结果结构之后在打给浏览器
                           response.getWriter().write("用户名已存在");
                       }else{
                           //返回一个用户名不存在提示到页面中
                           response.getWriter().write("恭喜，用户名可以使用");
                       }
                   } catch (Exception e) {
                       e.printStackTrace();
                   }finally{
                       JDBCUtils.close(conn,ps,rs);
                   }
               }
           }

         #+END_SRC
2. 验证码实现
   用户输入的数据可以由一段代码自动填写实现，所以添加上一个验证码访问自动注册用户，保证垃圾数据不进入数据库当中。
   - 代码实现：
      1. 修改regist.jsp页面：
         图片在加载资源的时候是通过src访问的，所以src可以指向一个动态资源，这个动态资源生成一张图片。
         #+BEGIN_SRC js
           //修改验证码图片
           $("#img").click(function(){
             $(this).attr("src","<%=request.getContextPath()%>/ValidateServlet?time="+new Date().getTime());
           });
         #+END_SRC
         #+BEGIN_SRC html
           <tr>
             <td class="tds">验证码：</td>
             <td>
               <input type="text" name="valistr" />
               <img id="img" src="<%=request.getContextPath()%>/ValidateServlet" width="" height="" alt="" />
               <span></span>>
             </td>
           </tr>
         #+END_SRC
      2. 创建ValidateServlet
         #+BEGIN_SRC java
           package com.easymall.servlet;

           import com.easymall.utils.VerifyCode;

           import javax.servlet.ServletException;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.IOException;
           //生成验证码
           public class ValidateServlet extends HttpServlet {
               protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   doGet(request, response);
               }
               protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   //调用工具类产生一个验证码的图片
                   VerifyCode vc = new VerifyCode();
                   vc.drawImage(response.getOutputStream());
                   //获取验证码的纯文本内容
                   String code = vc.getCode();
                   System.out.println(code);
               }
           }

         #+END_SRC
      3. 动态生成图片工具类
         #+BEGIN_SRC java
           package com.easymall.utils;

           import java.awt.Color;
           import java.awt.Font;
           import java.awt.Graphics2D;
           import java.awt.image.BufferedImage;
           import java.io.OutputStream;
           import java.util.Random;
           import javax.imageio.ImageIO;
           /**
            ,* 动态生成图片
            ,*/
           public class VerifyCode {
               // {"宋体", "华文楷体", "黑体", "华文新魏", "华文隶书", "微软雅黑", "楷体_GB2312"}
               private static String[] fontNames = { "宋体", "华文楷体", "黑体", "微软雅黑",  "楷体_GB2312" };
               // 可选字符
               //"23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ";
               private static String codes = "23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ";
               // 背景色
               private Color bgColor = new Color(255, 255, 255);
               // 基数(一个文字所占的空间大小)
               private int base = 30;
               // 图像宽度
               private int width = base * 4;
               // 图像高度
               private int height = base;
               // 文字个数
               private int len = 4;
               // 设置字体大小
               private int fontSize = 22;
               // 验证码上的文本
               private String text;

               private BufferedImage img = null;
               private Graphics2D g2 = null;

               /**
                ,* 生成验证码图片
                ,*/
               public void drawImage(OutputStream outputStream) {
                   // 1.创建图片缓冲区对象, 并设置宽高和图像类型
                   img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                   // 2.得到绘制环境
                   g2 = (Graphics2D) img.getGraphics();
                   // 3.开始画图
                   // 设置背景色
                   g2.setColor(bgColor);
                   g2.fillRect(0, 0, width, height);

                   StringBuffer sb = new StringBuffer();// 用来装载验证码上的文本

                   for (int i = 0; i < len; i++) {
                       // 设置画笔颜色 -- 随机
                       // g2.setColor(new Color(255, 0, 0));
                       g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),getRandom(0, 150)));

                       // 设置字体
                       g2.setFont(new Font(fontNames[getRandom(0, fontNames.length)], Font.BOLD, fontSize));

                       // 旋转文字(-45~+45)
                       int theta = getRandom(-45, 45);
                       g2.rotate(theta * Math.PI / 180, 7 + i * base, height - 8);

                       // 写字
                       String code = codes.charAt(getRandom(0, codes.length())) + "";
                       g2.drawString(code, 7 + i * base, height - 8);
                       sb.append(code);
                       g2.rotate(-theta * Math.PI / 180, 7 + i * base, height - 8);
                   }

                   this.text = sb.toString();

                   // 画干扰线
                   for (int i = 0; i < len + 2; i++) {
                       // 设置画笔颜色 -- 随机
                       // g2.setColor(new Color(255, 0, 0));
                       g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),
                                             getRandom(0, 150)));
                       g2.drawLine(getRandom(0, 120), getRandom(0, 30), getRandom(0, 120),
                                   getRandom(0, 30));
                   }
                   // 4.保存图片到指定的输出流
                   try {
                       ImageIO.write(this.img, "JPEG", outputStream);
                   } catch (Exception e) {
                       e.printStackTrace();
                       throw new RuntimeException(e);
                   }finally{
                       // 5.释放资源
                       g2.dispose();
                   }
               }

               /**
                ,* 获取验证码字符串
                ,* @return
                ,*/
               public String getCode() {
                   return this.text;
               }

               /*
                ,* 生成随机数的方法
                ,*/
               private static int getRandom(int start, int end) {
                   Random random = new Random();
                   return random.nextInt(end - start) + start;
               }
               /*
                 public static void main(String[] args) throws Exception {
                 VerifyCode vc = new VerifyCode();
                 vc.drawImage(new FileOutputStream("d:/vc.jpg"));
                 System.out.println("执行成功~!");
                 }
               ,*/
           }

         #+END_SRC
* 会话技术 -- cookie
[[./Img/cookie.png]]
[[./SourceCode/login.jsp]]
[[./SourceCode/loginServlet.java]]
1. 会话是什么？
   为了完成某一个功能，浏览器和服务器建立连接之后，进行一次或多次请求和响应操作，这些请求和响应构成了浏览器和服务器之间的一次会话操作。
2. 会话的作用：
   会话主要是解决在浏览器请求中数据的共享问题而出现的奇数。

   http是一个无状态协议。 -- 请求与请求之间是没有关联的。
                        -- 请求与请求之间是没有关联的。
                        -- 利用会话技术可以解决请求之间没有关联的问题。
3. 会话技术 -- cookie
   [[./Img/64.png]]
   1. Cookie实现原理：
      在第一次请求过后，由服务器发出一个携带set-Cookie响应头的响应，到达浏览器之后，会将其中的数据在浏览器端保存一份，以备下次发送请求时自动携带。在下一次发送请求时，请求中自动包含一个请求头cookie其中包含的值是set-cookie在浏览器端保存的值。
   2. 浏览器请求服务器，服务器响应的结果数据会保留在浏览器端一份，这个数据可以通过cookie技术来使用。所以cookie技术是一门浏览器端的技术。
4. 用户上次访问页面的时间
   在set-cookie中保存的时间是用户本次的访问时间，这个访问时间会在下一次请求中包含，并且通过请求头cookie获取，展示在浏览器端。
   #+BEGIN_SRC java
     package cn.commandoptionesc.cookie;

     import java.io.IOException;
     import java.util.Date;

     //在浏览器中回显用户上次访问页面的时间
     public class CookieDemo1 extends javax.servlet.http.HttpServlet {
         protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {
             response.setContentType("text/html;charset=utf-8");
             //产生一个时间值
             Date date = new Date();
             String time = date.toLocaleString();
             //实现cookie
             //1. 设置setcookie响应头
             response.setHeader("set-cookie",time);
             //2. 获取一个请求头cookie
             String cookie = request.getHeader("cookie");
             //用户是第一次访问当前页面，则在浏览器中没有cookie请求头，所以无法获取到上次访问的时间
             if(cookie == null){
                 response.getWriter().write("您是初次访问这个页面");
             }else{
                 //如果不是初次访问，则在cookie请求中会读取浏览器中保留的set-ciikie响应头中上次访问到时间
                 response.getWriter().write("您上次访问本页面的时间是："+cookie);
             }
         }
     }
   #+END_SRC
5. Cookie类型
   Sun公司提供的Cookie类，便于开发者创建、使用cookie。

   1. 创建cookie
      #+BEGIN_SRC java
        Cookie cookie = new Cookie(String name,String value);
      #+END_SRC
   2. 发送cookie到浏览器
      #+BEGIN_SRC java
        response.addCookie(cookie);
      #+END_SRC
   3. 设置最大值生命时长
      #+BEGIN_SRC java
        cookie.setMaxAge();//单位为秒
      #+END_SRC
      如果不设置cookie的最大生命时长，则cookie是一个会话级别的cookie，在浏览器关闭之后就会销毁，如果定义的了cookie的生命时长，则cookie会以文件的形式保存在本地磁盘一份(浏览器的临时文件目录)，在到达执行生命时长之后cookie会自动失效，销毁。
   4. 设置有效路径
      #+BEGIN_SRC java
        cookie.setPath();
      #+END_SRC
      所谓有效路径就是cookie可以被问的路径级别。如果不指定cookie的有效路径级别，则只在当前资源的映射路径下有效。如果指定cookie的有效路径，则在指定路径及其级别下可以获取到当前cookie。
      - 推荐在设置路径时加上一个/ 如果web应用的虚拟路径为缺省路径，则此时将会以/作为有效路径，可以避免缺省路径带来的不必要的错误。
   5. 获取cookie
      #+BEGIN_SRC java
        Cookie[] cs = request.getCookies();
      #+END_SRC
      结果是一个cookie数据，将数组中的数据遍历使用。

   6. 删除cookie
      cookie中没有删除cookie的方法。
      1. 创建一个名称要和删除的cookie名称相同的cookie，并且要设置这个cookie的path与要删除的相同，然后将新发送的cookie生命时长设置为0，这样就可以删除一个cookie。
      2. 原因：
         浏览器在判断两个cookie是否相同时，判断三个内容：
         - Name
         - Path
         - domain
         默认情况下每一个cookie的domain都相同的，所以只需要发送一个name和path与要删除的cookie相同的cookie到浏览器就可以完成删除操作了。
         #+BEGIN_SRC java
           package cn.commandoptionesc.cookie;

           import javax.servlet.ServletException;
           import javax.servlet.http.Cookie;
           import javax.servlet.http.HttpServlet;
           import javax.servlet.http.HttpServletRequest;
           import javax.servlet.http.HttpServletResponse;
           import java.io.IOException;
           //删除cookie
           public class CookieDemo4 extends HttpServlet {
               protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   doGet(request, response);
               }
               protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                   //创建一个name和path与要删除的完全一致的coolie，并且设置生命时长为0
                   //创建cookie
                   Cookie cookie = new Cookie("time","");
                   //path一致
                   cookie.setPath(request.getContextPath()+"/");
                   //设置生命时长为0
                   cookie.setMaxAge(0);
                   //将cookie发送到浏览器
                   response.addCookie(cookie);
               }
           }

         #+END_SRC
   7. cookieAPI
      cookie.getName() --- 获取cookie的名称

      cookie.getValue() --- 获取cookie中包含的值
   8. cookie小细节
      一个cookie标识一种信息。同一个cookie信息可以在多个浏览器中保存。一个浏览器中可以保存不同网站的cookie。
6. Cookie类型使用cookie：
   #+BEGIN_SRC java
     package cn.commandoptionesc.cookie;

     import javax.servlet.ServletException;
     import javax.servlet.http.Cookie;
     import javax.servlet.http.HttpServlet;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     import java.net.URLDecoder;
     import java.net.URLEncoder;
     import java.text.SimpleDateFormat;
     import java.util.Date;
     //cookie生命时长、有效路径设置
     public class CookieDemo3 extends HttpServlet {
         protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             doGet(request, response);
         }
         protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
             response.setContentType("text/html;charset=utf-8");
             Date date = new Date();
             SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
             String time = format.format(date);
             //创建cookie
             Cookie cookie = new Cookie("time", URLEncoder.encode(time,"UTF-8"));
             //修改cookie生命时长、有效路径
             //设置cookie生命时长（以秒值为单位
             cookie.setMaxAge(60*60*24);
             //设置路径
             //修改为web应用的虚拟路径
             //如果是缺省web应用，则在request.getContextPath中获取到一个空的返回值
             //这个值不能作为setPath的值，需要在其后加上一个"/"，来表明是当前web应用的路径
             cookie.setPath(request.getContextPath()+"/");
             //发送cookie
             response.addCookie(cookie);
             //获取cookie
             Cookie[] cs = request.getCookies();
             Cookie timeC = null;
             if(cs != null){
                 for(Cookie c:cs){
                     if("time".equals(c.getName())){
                         timeC = c;
                     }
                 }
             }
             if(timeC != null){
                 //timeC.getValue()获取cookie中的value时间值
                 //通过URLDecoder.decode(String s,String enc)进行解码
                 response.getWriter().write("您上次访问页面的时间为："+ URLDecoder.decode(timeC.getValue(),"UTF-8"));
             }else{
                 response.getWriter().write("您是初次访问本页面");
             }
         }
     }
   #+END_SRC
7. 修改EasyMall：添加登陆功能-记住用户名
   1. 添加login.jsp页面
      1. 在课前资料中有login页面的全部资源，粘贴到webRoot目录下。
      2. 修改login.html为login.jsp页面
      3. 删除login.html
   2. 添加LoginServlet：
      代码如下：
      #+BEGIN_SRC java
        package com.easymall.servlet;

        import com.easymall.utils.JDBCUtils;

        import javax.servlet.ServletException;
        import javax.servlet.http.Cookie;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        import java.sql.Connection;
        import java.sql.PreparedStatement;
        import java.sql.ResultSet;
        import java.sql.SQLException;

        //登陆功能
        public class LoginServlet extends HttpServlet {
            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                doGet(request,response);
            }
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                //1. 乱码处理
                request.setCharacterEncoding("utf-8");
                response.setContentType("text/html;charset=UTF-8");
                //2. 获取用户信息
                String username = request.getParameter("username");
                String password = request.getParameter("password");
                String remname = request.getParameter("remname");
                //如果remname值为true则要求记住用户名
                if("true".equals(remname)){
                    //为true要求保存用户名
                    Cookie cookie = new Cookie("remname",username);
                    cookie.setMaxAge(60*60*24*30);
                    cookie.setPath(request.getContextPath()+"/");
                    response.addCookie(cookie);
                }else{
                    //如果不为true则应该销毁cookie
                    Cookie cookie = new Cookie("remname","");
                    cookie.setMaxAge(0);
                    cookie.setPath(request.getContextPath()+"/");
                    response.addCookie(cookie);
                }
                //3. 访问数据库，比对用户信息
                Connection conn = null;
                PreparedStatement ps = null;
                ResultSet rs = null;
                try {
                    conn = JDBCUtils.getConnection();
                    ps = conn.prepareStatement("select * from user where username = ? and password = ?");
                    ps.setString(1,username);
                    ps.setString(2,password);
                    rs = ps.executeQuery();
                    if(rs.next()){
                        //登陆操作
                        //TODO:session
                        //4. 回到首页
                        response.sendRedirect("http://www.easymall.com");
                    }else{
                        //如果不一致则在页面中提示用户名或密码不正确
                        request.setAttribute("msg","用户名或者密码不正确");
                        request.getRequestDispatcher("/login.jsp").forward(request,response);
                        return;
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }finally{
                    JDBCUtils.close(conn,ps,rs);
                }
            }
        }

      #+END_SRC
   3. 修改login.jsp页面
      1. 修改form标签
         #+BEGIN_SRC html
           <form action="<%=request.getContextPath()%>/LoginServlet" method="POST">
         #+END_SRC
      2. 添加错误信息回显
         #+BEGIN_SRC html
           <tr>
             <td class="tds" colspan=2 style="color:red;text-align:center">
               <%=request.getAttribute("msg")==null?"":request.getAttribute("msg")%>
           </td>
           </tr>
         #+END_SRC
      3. table中添加
         #+BEGIN_SRC
           <%
               Cookie remnameC = null;
               Cookie[] cs = request.getCookies();
               if(cd != null){
                   for(Cookie c:cs){
                       if("remname".equals(c.getName())){
                           remnameC = c;
                       }
                   }
               }
               String username = "";
               if(remnameC != null){
               username = URLDecoder.decode(remnameC.getValue(),"utf-8");
               }
           %>
         #+END_SRC
      4. 在input[name='username']标签中添加
         #+BEGIN_SRC html
           <input type="text" name="username" value="<%=username%>"/>
         #+END_SRC
   4. 回显选中记住用户名的对勾
      在cookie中如果有用户的登陆名称，则代表用户要求记住用户名，这时应该将记住用户名选框的对象勾选上。
      #+BEGIN_SRC html
        <input type="checkbox" name="remname" value="true" <%=username==""?"":"checked='checked'"%>/>
        记住用户名
      #+END_SRC
* 会话技术 -- session
[[./Img/day14.png]]
[[./SourceCode/ValilmageServlet.java]]
[[./SourceCode/VerifyCode.java]]
[[./Img/65.png]]
  1. 在浏览器端存储数据的弊端:
     如果一个数据非常重要这个数据存储在浏览器端可以被任何一个用户查看到，无法保证当前数据的安全性，所以可以将数据由浏览器保存转向让服务器保存数据。
  2. session实现原理：
     1. 在浏览器访问服务器的时候，会在服务器内部创建一个与当前浏览器相关的session对象，在本次会话中如果用户多次请求服务器，都是操作的同一个session对象。不同浏览器会拥有各自的session对象。
     2. session的实现原理是通过一个JSESSIONID的cookie实现的。
  3. session的使用
     1. request.getSession(); //如果服务器中已有浏览器对应的session，则这个方法会直接将session对象获取到拿来使用，如果服务器中没有对应的session，则这个方法会创建一个新的session对象使用。
     2. request.getSession(true);//如果服务器中已有浏览器对应的session，则这个方法会直接将session对象获取到拿来使用，如果服务器中没有对应的session，则这个方法会创建一个新的session对象使用。
     3. request.getSession(false);//如果服务器中没有浏览器对应的session，则会返回一个null的结果，如果有则拿过来使用。
  4. session功能一:域对象
     在一个对象身上有一个可以被看见的范围，在这个范围内利用对象身上的map实现资源的共享，这样的对象就称之为域对象。
     1. 操作方法:
        #+BEGIN_SRC java
          setAttribute(String name,Object obj);
          getAttribute(String name);
          removeAttribute(String name);
          getAttributeNames();
        #+END_SRC
     2. 生命周期
        request.getSession()方法调用的时候session对象创建。
        - session对象的销毁:
          1. 超时死亡:session在默认情况下回会在服务器中存储30分钟，超过30会被 服务器认为是一个无效session而销毁。超时时间可以在web.xml中配置一 个<session-config>标签来指定。
          2. 自杀:当调用session.invalidate();会主动将session对象释放。
          3. 意外身亡:在非常关闭状态下，session会直接销毁。如果服务器正常关 闭，则session对象会序列化到磁盘上成为一个文件，这个过程称之为钝化。在服务器下次启动的时候再将这个文件，读取到服务器当中，这个过程称之为活化。
     3. 作用范围
        当前会话范围内。
     4. 主要功能
        当前会话范围内实现资源共享。
  5. session案例：购物车
     1. 需求:创建一个购物车的Servlet，和一个结账的Servlet，使两者可以实现购物车、购买商品结账的需求.
     2. 实现内容:在本次会话范围内实现用户购买商品数据的共享。
        代码实现:
        #+BEGIN_SRC html
          <%@ page pageEncoding="UTF-8" language="java" import="java.util.*" session="false"%>
          <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
          <html>
            <head>
              <title>$Title$</title>
            </head>
            <body>
              <a href="<%=request.getContextPath()%>/servlet/BuyServlet?prod=皮鞋">皮鞋</a>
              <a href="<%=request.getContextPath()%>/servlet/BuyServlet?prod=牙刷">牙刷</a>
              <a href="<%=request.getContextPath()%>/servlet/BuyServlet?prod=毛巾">毛巾</a>
              <a href="<%=request.getContextPath()%>/servlet/BuyServlet?prod=篮球">篮球</a>
              <a href="<%=request.getContextPath()%>/servlet/PayServlet">付款</a>
            </body>
          </html>
        #+END_SRC
        #+BEGIN_SRC java
          package cn.commandoptionesc.session;

          import javax.servlet.ServletException;
          import javax.servlet.http.*;
          import java.io.IOException;
          import java.nio.charset.StandardCharsets;

          //购物车servlet
          //商品添加的操作
          public class BuyServlet extends HttpServlet {
              protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  doGet(request, response);
              }
              protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  response.setContentType("text/html;charset=utf-8");
                  String prod = request.getParameter("prod");
                  //中文系统乱码
                  //prod = new String(prod.getBytes("iso8859-1"), "utf-8");
                  prod = new String(prod.getBytes());
                  //向session域中添加数据 --- 在当前会话范围内实现商品数据的共享
                  //创建session
                  HttpSession session = request.getSession();
                  session.setAttribute("prod",prod);
                  //创建一个JSESSION的cookie，将session保存在本地，使浏览器多次关闭打开都能获取到同一个session
                  Cookie cookie = new Cookie("JSESSIONID",session.getId());
                  cookie.setMaxAge(60*60*24);
                  cookie.setPath(request.getContextPath()+"/");
                  response.addCookie(cookie);

                  //向页面显示商品添加信息
                  response.getWriter().write("已经将商品「"+prod+"」加入购物车");
              }
          }
        #+END_SRC
        #+BEGIN_SRC java
          package cn.commandoptionesc.session;

          import javax.servlet.ServletException;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import javax.servlet.http.HttpSession;
          import java.io.IOException;

          public class PayServlet extends HttpServlet {
              protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  doGet(request, response);
              }
              protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  response.setContentType("text/html;charset=utf-8");
                  //获取session对象
                  HttpSession session = request.getSession();
                  //获取session域中的属性
                  String prod = (String)session.getAttribute("prod");
                  if(prod == null){
                      response.getWriter().write("您还未选择任何商品");
                  }else{
                      //向浏览器提示付款信息
                      response.getWriter().write("已付款商品「"+prod+"」,价格￥10000000");
                  }
              }
          }
        #+END_SRC
  6. EasyMall页面功能
     1. 登陆功能的实现：
        1. 修改login.jsp页面：在<div id="content">中添加如下代码
           #+BEGIN_SRC html
             <%@ page language="java" import="java.util.*"   pageEncoding="UTF-8"%>
             <%@ page import="java.net.URLDecoder" %>
             <!DOCTYPE HTML>
             <html>
               <head>
                 <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
                 <link rel="stylesheet" href="<%=request.getContextPath()%>/css/login.css"/>
                 <title>EasyMall欢迎您登陆</title>
               </head>
               <body>
                 <h1>欢迎登陆EasyMall</h1>
                 <form action="<%=request.getContextPath()%>/LoginServlet" method="POST">
                   <table>
                     <%
                       Cookie remnameC = null;
                       Cookie[] cs = request.getCookies();
                       if(cs != null){
                       for(Cookie c:cs){
                       if("remname".equals(c.getName())){
                       remnameC = c;
                       }
                       }
                       }
                       String username = "";
                       if(remnameC != null){
                       username = URLDecoder.decode(remnameC.getValue(),"utf-8");
                       }
                       %>
                     <tr>
                       <td class="tds" colspan=2 style="color:red;text-align:center">
                         <%=request.getAttribute("msg")==null?"":request.getAttribute("msg")%>
                       </td>
                     </tr>
                     <tr>
                       <td class="tdx">用户名：</td>
                       <td><input type="text" name="username" value="<%=username%>"/></td>
                     </tr>
                     <tr>
                       <td class="tdx">密&nbsp;&nbsp; 码：</td>
                       <td><input type="password" name="password"/></td>
                     </tr>
                     <tr>
                       <td colspan="2">
                         <input type="checkbox" name="remname" value="true" <%= username==""?"":"checked='checked'"%>/>记住用户名
                         <input type="checkbox" name="autologin" value="true"/>30天内自动登陆
                       </td>
                     </tr>
                     <tr>
                       <td colspan="2" style="text-align:center">
                         <input type="submit" value="登 陆"/>
                       </td>
                     </tr>
                   </table>
                 </form>
               </body>
             </html>
           #+END_SRC
        2. 修改LoginServlet
           #+BEGIN_SRC java
             package com.easymall.servlet;

             import com.easymall.utils.JDBCUtils;
             import javax.servlet.ServletException;
             import javax.servlet.http.*;
             import java.io.IOException;
             import java.net.URLEncoder;
             import java.sql.Connection;
             import java.sql.PreparedStatement;
             import java.sql.ResultSet;
             import java.sql.SQLException;
             //登陆功能
             public class LoginServlet extends HttpServlet {
                 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                     doGet(request,response);
                 }
                 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                     //1. 乱码处理
                     request.setCharacterEncoding("utf-8");
                     response.setContentType("text/html;charset=UTF-8");
                     //2. 获取用户信息
                     String username = request.getParameter("username");
                     String password = request.getParameter("password");
                     String remname = request.getParameter("remname");
                     //如果remname值为true则要求记住用户名
                     if("true".equals(remname)){
                         //为true要求保存用户名
                         Cookie cookie = new Cookie("remname", URLEncoder.encode(username,"utf-8"));
                         cookie.setMaxAge(60*60*24*30);
                         cookie.setPath(request.getContextPath()+"/");
                         response.addCookie(cookie);
                     }else{
                         //如果不为true则应该销毁cookie
                         Cookie cookie = new Cookie("remname","");
                         cookie.setMaxAge(0);
                         cookie.setPath(request.getContextPath()+"/");
                         response.addCookie(cookie);
                     }
                     //3. 访问数据库，比对用户信息
                     Connection conn = null;
                     PreparedStatement ps = null;
                     ResultSet rs = null;
                     try {
                         conn = JDBCUtils.getConnection();
                         ps = conn.prepareStatement("select * from user where username = ? and password = ?");
                         ps.setString(1,username);
                         ps.setString(2,password);
                         rs = ps.executeQuery();
                         if(rs.next()){
                             //登陆操作
                             //如果一致则保存用户登录信息
                             //将用户的登陆信息登陆到session当中
                             HttpSession session = request.getSession();
                             session.setAttribute("username",username);
                             //4. 回到首页
                             response.sendRedirect("http://www.easymall.com");
                         }else{
                             //如果不一致则在页面中提示用户名或密码不正确
                             request.setAttribute("msg","用户名或者密码不正确");
                             request.getRequestDispatcher("/login.jsp").forward(request,response);
                             return;
                         }
                     } catch (SQLException e) {
                         e.printStackTrace();
                     }finally{
                         JDBCUtils.close(conn,ps,rs);
                     }
                 }
             }

           #+END_SRC
     2. 注销功能能实现：
        修改_head.jsp页面
        #+BEGIN_SRC html
          <div id="common_head">
            <div id="line1">
              <div id="content">
                <!--如果有session且session中包含username域属性则证明用户已经登录-->
                <!--可以从session域中取出用户名-->
                <%
                  if(request.getSession(false)!=null && request.getSession().getAttribute("username") != null){
                  %>
                <a href="#">欢迎&nbsp;<%=request.getSession().getAttribute("username")%>&nbsp;回来</a>&nbsp;&nbsp;|&nbsp;&nbsp;
                <a href="<%=request.getContextPath()%>/LogoutServlet">注销</a>
                <%
                  }else{
                  %>
                <a href="<%=request.getContextPath()%>/login.jsp">登录</a>&nbsp;&nbsp;|&nbsp;&nbsp;
                <a href="<%=request.getContextPath()%>/regist.jsp">注册</a>
                <%
                  }
                  %>
              </div>
            </div>
          </dic>
        #+END_SRC
        创建注销Servlet --- LogOutServlet
        #+BEGIN_SRC java
          package com.easymall.servlet;

          import javax.servlet.ServletException;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import java.io.IOException;
          //注销用户登录状态
          public class LogoutServlet extends HttpServlet {
              protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  doGet(request, response);
              }
              protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                  //注销用户登陆状态可以将session删除，删除session后其中的属性值也会注销
                  //实现用户注销的功能
                  request.getSession(false).invalidate();
                  response.sendRedirect("http://www.easymall.com");
              }
          }
        #+END_SRC
     3. 验证码的实现：
        1. request中存储验证码仅在当前request中有效，在下一次的去请求中会失效。保存数据的范围太小。
        2. ServletContext存储验证码,会在整个web应用的范围内，如果多个用户同时存储多个不同的验证码在web应用中，那么只有最后一个验证码会保存下来，会导致其他用户看到的图片验证码是真实验证码是不匹配。保存数据的范围过大。
        3. session将验证码存储在当前会话的范围内，可以在多次请求中使用，符合验证码的使用范围，而且session在多个浏览器直接也互补影响。
           1. 修改RegistServlet；在//TODO:session位置添加如下代码
              #+BEGIN_SRC java
                //验证码校验
                String code = (String) request.getSession().getAttribute("code");
                if(!valistr.equalsIgnoreCase(code)){
                    request.setAttribute("msg","验证码错误");
                    request.getRequestDispatcher("/regist.jsp").forward(request,response);
                    return;
                }
              #+END_SRC
           2. 修改ValidateServlet:
              #+BEGIN_SRC java
                package com.easymall.servlet;

                import com.easymall.utils.VerifyCode;

                import javax.servlet.ServletException;
                import javax.servlet.http.HttpServlet;
                import javax.servlet.http.HttpServletRequest;
                import javax.servlet.http.HttpServletResponse;
                import java.io.IOException;
                //生成验证码
                public class ValidateServlet extends HttpServlet {
                    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                        doGet(request, response);
                    }
                    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
                        //控制缓存，防止浏览器使用图片
                        response.setDateHeader("Expires",-1);
                        response.setHeader("Cache-control","no-cache");
                        //调用工具类产生一个验证码的图片
                        VerifyCode vc = new VerifyCode();
                        vc.drawImage(response.getOutputStream());
                        //获取验证码的纯文本内容
                        String code = vc.getCode();
                        //将创建出来的验证码加入到session域中
                        request.getSession().setAttribute("code",code);
                        System.out.println(code);
                    }
                }

              #+END_SRC
** cookie和session特点：
1. cookie特点：
   cookie是浏览器端的技术，保存在浏览器的数据可能会被其他人读取，造成数据丢失，数据安全性较差。cookie可以存储长期保存的数据。cookie适合存储安全性要求较低，而存储时间较长的数据。
2. session服务器端的技术，数据保存在服务器端安全性较高，普通用户无法读取服务器上的数据。session不善于长期存储数据，如果存储数据时间过长，会导致服务器长时间存储一个无人使用的对象，造成内存的浪费。session适合存储安全性较高，而存储时间较短的数据。
* JSP
[[./Img/JSP.png]]
[[./SourceCode/JspDemo1.jsp]]
[[./SourceCode/JspDemo2.jsp]]
[[./SourceCode/JspDemo3.jsp]]
[[./SourceCode/JSPDemo4.jsp]]
[[./SourceCode/ELDemo1.jsp]]
[[./SourceCode/ELDemo2.jsp]]
[[./SourceCode/ELDemo3.jsp]]
[[./SourceCode/cout.jsp]]
[[./SourceCode/cset.jsp]]
[[./SourceCode/cremove.jsp]]
[[./SourceCode/ccatch.jsp]]
[[./SourceCode/cif.jsp]]
[[./SourceCode/cforeach.jsp]]
[[./SourceCode/cfortokends.jsp]]
[[./SourceCode/cchoose.jsp]]
[[./SourceCode/curl.jsp]]
** 1. 概述与原理
由于在servlet中书写前台页面代码非常复杂，于是Sun提出一门新的技术--jsp，将所有的页面内容重新书写到一个文件中，在这个文件中还可以书写java语句，这样的一个文件就称之为一个jsp文件。 在jsp页面内开发HTML代码十分便利，还可以在其中嵌入java语句，使开发变得非 常简洁，直接在页面中就完成了页面构建和代码逻辑的全部内容。
- JSP原理：在jsp页面被初次访问的时候，会被jsp翻译引擎翻译成一个servlet文件，这个文件是一个普通java文件，继承了一个具有servlet接口的类，所以当前文件才会成为一个servlet文件。
- 实验:寻找如下文件 --> 在[tomcat]/work/localhost/day14/index_jsp.java文件
** 2. JSP语法
1. 模板元素
   jsp页面中的HTML内容会在浏览器发生访问的时候，被jsp翻译引擎翻译为 Servlet文件的模板元素。
   #+BEGIN_SRC html
     <body>
       <div>aaaa</div>
     </body>
   #+END_SRC
   #+BEGIN_SRC java
     out.write("<body>\r\n");
     out.write("  <div>aaaa</div>\r\n");
     out.write("<body>\r\n");
   #+END_SRC
   其实就是将HTML内容使用out.write()输出.
2. 脚本表达式
   语法:<%= 脚本表达式(具有返回值的表达式，或一个直接量) %> 在jsp页面被访问的时候，jsp翻译引擎将脚本表达式中的内容翻译为了原封不动 的表达式结果值。
   #+BEGIN_SRC html
     <h3>脚本表达式</h3>
     <%=request.getContextPath()%>
   #+END_SRC
   #+BEGIN_SRC java
     out.write("   ");
     out.print(request.getContextPath());
     out.write("\r\n");
   #+END_SRC
   翻译后的结果值直接放在servlet文件的对应位置，并使用out.print()输出表达式的值。
3. 脚本片段
   语法:<% 脚本片段(java语句) %> ；在JSP页面被访问的时候，其中脚本片段中的内容会原封不动的放在翻译后的 servlet文件制定位置。
   #+BEGIN_SRC html
     <h3>脚本表达式</h3>
     <%=request.getContextPath()%>
     <h3>脚本片段</h3>
     <%
       for(int i = 0;i<5;i++){
                        %>
       <font color='red'>I am li shuai;</font>
       <%
         }
         %>
   #+END_SRC
   #+BEGIN_SRC java
     for(int i=0;i<5;i++){
         out.write("\r\n");
         out.write("\t\t\r\n");
         out.write("\t\t<font color='red'>I am li shuai;</font>\r\n");
         out.write("\t\t\r\n");
         out.write("\t\t");
     }
   #+END_SRC
   在jsp页面中脚本片段可以分开书写，分开书写脚不片段必须要保证java语法完整，因为在jsp页面中的java语句会被翻译到servlet文件中，需要保证java语句在servlet文件中的完整性。
4. JSP声明
   语法:<%! JSP声明 %> ；在jsp页面被访问的时候，其中的jsp声明会被jsp翻译引擎翻译为当前servlet的成 员变量，成员方法，静态代码块等内容。被翻译后的成员内容都会出现在类内方法外，作为成员内容使用。
   #+BEGIN_SRC html
     <h3>JSP声明</h3>
     <%! int i=0;%>
     <%! public void m(){}%>
     <%!static{}%>
   #+END_SRC
   #+BEGIN_SRC java
     public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent{
         int i = 0;
         public void m(){}
         static{}
     }
   #+END_SRC
5. JSP注释
   | <%//abc%>   | 被翻译成java注释内容，由于是注释内容所以不会输出任何内容                                 |
   | <!-- def--> | HTML注释被翻译成模板元素，由于是HTML注释，所以不会输出任何内容，但是仍然会出现在页面中。 |
   | <%--ghi--%> | 在翻译过程中直接被抛弃，不会出现在翻译后的servlet文件中。                                |
6. JSP指令
   - 语法:<%@指令名称 %>
   - 指令
     指令本身不会产生任何的输出内容，是用来控制jsp翻译引擎如何来翻译jsp页面 的。
     | page    | <%@page%>    | 用户指定当前页面依赖哪些配置翻译页面。 |
     | include | <%@include%> | 在当前jsp页面引入其他jsp页面           |
     | taglib  | <%@taglib%>  | 标签技术                               |
     1. *language="java"*
        当前JSP使用的开发语言
     2. *extends="package.class"*
        当前jsp翻译成servlet后要继承的类，注意此值必须是一个servlet的子类，一般情况下不要改
     3. *import="{package.class | package.**}, ..."
        导入需要使用到的包 /java.lang.*;javax.servlet.*;javax.servlet.jsp.*;javax.servlet.http.*;/
     4. *session="true | false"*
        用来指定当前页面是否使用session，如果设置为true，则翻译过来的servlet中将会 有对session对象的引用，于是可以直接在jsp中使用session隐式对象。但是这将导 致一旦访问jsp就会调用request.getSession()方法，可能导致不必要的空间浪费。如 果确定jsp中不需要session可以设为false
     5. *[ buffer="none | 8kb | sizekb" ]*
        out隐式对象所使用的缓冲区的大小
     6. *[autoFlush="true | false"]*
        out隐式对象是否自动刷新缓冲区，默认为true，不需要更改
     7. *[ isThreadSafe="true | false" ]*
        翻译过来的servlet是否实现SingleThreadModel
     8. *[ errorPage="relative_url" ]*
        如果页面出错，将要跳转到的页面，除了在jsp中使用此属性指定错误页面外也可以在web.xml中配置整个web应用的错误页面，如果两个都设置则jsp中的此属性起作用
        #+BEGIN_SRC html
          <error-page>
              <error-code>404</error-code>
              <location>/error/404.jsp</location>
          </error-page>
          <error-page>
              <error-code>500</error-code>
              <location>/error/500.jsp</location>
          </error-page>
        #+END_SRC
     9. *[ isErrorPage="true | false" ]*
        如果设置此属性为true,翻译过来的servlet中将含有Exception隐式对象,其中封装的就 是上一个页面中抛出的异常对象
     [[./Img/66.png]]
     10. *[ contentType="mimeType [ ;charset=characterSet ]" | "text/html ; charset=ISO-8859-1" ]*
         和jsp乱码相关的指令,用来指定jsp输出时,设置的Content -Type响应头用来指定浏览 器打开的编码
     11. *[ pageEncoding="characterbSet | ISO-8859-1"]*
         服务器翻译jsp时使用的编码集.如果向防止jsp乱码,应该保证文件的保存编码和jsp翻 译成servlet用的编码以及输出到浏览器后浏览器打开的编码一致.此属性一旦设置好, 翻译引擎会间接帮我们设置content-type属性.
     12. include指令
         在当前的jsp页面中引入其他的jsp页面，将组合之后的页面输出在浏览器。 <%@include file=""%>
     13. taglib指令
         标签技术 <%@taglib %>
** 3. 九大隐式对象
   在jsp翻译成一个servlet后，其中都可以包含9大隐式对象，其中Exception、session 需要手动开启。在每一个jsp页面中都会有自己独立的9大隐式对象，每一个隐式对 象所具有的变量名可以直接使用，在自行定义新的变量时 应避免与已有隐式对象 名称重复。
   - 面试题经常考:
     九大隐式对象:
     1. page --- 代表当前Servlet的对象
     2. request --- 代表当前请求的对象
     3. response --- 代表当前响应的对象
     4. session --- 代表当前会话的对象
     5. application --- 代表当前web应用的对象
     6. config --- 代表当前servlet配置信息的对象 exception--- 代表当前页面产生的异常信息对象
     7. exception --- 代表当前页面产生的异常信息对象
     8. out --- 代表当前jsp页面向浏览器输出数据的对象 pageContext --- 代表当前jsp页面上下文的对象
     9. pageContext --- 代表当前jsp页面上下文的对象
** 4. PageContext详解
   1. 功能一:可以作为其他八大隐式对象的入口。
      1. getException方法返回exception隐式对象
      2. getPage方法返回page隐式对象
      3. getRequest方法返回request隐式对象
      4. getResponse方法返回response隐式对象
      5. getServletConfig方法返回config隐式对象
      6. getServletContext方法返回application隐式对象
      7. getSession方法返回session隐式对象
      8. getOut方法返回out隐式对象
   2. 功能二:域对象
      1. 相关的方法:
         setAttribute() getAttribute() removeAttribute() getAttributeNames()
      2. 生命周期: 当前jsp页面被访问的时候创建，当前jsp访问结束的时候销毁。
      3. 作用范围: 当前jsp页面。
      4. 主要功能: 当前jsp页面内共享数据。
   3. 功能三:可以作为其他三大作用域的入口对象使用:
      scope是int类型的一个值，代表作用域.
      #+BEGIN_SRC
        setAttribute(String name,Obejct obj,int scope);
        getAttribute(String name,int scope);
        removeAttribute(String name,int scope);
        getAttributeNamesInScope(int scope);
      #+END_SRC
      | PageContext.APPLICATION_SCOPE | ServletContext |
      | PageContext.SESSION_SCOPE     | Session        |
      | PageContext.REQUEST_SCOPE     | request        |
      | PageContext.PAGE_SCOPE        | page           |
      获取指定域中的数据：
      #+BEGIN_SRC html
        <h4>获取指定域当中的数据</h4>
        page:<%=pageContext.getAttribute("country",PageContext.PAGE_SCOPE)%>
        request:<%=pageContext.getAttribute("country",PageContext.REQUEST_SCOPE)%>
        session:<%=pageContext.getAttribute("country",PageContext.SESSION_SCOPE)%>
        application:<%=pageContext.getAttribute("country",APPLICATION_SCOPE)%>
      #+END_SRC
      直接获取pageContext域属性
      #+BEGIN_SRC html
        <h4>直接书写pageCOntext获取的是pageContext域</h4>
            <%=pageContext.getAttribute("country")%>
      #+END_SRC
      删除指定域中属性
      #+BEGIN_SRC html
        <h4>删除指定域中属性</h4>
          <%
              pageContext.removeAttribute("country",PageContext.PAGE_SCOPE);
          %>
      #+END_SRC
   4. 功能四:便捷的请求转发
      #+BEGIN_SRC java
        pageContext.forward("path");
      #+END_SRC
** 5. 四大作用域
1. 域对象概念
   一个对象身上有一个可以被看见的范围,在这个范围内利用对象身上的map实现资源的共享,像这样一个对象就称之为域对象.
2. 四个域对象
   由大到小的顺序排列:
   #+BEGIN_SRC
     ServletContext > Session > Request > PageContext
          web应用        会话       请求       jsp页面
   #+END_SRC
   1. ServletContext
      代表web应用的对象
      1. 生命周期:
         web应用加载的时候ServletContext对象创建，web应用被移出容器，ServletContext对象销毁。
      2. 作用范围:
         整个web应用的范围。
      3. 主要功能:
         在整个web应用的范围内实现资源的共享。
   2. Session
       代表session会话的对象
       1. 生命周期:
          调用request.getSession()方法是session对象创建。
          - 超时死亡:如果一个session在30分钟内没有任何操作，则服务器认为 这个session无人认领，可以销毁。
          - 自杀:session对象主动调用invalidate()，自行释放。
          - 意外身亡:服务器非正常关闭的时候session对象也会销毁。如果服务器正常关闭是仍有session对象没有释放，则session中的数据会序列化 到本次磁盘上，作为一个文件保存，这个过程叫做钝化，在服务器再 次启动的时候会将这个文件读取，这个过程称之为活化。
       2. 作用范围:
          整个会话范围。
       3. 主要功能:
          在整个会话范围内共享数据。
   3. request
      代表request请求的对象
      1. 生命周期:
         请求链开始的时候request对象创建，请求链结束的时候request对象销毁。
      2. 作用范围:
         整个请求链。
      3. 主要功能:
         在整个请求链中实现数据的共享。
   4. pageContext
      代表当前jsp页面上下文的对象
      1. 生命周期:
         当前jsp页面加载的时候pageContext创建，访问结束时pageContext对象销毁
      2. 作用范围:
         当前jsp页面。
      3. 主要功能:
         在当前jsp页面内实现数据的共享。
** 6. 示例
#+BEGIN_SRC html
  <%@ page language="java" import="java.util.*" pageEncoding="UTF-8" isErrorPage="true"%>
  <!DOCTYPE HTML >
  <html>
    <head>
      <title>pageContext详解</title>
    </head>
    <body>
      <h3>功能一：作为其他八大隐式对象的入口</h3>
      <%
        pageContext.getPage();
        %>
      <h3>功能二：作为域对象使用</h3>
      <%
        pageContext.setAttribute("name", "lishuai");
        %>
      <br/>
      pageContext域中取出数据：
      <%=
        pageContext.getAttribute("name")
        %>
      <h3>功能三：作为三大作用域的入口</h3>
      <%
        pageContext.setAttribute("country", "China", PageContext.APPLICATION_SCOPE);
        pageContext.setAttribute("country", "US", PageContext.SESSION_SCOPE);
        pageContext.setAttribute("country","UK",PageContext.REQUEST_SCOPE);
        pageContext.setAttribute("country","Japan",PageContext.PAGE_SCOPE);
        %>
      <h4>获取指定域当中的数据</h4>
      page：<%=pageContext.getAttribute("country", PageContext.PAGE_SCOPE) %>
      request：<%=pageContext.getAttribute("country",PageContext.REQUEST_SCOPE) %>
      session：<%=pageContext.getAttribute("country",PageContext.SESSION_SCOPE) %>
      application:<%=pageContext.getAttribute("country",PageContext.APPLICATION_SCOPE) %>
      <h4>直接书写pageContext获取的是pageContext域</h4>
      <%=pageContext.getAttribute("country") %>
      <h4>删除指定域中属性</h4>
      <%
        pageContext.removeAttribute("country", PageContext.PAGE_SCOPE);
        %>
      删除之后的page域：<%=pageContext.getAttribute("country") %>
      <h4>便捷的请求转发</h4>
      <%
        //pageContext.forward("/2.jsp");
        %>
    </body>
  </html>

#+END_SRC
** 7. JSP标签技术
1. JSP标签技术概述
   Jsp当前可以书写HTML内容和Java语句，便于开发，但是面对大量逻辑需要处理和 复杂的页面构成的时候，HTML和java的结合就无法做到合理维护和高效开发。这 时可以将页面中的java语句都变成标签内容，让标签处理java语句对应的逻辑，也 就是说利用标签代替java，这样就可以保证页面内只出现标签内容，这样的页面只 有一种语言，相比之前便于维护和关闭，可以提升开发效率。
2. 常用的JSP标签技术
   1. jsp标签技术
      Sun公司开发
   2. el表达式
      便捷易用 - 使用广泛 - 只能获取值 不能设置值。
   3. jstl标签技术
      标签库数据庞大，可以覆盖多数的开发需求。
   4. 自定义标签
   5. 其他第三方标签
* EL表达式
1. EL表达式概述
   EL全名为Expression Language，用来替代<%=%>脚本表达式；EL具有获取数据、执行运算、获取常用开发对象、调用java方法这四方面的功能；javaEE目前内置了EL表达式，可以在jsp页面中直接使用
2. EL表达式使用方式
   ${el表达式}
3. EL表达式的特点
   只能获取数据
   不能设置数据
   不能遍历数据
4. 功能一:获取数据
   1. 获取常量
      #+BEGIN_SRC html
        <h4>获取常量</h4>
          脚本片段书写:<br/>
          <%=123 %>
          <%="abc"%>
            <%=true%>
            <%=1.1%>
            <br/>el表达式书写:<br/>
            ${123}
            ${"abc" }
            ${true }
            ${1.1 }
        #+END_SRC
   2. 自动搜寻域
      所谓自动搜寻域就是从最小范围的域中开始检索一个指定名称的域属性，如果在较小范围内找到了这个域属性，则直接将找到的域属性返回，当前范围的域中如果没有指定名称的域属性，则向更大的域中去搜寻，直到找到指定 名称的域属性。
      总结:由小到大的搜索域中的属性。
      #+BEGIN_SRC html
        <h4>自动搜寻域</h4>
        <%
            application.setAttribute("name", "兰刚");
            session.setAttribute("name","朴乾");
            request.setAttribute("name","李帅");
            //pageContext.setAttribute("name","张三");
        %>
        <%=pageContext.findAttribute("name") %>
        ${name }
      #+END_SRC
      el表达式自动搜寻域，只需要指定一个域属性的名称即可，它会自动在四个 作用域中寻找指定名称的域属性。
   3. 获取指定域中的数据
      #+BEGIN_SRC html
        <h4>获取指定域中的属性</h4>
            <%
              application.setAttribute("job", "IT");
              session.setAttribute("job", "teacher");
              request.setAttribute("job", "doctor");
              pageContext.setAttribute("job", "work");
            %>
            <%=pageContext.getAttribute("job", PageContext.APPLICATION_SCOPE) %>
              el表达式获取指定域的属性:
              ${applicationScope.job}
              ${sessionScope.job }
              ${requestScope.job } ${pageScope.job }
      #+END_SRC
      el表达式中域名称书写形式:
      | 脚本片段           | el表达式         |
      | APPLICATION_SCOPE | applicationScope |
      | SESSION_SCOPE     | sessionScope     |
      | REQUEST_SCOPE     | requestScope     |
      | PAGE_SCOPE        | pageScope        |
   4. 获取数组中的元素
      el表达式可以获取数组中指定下标的元素，但是数据必须要在某一个域中， 才可以获取其中的数据。
      #+BEGIN_SRC html
        <h4>el表达式数组中获取数据</h4>
        <%
            String[] names={"殷正天","黛绮丝","谢逊","韦一笑"};
            pageContext.setAttribute("names",names);
        %>
        ${names[1]}
      #+END_SRC
      获取一个元素的时候，需要指定元素的下标。
   5. 获取集合中的元素
      #+BEGIN_SRC html
        <h4>获取集合中的元素</h4>
        <%
            List<String> list=new ArrayList<String>();
            list.add("大数据");
            list.add("小数据");
            list.add("中数据");
            pageContext.setAttribute("list",list);
        %>
        ${list[0]}
      #+END_SRC
      集合中获取元素和数组中获取元素的方式类似，都可以通过指定一个下标来获取元素。
   6. 获取Map中的元素
      #+BEGIN_SRC html
        <h4>获取Map中的元素</h4 >
        <%
            Map<String,String> map = new HashMap<String,String>();
            map.put("name", "李帅");
            map.put("武功","黯然销魂掌");
            map.put("wife","姑姑");
            map.put("wife.one","小龙女");
            pageContext.setAttribute("map", map);
            /* 书写一个字符串数据添加到域中，即可获取变量名中包含的数据 */
            pageContext.setAttribute("wife", "wife");
        %>
        ${map["name"]}
        ${map.武功}
        ${map[wife]}
        ${map["wife.one"]}
      #+END_SRC
   7. 获取javabean中属性
      #+BEGIN_SRC html
        <h3>获取javabean中的元素</h3>
        <%
            Person p = new Person();
            p.setName("lishuai");
            p.setAge(18);
            p.setAddr("bj");
            pageContext.setAttribute("p", p);
        %>
        ${p.name}
        ${p.age}
        ${p.addr}
      #+END_SRC
5. 执行运算
   1. 算术运算:
      #+BEGIN_SRC html
        <h3>el表达式功能二:运算</h3>
            <h4>算术运算</h4>
            ${2+3 }
            ${2-3 }
            ${3/2 }
            ${3%2 }
            <hr>
            ${2+"3" }
            <hr>
            ${"2"+"3" }
            在加法中如果有字符串类型的数据，尝试将这个数据转换成一个数值类型，如果能够转换则 转换过后执行运算，如果不能转换则会报错。
            <%-- ${2+"a" } --%>
      #+END_SRC
   2. 关系运算:
      #+BEGIN_SRC html
        <h4>关系运算</h4>
            ${3>2}
            ${3<2}
            ${3>=2}
            ${3<=2}
            ${3!=2 }
      #+END_SRC
   3. 逻辑运算:
      #+BEGIN_SRC html
        <h4>逻辑运算</h4>
            ${true and false }
          ${true or false }
          ${not(true) }
          ${true && false }
          ${true || false }
          ${!true }
          ${!true }
      #+END_SRC
   4. Empty运算:
      如果对象为null，字符串保存的值为""，数组和集合以及map中没有数据，使用empty运算的结构都为true，其他任何形式都为false.
      #+BEGIN_SRC html
        <h4>empty运算</h4>
        <%
            String a = null;
            String str = "aaaa";
            String[] arr = {"1"};
            ArrayList list = new ArrayList();
            list.add("abc");
            Map map = new HashMap();
            pageContext.setAttribute("a",a);
            pageContext.setAttribute("str",str);
            pageContext.setAttribute("arr",arr);
            pageContext.setAttribute("list",list);
            pageContext.setAttribute("map", map);
        %>
        ${empty a}
        ${empty str}
        ${empty arr}
        ${empty list}
        ${empty map}
      #+END_SRC
   5. 三元表达式:
      #+BEGIN_SRC html
        <h4>三元表达式</h4>
        <%
            Map<String,String> mapx = new HashMap<String,String>();
            mapx.put("a","aa");
            mapx.put("b","bb");
            mapx.put("c","cc");
            pageContext.setAttribute("mapx", mapx);
        %>
        ${empty mapx.b?"yes":"no" }
      #+END_SRC
6. 获取常用开发对象
   EL内置的11个内置对象。
   1. 代表域的内置对象
      | pageScope        | 代表pageContext域    |
      | requestScope     | 代表request域        |
      | sessionScope     | 代表session域        |
      | applicationScope | 代表ServletContext域 |
   2. 代表请求参数的内置对象
      | param       | 代表当前请求中的请求参数信息，获取的结果组成Map<String,String>     |
      | paramValues | 代表当前你请求中的请求参数信息，获取的结果组成Map<String,String[]> |
   3. 代表请求头的内置对象
      | header       | 代表请求中的请求头信息，获取的结果组成Map<String,String>   |
      | headerValues | 代表请求中的请求头信息，获取的结果组成Map<String,String[]> |
   4. 代表web应用初始化配置信息的内置对象
      | initParam | 代表当前web应用的初始化配置信息的对象 |
   5. 代表当前请求头中的cookie组成的内置对象
      | cookie | 代表当前请求头中的cookie，获取的结果组成Map<String,String[]> |
   6. 代表pageContext(页面中的上下文)的内置对象
      pageContext
   #+BEGIN_SRC html
     <%@page import="java.util.Map"%>
     <%@page import="java.util.HashMap"%>
     <%@page import="java.util.ArrayList"%>
     <%@ page language="java" pageEncoding="UTF-8"%>
     <!DOCTYPE html >
     <html>
       <head>
         <title>el表达式</title>
       </head>
       <body>
         <h3>el表达式功能三：获取对象</h3>
         <h4>四个作用域</h4>
         ${pageContext.request.contextPath}
         <h4>请求参数</h4>
         <%=request.getParameter("username") %>
         ${param.username }
         <h4>请求头</h4>
         ${header.host }
         <h4>web应用初始化配置信息的对象</h4>
         ${initParam.key01 }
         <h4>cookie</h4>
         ${cookie.JSESSIONID.name }
         ${cookie.JSESSIONID.value }
       </body>
     </html>
   #+END_SRC
   #+BEGIN_SRC xml
     <context-param>
         <param-name>key01</param-name>
           <param-value>value01</param-value>
     </context-param>
   #+END_SRC
7. 调用java方法
   略
* JSTL标签库
** 1. 概述
JSTL全程JavaServerPages Standard Tag Library。由JCP（Java Community Process）指定标准，是提供给Java Web开发人员一个标准通用的标签函数库。可以和EL配合来取代传统直接在页面上嵌入Java程序（Scripting）的做法，以提高程序可读性、维护性和方便性。
** 2. 在页面中引入JSTL标签库
Java EE 5包及其以上版本都已经支持jstl标签库，所以在页面中直接书写指令引入使用即可。
<%@taglib uri="" prefix=""%>
* javaEE开发模式
1. 纯Servlet开发 单纯的servlet开发，如果面对复杂页面将会难于处理，所以前台HTML内容还是应 该放在页面中书写。
2. 纯JSP开发
   相比servlet开发，纯jsp开发比较简单，但是面对复杂页面构成和代码逻辑的时 候，HTML内容和Java语句内容相互嵌套，如果书写有误则会造成完全无法使用， 代码可读性低，可维护性需求较高，便捷性较低。
3. JSP+JSP标签库
   利用JSP+JSP标签库的确简化了页面内容，但是面对复杂的逻辑需求是，在JSP页 面中标签库可能无法处理，需要自行设计标签，而且这些标签域HTML标签相互 嵌套，对于页面代码的可读性来说还是较低，由于逻辑代码和页面展示代码耦合 在一起所以管理起来十分不便。
4. java+javaBean (Model One 模式一)
   在模式一中JSP页面负责展示页面内容和调用javaBean中的方法。在javaBean中负 责提供封装数据和提供方法。在JSP页面中既展示HTML内容也书写java代码逻辑， 一个模块进行两个模块的工作，导致如果出现问题，模块之间会相互影响，所以 应该将JSP页面中的两部分工作，拆分成两个模块，降低模块之内的耦合性。
5. Servlet+javaBean+JSP Model Two模式二
   模式二将javaEE处理的数据分成了三部分。在Servlet中主要负责接收请求，和根 据请求调用javabean中的方法。在javaBean中主要负责封装数据和提供方法。杂 JSP页面中只负责数据和页面的展示。在这样的模型下，摸一个模块都进行各自模
   分区 day15-javaEEDesignModel 的第 1 页
   JSP页面中只负责数据和页面的展示。在这样的模型下，摸一个模块都进行各自模 块功能，各个模块之间已经很大程度的降低了耦合性，各自执行各自的工作，当 前模块产生异常，只需寻找当前模块的异常问题，无序寻找其他模块的问题。
   #+BEGIN_SRC
     三个模块之间:
        相互独立。虽然存在耦合，但是这个耦合是必要的存在，如果抛弃这个耦合将会使每个模块完全独立，导致无法一起工作。
        模块之间相互协作，可读性已经最大程度的提升，代码量虽然有所上升，但是更加便于代码的维护和管理。
   #+END_SRC
6. MVC设计思想
   MVC设计思想并不是javaEE特有的设计思想，而是在设计程序代码的时候，一个 通用的设计思想，在其他语言和程序中同样也适用。
   MVC设计思想一共分为三个部分，第一是负责接收用户发送请求的Controller(控 制器),接收请求之后，根据用户请求的内容，调用对应模型中的方法。第二是负 责提供封装数据和方法的Model(模型),模型中有用户请求发送来的数据，以及数 据处理的方法，model处理完用户数据之后，将结果数据再次范围到Controller 中。第三是负责展示用户结果数据View(视图),View中，将Controller传递的结 果数据不做任何处理直接展示到页面当中。
   特点:
       MVC中三个模块都各自执行各自模块的功能，模块之间相互独立。 正是因为模块之间相互独立，所以代码的管理更加便捷，可维护性更强。
7. JavaEE经典三层架构
* 重构EasyMall项目
1. 创建EasyMall web应用
2. 将原有EasyMall的静态资源引入
   将原有web应用全部静态资源复制到新的EasyMallweb应用中
3. 导入开发包以及配置文件 在WEB-INF的lib中有开发所需包
4. 复制web.xml文件内容 将原有web应用的web.xmln内容复制到新的EasyMall 的web.xml中
5. 根据经典架构---构建新的目录结构
6. 导入动态资源和工具类
7. 修改web.xml文件中的配置信息
   将原有的com.easymall.servlet 更改为com.easymall.web
8. 创建JavaBean--User 用来存储用户信息数据
   #+BEGIN_SRC java
   #+END_SRC
9. 实现登录功能:
   1. 修改LoginServlet
   2. 创建UserService
   3. 创建异常类MsgException
   4. 创建UserDao
   5. head.jsp修改:
10. 实现注册功能
    1. 修改 RegistServlet:
    2. 修改UserService:
    3. 修改UserDao:
11. 注销功能
12. 作业:
    a. 配置一个错误友好提示页面。<error-page></error-page>
1. JSTL标签库概述
   JSTL全称为JavaServerPages Standard Tag Library。由JCP(Java Community Process)指定标准。是提供给 Java Web 开发人员一个标准通用的标签函数库。可以和 EL 配合来取代传统直接在页面上嵌入 Java 程序(Scripting)的做法，以提高程 序可读性、维护性和方便性。
2. 在页面中引入jstl标签库
   java EE 5包及其以上版本都已经支持jstl标签库，所以在页面中直接书写指令引入使用即可。
   #+BEGIN_SRC
     <%@taglib uri="" prefix=""%>
   #+END_SRC
3. JSTL标签库的子库
   核心标签库 core - c
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
    国际化标签 fmt
    数据库标签 sql
    XML标签 xml
    JSTL函数(EL函数)
4. 命名空间或名称空间概念
   在uri中包含两部分内容，一个是url，是常见的location地址保存形式。还有一个URN保存 的内容是一个名称，这个名称看起来像是一个地址，但是本质存储的是一个Naming，所 以把这中命名方式称之为名称空间或者命名空间。
5. 核心函数库
   1. c:set标签
      设置或修改域中的值，设置或修改map中的值，设置修改javaBean中的数据
      #+BEGIN_SRC
        <h4>c:set标签，设置或修改值</h4>
            <c:set var="a" value="bj" scope="request"></c:set>
            ${a}
            <c:set var="a" value="sh" scope="request"></c:set>
            ${a}
        <h3>c:set设置或修改map中的值</h3>
            <%
                Map<String,String> map = new HashMap<String,String>();
                pageContext.setAttribute("map", map);
            %>
            <c:set target="${map }" property="addr" value="重庆"></c:set> ${map }
            ${map.addr}
            ${map.addr}
            <c:set target="${map }" property="addr" value="宝安"></c:set> ${map.addr }
        <h4>c:set设置或修改javabean中的属性</h4>
            <%
                Person p = new Person("李帅",18,"北京");
                pageContext.setAttribute("p",p);
            %>
            <c:set target="${p }" property="name" value="朴乾"></c:set>
            ${p.name }
            ${p.age }
              <!-- javabean中不存在的属性不能直接设置值 -->
              <%-- <c:set target="${p }" property="gender" value="男"></c:set>--%>
              <%-- ${p.gender } --%>
        #+END_SRC
   2. c:remove 删除指定域中的域属性
      #+BEGIN_SRC
        <h3>c:remove</h3>
            <h4>c:remove删除指定域中的域属性</h4>
            <c:set var="name" value="张三丰" scope="request"></c:set>
            ${name}
            <br>
                <c:remove var="name" scope="request"></c:remove>
                调用remove:${name }
        <h4>删除全部域中的域属性</h4>
        <%
            application.setAttribute("namex", "大一");
            session.setAttribute("namex", "大二");
            request.setAttribute("namex", "大三");
            pageContext.setAttribute("namex", "大四");
        %>
        <%-- <c:remove var="namex"></c:remove> --%>
        <c:remove var="namex" scope="request"></c:remove>
        ${applicationScope.namex }
        ${sessionScope.namex }
        ${requestScope.namex }
        ${pageScope.namex }
   3. c:if判断
      #+BEGIN_SRC
       <h3>c:if</h3>
           <h4>c:if判断</h4>
            <c:set var="i" value="10" scope="request"></c:set>
            <c:if test="${i<=10 }" var="flag">
                no~~~
            </c:if>
            <c:if test="${i>10 }" var="f">
                yes
            </c:if> ${flag }
            ${f }
      #+END_SRC
   4. c:catch 捕获异常
      #+BEGIN_SRC
        <h3>c:catch</h3>
            <h4>c:catch捕获异常信息</h4>
            <c:catch var="e">
                <%
                    String str = null;
                    str.toUpperCase();
                %>
            </c:catch>
            ${e }
      #+END_SRC
   5. c:choose 多重判断
      可以实现一个类似于if else的判断结构。
      #+BEGIN_SRC
        <h3>c:choose</h3>
            <h4>c:choose实现多重判断</h4>
            <c:set var="b" value="18" scope="request"></c:set>
            <c:choose >
                <c:when test="${b<10 }" >小于10</c:when>
                <c:when test="${b<100 }">大于10小于100</c:when>
                <c:when test="${b<1000 }">大于100小于1000</c:when>
                <c:other w is e>大 于 10 00</c:other w is e>
            </c:choose>
    #+END_SRC
    多重判断的结果不需要使用变量展示，满足c:when或者从c:otherwise结果会打印在页面当中。
   6. c:forEach 遍历循环
      可以循环指定数据内容，也可以遍历一个数据结构。
      forEach中有varStatus属性，属性可以引用的内容如下:
      1. 如果是利用自身数据遍历:
         #+BEGIN_SRC
           <c:forEach begin="10" end="100" step="1" var="o" varStatus="stat">
               ${stat.index }
           </c:forEach>
         循环中会认为10即为第十个下标。打印结果为 10 11 12
      2. 如果是遍历其他数据结构:
         #+BEGIN_SRC
         <%
            List<String> list = new LinkedList<String>();
            list.add("danny");
            list.add("jenny");
            list.add("liming");
            list.add("laowang");
            pageContext.setAttribute("list", list);
         %>
         <c:forEach items="${list }" var="h" varStatus="stat">
         ${h }
         ${stat.index }
         </c:forEach>
         #+END_SRC
         循环中下标会从0开始计数,打印结果为 danny 0 jenny1 .....
         #+BEGIN_SRC
           <h3>c:forEach实现循环</h3>
               <h4>c:forEach循环数字</h4>
               <c:forEach begin="1" end="100" step="1" var="q">
                   ${q }
               </c:forEach>
               <h4>c:forEach遍历链表</h4>
               <%
                  List<String> list = new LinkedList<String>();
                  list.add("danny");
                  list.add("jenny");
                  list.add("liming");
                  list.add("laowang");
                  pageContext.setAttribute("list", list);
               %>
               <c:forEach items="${list }" var="h">
                   ${h}
               </c:forEach>
               <c:forEach begin="10" end="100" step="1" var="o" varStatus="stat">
                   ${stat.index }
               </c:forEach>
               <br>
         #+END_SRC
         问题:遍历一个10到100的全部偶数，如果当前总数的下标为3的倍数，则将这个数据变为红色。
         #+BEGIN_SRC
           <c:forEach begin="10" end="100" step="2" var="r" varStatus="s">
               <c:if test="${s.count%3 == 0}">
                   <font color="red">${r }</font> </c:if>
               <c:if test="${s.count%3 != 0 }">
                   <font color="blue">${r }</font>
               </c:if>
           </c:forEach>
         #+END_SRC
* 修改EasyMall页面
1. 将页面中的java代码替换为el表达式和jstl标签
